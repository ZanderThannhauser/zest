#include "zebu.h"

#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif

#include <limits.h>
#include <stdarg.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <assert.h>
#include <stdio.h>
#include <errno.h>

const unsigned zebu_shifts[168][22] = {
	[1][2] = 2,
	[1][3] = 3,
	[1][4] = 4,
	[1][5] = 5,
	[1][6] = 6,
	[2][7] = 17,
	[3][2] = 18,
	[3][3] = 19,
	[3][4] = 20,
	[3][5] = 21,
	[3][6] = 22,
	[5][3] = 30,
	[6][3] = 31,
	[7][11] = 32,
	[7][12] = 33,
	[8][2] = 2,
	[8][3] = 3,
	[8][4] = 4,
	[8][5] = 5,
	[8][6] = 6,
	[9][13] = 35,
	[9][14] = 36,
	[9][15] = 37,
	[10][8] = 38,
	[11][2] = 2,
	[11][3] = 3,
	[11][4] = 4,
	[11][5] = 5,
	[11][6] = 6,
	[12][9] = 40,
	[12][10] = 41,
	[16][16] = 42,
	[17][2] = 43,
	[17][3] = 3,
	[17][4] = 4,
	[17][5] = 5,
	[17][6] = 6,
	[19][2] = 18,
	[19][3] = 19,
	[19][4] = 20,
	[19][5] = 21,
	[19][6] = 22,
	[21][3] = 46,
	[22][3] = 47,
	[23][11] = 48,
	[23][12] = 49,
	[24][13] = 50,
	[24][14] = 51,
	[24][15] = 52,
	[25][18] = 53,
	[26][9] = 54,
	[26][10] = 55,
	[30][2] = 18,
	[30][3] = 19,
	[30][4] = 20,
	[30][5] = 21,
	[30][6] = 22,
	[31][2] = 57,
	[31][3] = 58,
	[31][4] = 59,
	[32][2] = 43,
	[32][3] = 3,
	[32][4] = 4,
	[32][5] = 5,
	[32][6] = 6,
	[33][2] = 43,
	[33][3] = 3,
	[33][4] = 4,
	[33][5] = 5,
	[33][6] = 6,
	[35][2] = 43,
	[35][3] = 3,
	[35][4] = 4,
	[35][5] = 5,
	[35][6] = 6,
	[36][2] = 43,
	[36][3] = 3,
	[36][4] = 4,
	[36][5] = 5,
	[36][6] = 6,
	[37][2] = 69,
	[37][3] = 70,
	[37][4] = 71,
	[37][5] = 72,
	[37][6] = 73,
	[40][2] = 43,
	[40][3] = 3,
	[40][4] = 4,
	[40][5] = 5,
	[40][6] = 6,
	[41][2] = 43,
	[41][3] = 3,
	[41][4] = 4,
	[41][5] = 5,
	[41][6] = 6,
	[42][2] = 2,
	[42][3] = 3,
	[42][4] = 4,
	[42][5] = 5,
	[42][6] = 6,
	[44][8] = 85,
	[45][18] = 86,
	[46][2] = 18,
	[46][3] = 19,
	[46][4] = 20,
	[46][5] = 21,
	[46][6] = 22,
	[47][2] = 57,
	[47][3] = 58,
	[47][4] = 59,
	[48][2] = 18,
	[48][3] = 19,
	[48][4] = 20,
	[48][5] = 21,
	[48][6] = 22,
	[49][2] = 18,
	[49][3] = 19,
	[49][4] = 20,
	[49][5] = 21,
	[49][6] = 22,
	[50][2] = 18,
	[50][3] = 19,
	[50][4] = 20,
	[50][5] = 21,
	[50][6] = 22,
	[51][2] = 18,
	[51][3] = 19,
	[51][4] = 20,
	[51][5] = 21,
	[51][6] = 22,
	[52][2] = 69,
	[52][3] = 70,
	[52][4] = 71,
	[52][5] = 72,
	[52][6] = 73,
	[54][2] = 18,
	[54][3] = 19,
	[54][4] = 20,
	[54][5] = 21,
	[54][6] = 22,
	[55][2] = 18,
	[55][3] = 19,
	[55][4] = 20,
	[55][5] = 21,
	[55][6] = 22,
	[56][18] = 99,
	[58][2] = 18,
	[58][3] = 19,
	[58][4] = 20,
	[58][5] = 21,
	[58][6] = 22,
	[60][18] = 99,
	[61][2] = 57,
	[61][3] = 58,
	[61][4] = 59,
	[62][19] = 105,
	[62][20] = 106,
	[62][21] = 107,
	[64][9] = 40,
	[64][10] = 41,
	[67][11] = 32,
	[67][12] = 33,
	[70][2] = 18,
	[70][3] = 19,
	[70][4] = 20,
	[70][5] = 21,
	[70][6] = 22,
	[72][3] = 109,
	[73][3] = 110,
	[74][11] = 111,
	[74][12] = 112,
	[75][13] = 113,
	[75][14] = 114,
	[75][15] = 115,
	[76][7] = 116,
	[77][9] = 117,
	[77][10] = 118,
	[87][18] = 119,
	[88][18] = 119,
	[90][9] = 54,
	[90][10] = 55,
	[93][11] = 48,
	[93][12] = 49,
	[95][7] = 122,
	[101][18] = 123,
	[104][2] = 57,
	[104][3] = 58,
	[104][4] = 59,
	[105][2] = 125,
	[105][3] = 126,
	[105][4] = 127,
	[106][2] = 129,
	[106][3] = 130,
	[106][4] = 131,
	[107][2] = 135,
	[107][3] = 136,
	[107][4] = 137,
	[108][18] = 140,
	[109][2] = 18,
	[109][3] = 19,
	[109][4] = 20,
	[109][5] = 21,
	[109][6] = 22,
	[110][2] = 57,
	[110][3] = 58,
	[110][4] = 59,
	[111][2] = 69,
	[111][3] = 70,
	[111][4] = 71,
	[111][5] = 72,
	[111][6] = 73,
	[112][2] = 69,
	[112][3] = 70,
	[112][4] = 71,
	[112][5] = 72,
	[112][6] = 73,
	[113][2] = 69,
	[113][3] = 70,
	[113][4] = 71,
	[113][5] = 72,
	[113][6] = 73,
	[114][2] = 69,
	[114][3] = 70,
	[114][4] = 71,
	[114][5] = 72,
	[114][6] = 73,
	[115][2] = 69,
	[115][3] = 70,
	[115][4] = 71,
	[115][5] = 72,
	[115][6] = 73,
	[116][2] = 43,
	[116][3] = 3,
	[116][4] = 4,
	[116][5] = 5,
	[116][6] = 6,
	[117][2] = 69,
	[117][3] = 70,
	[117][4] = 71,
	[117][5] = 72,
	[117][6] = 73,
	[118][2] = 69,
	[118][3] = 70,
	[118][4] = 71,
	[118][5] = 72,
	[118][6] = 73,
	[122][2] = 18,
	[122][3] = 19,
	[122][4] = 20,
	[122][5] = 21,
	[122][6] = 22,
	[126][2] = 18,
	[126][3] = 19,
	[126][4] = 20,
	[126][5] = 21,
	[126][6] = 22,
	[128][20] = 156,
	[128][21] = 157,
	[130][2] = 18,
	[130][3] = 19,
	[130][4] = 20,
	[130][5] = 21,
	[130][6] = 22,
	[133][2] = 129,
	[133][3] = 130,
	[133][4] = 131,
	[134][20] = 156,
	[134][21] = 157,
	[136][2] = 18,
	[136][3] = 19,
	[136][4] = 20,
	[136][5] = 21,
	[136][6] = 22,
	[141][18] = 164,
	[142][18] = 164,
	[144][9] = 117,
	[144][10] = 118,
	[147][11] = 111,
	[147][12] = 112,
	[149][7] = 167,
	[155][18] = 168,
	[156][2] = 129,
	[156][3] = 130,
	[156][4] = 131,
	[157][2] = 135,
	[157][3] = 136,
	[157][4] = 137,
	[159][18] = 171,
	[161][2] = 129,
	[161][3] = 130,
	[161][4] = 131,
	[163][18] = 173,
	[167][2] = 69,
	[167][3] = 70,
	[167][4] = 71,
	[167][5] = 72,
	[167][6] = 73,
};


const unsigned zebu_reduces[175][22] = {
	[2][8] = 1,
	[2][9] = 1,
	[2][10] = 1,
	[2][11] = 1,
	[2][12] = 1,
	[2][13] = 1,
	[2][14] = 1,
	[2][15] = 1,
	[4][8] = 2,
	[4][9] = 2,
	[4][10] = 2,
	[4][11] = 2,
	[4][12] = 2,
	[4][13] = 2,
	[4][14] = 2,
	[4][15] = 2,
	[7][8] = 3,
	[7][13] = 3,
	[7][14] = 3,
	[7][15] = 3,
	[8][16] = 4,
	[8][17] = 4,
	[9][8] = 5,
	[11][16] = 6,
	[11][17] = 6,
	[12][8] = 7,
	[12][11] = 7,
	[12][12] = 7,
	[12][13] = 7,
	[12][14] = 7,
	[12][15] = 7,
	[13][8] = 8,
	[13][9] = 8,
	[13][10] = 8,
	[13][11] = 8,
	[13][12] = 8,
	[13][13] = 8,
	[13][14] = 8,
	[13][15] = 8,
	[14][8] = 9,
	[14][9] = 9,
	[14][10] = 9,
	[14][11] = 9,
	[14][12] = 9,
	[14][13] = 9,
	[14][14] = 9,
	[14][15] = 9,
	[15][8] = 10,
	[16][17] = 11,
	[18][9] = 1,
	[18][10] = 1,
	[18][11] = 1,
	[18][12] = 1,
	[18][13] = 1,
	[18][14] = 1,
	[18][15] = 1,
	[18][18] = 1,
	[20][9] = 2,
	[20][10] = 2,
	[20][11] = 2,
	[20][12] = 2,
	[20][13] = 2,
	[20][14] = 2,
	[20][15] = 2,
	[20][18] = 2,
	[23][13] = 3,
	[23][14] = 3,
	[23][15] = 3,
	[23][18] = 3,
	[24][18] = 5,
	[26][11] = 7,
	[26][12] = 7,
	[26][13] = 7,
	[26][14] = 7,
	[26][15] = 7,
	[26][18] = 7,
	[27][9] = 8,
	[27][10] = 8,
	[27][11] = 8,
	[27][12] = 8,
	[27][13] = 8,
	[27][14] = 8,
	[27][15] = 8,
	[27][18] = 8,
	[28][9] = 9,
	[28][10] = 9,
	[28][11] = 9,
	[28][12] = 9,
	[28][13] = 9,
	[28][14] = 9,
	[28][15] = 9,
	[28][18] = 9,
	[29][18] = 10,
	[34][16] = 12,
	[34][17] = 12,
	[38][2] = 13,
	[38][3] = 13,
	[38][4] = 13,
	[38][5] = 13,
	[38][6] = 13,
	[38][16] = 13,
	[38][17] = 13,
	[39][16] = 14,
	[39][17] = 14,
	[43][8] = 1,
	[43][9] = 1,
	[43][10] = 1,
	[43][11] = 1,
	[43][12] = 1,
	[43][13] = 1,
	[43][14] = 1,
	[43][15] = 1,
	[53][8] = 15,
	[53][9] = 15,
	[53][10] = 15,
	[53][11] = 15,
	[53][12] = 15,
	[53][13] = 15,
	[53][14] = 15,
	[53][15] = 15,
	[57][2] = 1,
	[57][3] = 1,
	[57][4] = 1,
	[57][18] = 1,
	[57][19] = 1,
	[57][20] = 1,
	[57][21] = 1,
	[59][2] = 2,
	[59][3] = 2,
	[59][4] = 2,
	[59][18] = 2,
	[59][19] = 2,
	[59][20] = 2,
	[59][21] = 2,
	[61][18] = 16,
	[61][19] = 16,
	[61][20] = 16,
	[61][21] = 16,
	[62][18] = 17,
	[63][8] = 18,
	[63][11] = 18,
	[63][12] = 18,
	[63][13] = 18,
	[63][14] = 18,
	[63][15] = 18,
	[64][8] = 19,
	[64][11] = 19,
	[64][12] = 19,
	[64][13] = 19,
	[64][14] = 19,
	[64][15] = 19,
	[65][8] = 20,
	[65][11] = 20,
	[65][12] = 20,
	[65][13] = 20,
	[65][14] = 20,
	[65][15] = 20,
	[66][8] = 21,
	[66][13] = 21,
	[66][14] = 21,
	[66][15] = 21,
	[67][8] = 22,
	[67][13] = 22,
	[67][14] = 22,
	[67][15] = 22,
	[68][8] = 23,
	[68][13] = 23,
	[68][14] = 23,
	[68][15] = 23,
	[69][7] = 1,
	[69][9] = 1,
	[69][10] = 1,
	[69][11] = 1,
	[69][12] = 1,
	[69][13] = 1,
	[69][14] = 1,
	[69][15] = 1,
	[71][7] = 2,
	[71][9] = 2,
	[71][10] = 2,
	[71][11] = 2,
	[71][12] = 2,
	[71][13] = 2,
	[71][14] = 2,
	[71][15] = 2,
	[74][7] = 3,
	[74][13] = 3,
	[74][14] = 3,
	[74][15] = 3,
	[75][7] = 5,
	[77][7] = 7,
	[77][11] = 7,
	[77][12] = 7,
	[77][13] = 7,
	[77][14] = 7,
	[77][15] = 7,
	[78][7] = 8,
	[78][9] = 8,
	[78][10] = 8,
	[78][11] = 8,
	[78][12] = 8,
	[78][13] = 8,
	[78][14] = 8,
	[78][15] = 8,
	[79][7] = 9,
	[79][9] = 9,
	[79][10] = 9,
	[79][11] = 9,
	[79][12] = 9,
	[79][13] = 9,
	[79][14] = 9,
	[79][15] = 9,
	[80][7] = 10,
	[81][8] = 24,
	[81][9] = 24,
	[81][10] = 24,
	[81][11] = 24,
	[81][12] = 24,
	[81][13] = 24,
	[81][14] = 24,
	[81][15] = 24,
	[82][8] = 25,
	[82][9] = 25,
	[82][10] = 25,
	[82][11] = 25,
	[82][12] = 25,
	[82][13] = 25,
	[82][14] = 25,
	[82][15] = 25,
	[83][8] = 26,
	[83][9] = 26,
	[83][10] = 26,
	[83][11] = 26,
	[83][12] = 26,
	[83][13] = 26,
	[83][14] = 26,
	[83][15] = 26,
	[84][17] = 27,
	[85][2] = 28,
	[85][3] = 28,
	[85][4] = 28,
	[85][5] = 28,
	[85][6] = 28,
	[85][16] = 28,
	[85][17] = 28,
	[86][9] = 15,
	[86][10] = 15,
	[86][11] = 15,
	[86][12] = 15,
	[86][13] = 15,
	[86][14] = 15,
	[86][15] = 15,
	[86][18] = 15,
	[89][11] = 18,
	[89][12] = 18,
	[89][13] = 18,
	[89][14] = 18,
	[89][15] = 18,
	[89][18] = 18,
	[90][11] = 19,
	[90][12] = 19,
	[90][13] = 19,
	[90][14] = 19,
	[90][15] = 19,
	[90][18] = 19,
	[91][11] = 20,
	[91][12] = 20,
	[91][13] = 20,
	[91][14] = 20,
	[91][15] = 20,
	[91][18] = 20,
	[92][13] = 21,
	[92][14] = 21,
	[92][15] = 21,
	[92][18] = 21,
	[93][13] = 22,
	[93][14] = 22,
	[93][15] = 22,
	[93][18] = 22,
	[94][13] = 23,
	[94][14] = 23,
	[94][15] = 23,
	[94][18] = 23,
	[96][9] = 24,
	[96][10] = 24,
	[96][11] = 24,
	[96][12] = 24,
	[96][13] = 24,
	[96][14] = 24,
	[96][15] = 24,
	[96][18] = 24,
	[97][9] = 25,
	[97][10] = 25,
	[97][11] = 25,
	[97][12] = 25,
	[97][13] = 25,
	[97][14] = 25,
	[97][15] = 25,
	[97][18] = 25,
	[98][9] = 26,
	[98][10] = 26,
	[98][11] = 26,
	[98][12] = 26,
	[98][13] = 26,
	[98][14] = 26,
	[98][15] = 26,
	[98][18] = 26,
	[99][8] = 29,
	[99][9] = 29,
	[99][10] = 29,
	[99][11] = 29,
	[99][12] = 29,
	[99][13] = 29,
	[99][14] = 29,
	[99][15] = 29,
	[100][8] = 30,
	[100][9] = 30,
	[100][10] = 30,
	[100][11] = 30,
	[100][12] = 30,
	[100][13] = 30,
	[100][14] = 30,
	[100][15] = 30,
	[102][8] = 31,
	[102][9] = 31,
	[102][10] = 31,
	[102][11] = 31,
	[102][12] = 31,
	[102][13] = 31,
	[102][14] = 31,
	[102][15] = 31,
	[103][18] = 32,
	[103][19] = 32,
	[103][20] = 32,
	[103][21] = 32,
	[104][18] = 33,
	[104][19] = 33,
	[104][20] = 33,
	[104][21] = 33,
	[119][9] = 29,
	[119][10] = 29,
	[119][11] = 29,
	[119][12] = 29,
	[119][13] = 29,
	[119][14] = 29,
	[119][15] = 29,
	[119][18] = 29,
	[120][9] = 30,
	[120][10] = 30,
	[120][11] = 30,
	[120][12] = 30,
	[120][13] = 30,
	[120][14] = 30,
	[120][15] = 30,
	[120][18] = 30,
	[121][9] = 31,
	[121][10] = 31,
	[121][11] = 31,
	[121][12] = 31,
	[121][13] = 31,
	[121][14] = 31,
	[121][15] = 31,
	[121][18] = 31,
	[123][2] = 15,
	[123][3] = 15,
	[123][4] = 15,
	[123][18] = 15,
	[123][19] = 15,
	[123][20] = 15,
	[123][21] = 15,
	[124][18] = 34,
	[124][19] = 34,
	[124][20] = 34,
	[124][21] = 34,
	[125][18] = 1,
	[125][20] = 1,
	[125][21] = 1,
	[127][18] = 2,
	[127][20] = 2,
	[127][21] = 2,
	[128][18] = 35,
	[129][2] = 1,
	[129][3] = 1,
	[129][4] = 1,
	[129][18] = 1,
	[129][20] = 1,
	[129][21] = 1,
	[131][2] = 2,
	[131][3] = 2,
	[131][4] = 2,
	[131][18] = 2,
	[131][20] = 2,
	[131][21] = 2,
	[132][18] = 36,
	[133][18] = 16,
	[133][20] = 16,
	[133][21] = 16,
	[134][18] = 37,
	[135][18] = 1,
	[137][18] = 2,
	[138][18] = 38,
	[139][18] = 39,
	[140][7] = 15,
	[140][9] = 15,
	[140][10] = 15,
	[140][11] = 15,
	[140][12] = 15,
	[140][13] = 15,
	[140][14] = 15,
	[140][15] = 15,
	[143][7] = 18,
	[143][11] = 18,
	[143][12] = 18,
	[143][13] = 18,
	[143][14] = 18,
	[143][15] = 18,
	[144][7] = 19,
	[144][11] = 19,
	[144][12] = 19,
	[144][13] = 19,
	[144][14] = 19,
	[144][15] = 19,
	[145][7] = 20,
	[145][11] = 20,
	[145][12] = 20,
	[145][13] = 20,
	[145][14] = 20,
	[145][15] = 20,
	[146][7] = 21,
	[146][13] = 21,
	[146][14] = 21,
	[146][15] = 21,
	[147][7] = 22,
	[147][13] = 22,
	[147][14] = 22,
	[147][15] = 22,
	[148][7] = 23,
	[148][13] = 23,
	[148][14] = 23,
	[148][15] = 23,
	[150][8] = 40,
	[151][7] = 24,
	[151][9] = 24,
	[151][10] = 24,
	[151][11] = 24,
	[151][12] = 24,
	[151][13] = 24,
	[151][14] = 24,
	[151][15] = 24,
	[152][7] = 25,
	[152][9] = 25,
	[152][10] = 25,
	[152][11] = 25,
	[152][12] = 25,
	[152][13] = 25,
	[152][14] = 25,
	[152][15] = 25,
	[153][7] = 26,
	[153][9] = 26,
	[153][10] = 26,
	[153][11] = 26,
	[153][12] = 26,
	[153][13] = 26,
	[153][14] = 26,
	[153][15] = 26,
	[154][18] = 40,
	[158][18] = 41,
	[160][18] = 32,
	[160][20] = 32,
	[160][21] = 32,
	[161][18] = 33,
	[161][20] = 33,
	[161][21] = 33,
	[162][18] = 42,
	[164][7] = 29,
	[164][9] = 29,
	[164][10] = 29,
	[164][11] = 29,
	[164][12] = 29,
	[164][13] = 29,
	[164][14] = 29,
	[164][15] = 29,
	[165][7] = 30,
	[165][9] = 30,
	[165][10] = 30,
	[165][11] = 30,
	[165][12] = 30,
	[165][13] = 30,
	[165][14] = 30,
	[165][15] = 30,
	[166][7] = 31,
	[166][9] = 31,
	[166][10] = 31,
	[166][11] = 31,
	[166][12] = 31,
	[166][13] = 31,
	[166][14] = 31,
	[166][15] = 31,
	[168][18] = 15,
	[168][20] = 15,
	[168][21] = 15,
	[169][18] = 43,
	[170][18] = 44,
	[171][2] = 15,
	[171][3] = 15,
	[171][4] = 15,
	[171][18] = 15,
	[171][20] = 15,
	[171][21] = 15,
	[172][18] = 34,
	[172][20] = 34,
	[172][21] = 34,
	[173][18] = 15,
	[174][7] = 40,
};


const unsigned zebu_gotos[168][22] = {
	[1][1] = 7,
	[1][2] = 8,
	[1][3] = 9,
	[1][4] = 10,
	[1][5] = 11,
	[1][6] = 12,
	[1][7] = 13,
	[1][8] = 14,
	[1][9] = 15,
	[1][10] = 16,
	[3][1] = 23,
	[3][3] = 24,
	[3][4] = 25,
	[3][6] = 26,
	[3][7] = 27,
	[3][8] = 28,
	[3][9] = 29,
	[8][1] = 7,
	[8][2] = 8,
	[8][3] = 9,
	[8][4] = 10,
	[8][5] = 11,
	[8][6] = 12,
	[8][7] = 13,
	[8][8] = 14,
	[8][9] = 15,
	[8][10] = 34,
	[11][1] = 7,
	[11][2] = 8,
	[11][3] = 9,
	[11][4] = 10,
	[11][5] = 11,
	[11][6] = 12,
	[11][7] = 13,
	[11][8] = 14,
	[11][9] = 15,
	[11][10] = 39,
	[17][1] = 7,
	[17][3] = 9,
	[17][4] = 44,
	[17][6] = 12,
	[17][7] = 13,
	[17][8] = 14,
	[17][9] = 15,
	[19][1] = 23,
	[19][3] = 24,
	[19][4] = 45,
	[19][6] = 26,
	[19][7] = 27,
	[19][8] = 28,
	[19][9] = 29,
	[30][1] = 23,
	[30][3] = 24,
	[30][4] = 56,
	[30][6] = 26,
	[30][7] = 27,
	[30][8] = 28,
	[30][9] = 29,
	[31][8] = 61,
	[31][11] = 60,
	[31][12] = 62,
	[32][6] = 64,
	[32][7] = 13,
	[32][8] = 14,
	[32][13] = 63,
	[33][6] = 64,
	[33][7] = 13,
	[33][8] = 14,
	[33][13] = 65,
	[35][1] = 67,
	[35][6] = 12,
	[35][7] = 13,
	[35][8] = 14,
	[35][14] = 66,
	[36][1] = 67,
	[36][6] = 12,
	[36][7] = 13,
	[36][8] = 14,
	[36][14] = 68,
	[37][1] = 74,
	[37][3] = 75,
	[37][4] = 76,
	[37][6] = 77,
	[37][7] = 78,
	[37][8] = 79,
	[37][9] = 80,
	[40][7] = 82,
	[40][8] = 14,
	[40][15] = 81,
	[41][7] = 82,
	[41][8] = 14,
	[41][15] = 83,
	[42][1] = 7,
	[42][2] = 8,
	[42][3] = 9,
	[42][4] = 10,
	[42][5] = 11,
	[42][6] = 12,
	[42][7] = 13,
	[42][8] = 14,
	[42][9] = 15,
	[42][10] = 16,
	[42][16] = 84,
	[46][1] = 23,
	[46][3] = 24,
	[46][4] = 87,
	[46][6] = 26,
	[46][7] = 27,
	[46][8] = 28,
	[46][9] = 29,
	[47][8] = 61,
	[47][11] = 88,
	[47][12] = 62,
	[48][6] = 90,
	[48][7] = 27,
	[48][8] = 28,
	[48][13] = 89,
	[49][6] = 90,
	[49][7] = 27,
	[49][8] = 28,
	[49][13] = 91,
	[50][1] = 93,
	[50][6] = 26,
	[50][7] = 27,
	[50][8] = 28,
	[50][14] = 92,
	[51][1] = 93,
	[51][6] = 26,
	[51][7] = 27,
	[51][8] = 28,
	[51][14] = 94,
	[52][1] = 74,
	[52][3] = 75,
	[52][4] = 95,
	[52][6] = 77,
	[52][7] = 78,
	[52][8] = 79,
	[52][9] = 80,
	[54][7] = 97,
	[54][8] = 28,
	[54][15] = 96,
	[55][7] = 97,
	[55][8] = 28,
	[55][15] = 98,
	[56][17] = 100,
	[58][1] = 23,
	[58][3] = 24,
	[58][4] = 101,
	[58][6] = 26,
	[58][7] = 27,
	[58][8] = 28,
	[58][9] = 29,
	[60][17] = 102,
	[61][8] = 104,
	[61][18] = 103,
	[70][1] = 23,
	[70][3] = 24,
	[70][4] = 108,
	[70][6] = 26,
	[70][7] = 27,
	[70][8] = 28,
	[70][9] = 29,
	[87][17] = 120,
	[88][17] = 121,
	[104][8] = 104,
	[104][18] = 124,
	[105][8] = 128,
	[106][8] = 133,
	[106][12] = 134,
	[106][19] = 132,
	[107][8] = 139,
	[107][20] = 138,
	[109][1] = 23,
	[109][3] = 24,
	[109][4] = 141,
	[109][6] = 26,
	[109][7] = 27,
	[109][8] = 28,
	[109][9] = 29,
	[110][8] = 61,
	[110][11] = 142,
	[110][12] = 62,
	[111][6] = 144,
	[111][7] = 78,
	[111][8] = 79,
	[111][13] = 143,
	[112][6] = 144,
	[112][7] = 78,
	[112][8] = 79,
	[112][13] = 145,
	[113][1] = 147,
	[113][6] = 77,
	[113][7] = 78,
	[113][8] = 79,
	[113][14] = 146,
	[114][1] = 147,
	[114][6] = 77,
	[114][7] = 78,
	[114][8] = 79,
	[114][14] = 148,
	[115][1] = 74,
	[115][3] = 75,
	[115][4] = 149,
	[115][6] = 77,
	[115][7] = 78,
	[115][8] = 79,
	[115][9] = 80,
	[116][1] = 7,
	[116][3] = 9,
	[116][6] = 12,
	[116][7] = 13,
	[116][8] = 14,
	[116][9] = 150,
	[117][7] = 152,
	[117][8] = 79,
	[117][15] = 151,
	[118][7] = 152,
	[118][8] = 79,
	[118][15] = 153,
	[122][1] = 23,
	[122][3] = 24,
	[122][6] = 26,
	[122][7] = 27,
	[122][8] = 28,
	[122][9] = 154,
	[126][1] = 23,
	[126][3] = 24,
	[126][4] = 155,
	[126][6] = 26,
	[126][7] = 27,
	[126][8] = 28,
	[126][9] = 29,
	[128][21] = 158,
	[130][1] = 23,
	[130][3] = 24,
	[130][4] = 159,
	[130][6] = 26,
	[130][7] = 27,
	[130][8] = 28,
	[130][9] = 29,
	[133][8] = 161,
	[133][18] = 160,
	[134][21] = 162,
	[136][1] = 23,
	[136][3] = 24,
	[136][4] = 163,
	[136][6] = 26,
	[136][7] = 27,
	[136][8] = 28,
	[136][9] = 29,
	[141][17] = 165,
	[142][17] = 166,
	[156][8] = 133,
	[156][12] = 134,
	[156][19] = 169,
	[157][8] = 139,
	[157][20] = 170,
	[161][8] = 161,
	[161][18] = 172,
	[167][1] = 74,
	[167][3] = 75,
	[167][6] = 77,
	[167][7] = 78,
	[167][8] = 79,
	[167][9] = 174,
};


const unsigned zebu_lexer[59][256] = {
	[1][9] = 24,
	[1][10] = 24,
	[1][32] = 24,
	[1][34] = 25,
	[1][40] = 26,
	[1][47] = 27,
	[1][48] = 28,
	[1][49] = 28,
	[1][50] = 28,
	[1][51] = 28,
	[1][52] = 28,
	[1][53] = 28,
	[1][54] = 28,
	[1][55] = 28,
	[1][56] = 28,
	[1][57] = 28,
	[1][102] = 29,
	[1][115] = 30,
	[2][9] = 24,
	[2][10] = 24,
	[2][32] = 24,
	[2][33] = 31,
	[2][42] = 32,
	[2][43] = 33,
	[2][45] = 34,
	[2][47] = 35,
	[2][58] = 36,
	[2][59] = 37,
	[2][61] = 38,
	[2][63] = 39,
	[3][9] = 24,
	[3][10] = 24,
	[3][32] = 24,
	[3][33] = 31,
	[3][42] = 32,
	[3][43] = 33,
	[3][45] = 34,
	[3][47] = 35,
	[3][59] = 37,
	[3][61] = 38,
	[3][63] = 39,
	[4][9] = 24,
	[4][10] = 24,
	[4][32] = 24,
	[4][40] = 26,
	[4][47] = 27,
	[5][9] = 24,
	[5][10] = 24,
	[5][32] = 24,
	[5][33] = 31,
	[5][43] = 33,
	[5][45] = 34,
	[5][47] = 27,
	[5][59] = 37,
	[5][61] = 38,
	[5][63] = 39,
	[6][9] = 24,
	[6][10] = 24,
	[6][32] = 24,
	[6][34] = 25,
	[6][40] = 26,
	[6][45] = 40,
	[6][47] = 27,
	[6][48] = 28,
	[6][49] = 28,
	[6][50] = 28,
	[6][51] = 28,
	[6][52] = 28,
	[6][53] = 28,
	[6][54] = 28,
	[6][55] = 28,
	[6][56] = 28,
	[6][57] = 28,
	[6][102] = 29,
	[6][115] = 30,
	[7][9] = 24,
	[7][10] = 24,
	[7][32] = 24,
	[7][33] = 31,
	[7][47] = 27,
	[7][59] = 37,
	[7][61] = 38,
	[7][63] = 39,
	[8][9] = 24,
	[8][10] = 24,
	[8][32] = 24,
	[8][47] = 27,
	[8][59] = 37,
	[9][9] = 24,
	[9][10] = 24,
	[9][32] = 24,
	[9][45] = 40,
	[9][47] = 27,
	[10][9] = 24,
	[10][10] = 24,
	[10][32] = 24,
	[10][33] = 31,
	[10][41] = 42,
	[10][42] = 32,
	[10][43] = 33,
	[10][45] = 34,
	[10][47] = 35,
	[10][61] = 38,
	[10][63] = 39,
	[11][9] = 24,
	[11][10] = 24,
	[11][32] = 24,
	[11][33] = 31,
	[11][41] = 42,
	[11][43] = 33,
	[11][45] = 34,
	[11][47] = 27,
	[11][61] = 38,
	[11][63] = 39,
	[12][9] = 24,
	[12][10] = 24,
	[12][32] = 24,
	[12][33] = 31,
	[12][41] = 42,
	[12][47] = 27,
	[12][61] = 38,
	[12][63] = 39,
	[13][9] = 24,
	[13][10] = 24,
	[13][32] = 24,
	[13][41] = 42,
	[13][47] = 27,
	[14][9] = 24,
	[14][10] = 24,
	[14][32] = 24,
	[14][34] = 25,
	[14][40] = 26,
	[14][47] = 27,
	[14][48] = 28,
	[14][49] = 28,
	[14][50] = 28,
	[14][51] = 28,
	[14][52] = 28,
	[14][53] = 28,
	[14][54] = 28,
	[14][55] = 28,
	[14][56] = 28,
	[14][57] = 28,
	[15][9] = 24,
	[15][10] = 24,
	[15][32] = 24,
	[15][34] = 25,
	[15][40] = 26,
	[15][41] = 42,
	[15][47] = 27,
	[15][48] = 28,
	[15][49] = 28,
	[15][50] = 28,
	[15][51] = 28,
	[15][52] = 28,
	[15][53] = 28,
	[15][54] = 28,
	[15][55] = 28,
	[15][56] = 28,
	[15][57] = 28,
	[15][60] = 43,
	[15][62] = 44,
	[15][124] = 45,
	[16][9] = 24,
	[16][10] = 24,
	[16][32] = 24,
	[16][41] = 42,
	[16][47] = 27,
	[16][60] = 43,
	[16][62] = 44,
	[16][124] = 45,
	[17][9] = 24,
	[17][10] = 24,
	[17][32] = 24,
	[17][33] = 31,
	[17][42] = 32,
	[17][43] = 33,
	[17][45] = 34,
	[17][47] = 35,
	[17][58] = 36,
	[17][61] = 38,
	[17][63] = 39,
	[18][9] = 24,
	[18][10] = 24,
	[18][32] = 24,
	[18][33] = 31,
	[18][43] = 33,
	[18][45] = 34,
	[18][47] = 27,
	[18][58] = 36,
	[18][61] = 38,
	[18][63] = 39,
	[19][9] = 24,
	[19][10] = 24,
	[19][32] = 24,
	[19][33] = 31,
	[19][47] = 27,
	[19][58] = 36,
	[19][61] = 38,
	[19][63] = 39,
	[20][9] = 24,
	[20][10] = 24,
	[20][32] = 24,
	[20][47] = 27,
	[20][58] = 36,
	[21][9] = 24,
	[21][10] = 24,
	[21][32] = 24,
	[21][47] = 27,
	[22][9] = 24,
	[22][10] = 24,
	[22][32] = 24,
	[22][41] = 42,
	[22][47] = 27,
	[22][62] = 44,
	[22][124] = 45,
	[23][9] = 24,
	[23][10] = 24,
	[23][32] = 24,
	[23][34] = 25,
	[23][40] = 26,
	[23][41] = 42,
	[23][47] = 27,
	[23][48] = 28,
	[23][49] = 28,
	[23][50] = 28,
	[23][51] = 28,
	[23][52] = 28,
	[23][53] = 28,
	[23][54] = 28,
	[23][55] = 28,
	[23][56] = 28,
	[23][57] = 28,
	[23][62] = 44,
	[23][124] = 45,
	[24][9] = 24,
	[24][10] = 24,
	[24][32] = 24,
	[24][47] = 27,
	[25][0] = 25,
	[25][1] = 25,
	[25][2] = 25,
	[25][3] = 25,
	[25][4] = 25,
	[25][5] = 25,
	[25][6] = 25,
	[25][7] = 25,
	[25][8] = 25,
	[25][9] = 25,
	[25][10] = 25,
	[25][11] = 25,
	[25][12] = 25,
	[25][13] = 25,
	[25][14] = 25,
	[25][15] = 25,
	[25][16] = 25,
	[25][17] = 25,
	[25][18] = 25,
	[25][19] = 25,
	[25][20] = 25,
	[25][21] = 25,
	[25][22] = 25,
	[25][23] = 25,
	[25][24] = 25,
	[25][25] = 25,
	[25][26] = 25,
	[25][27] = 25,
	[25][28] = 25,
	[25][29] = 25,
	[25][30] = 25,
	[25][31] = 25,
	[25][32] = 25,
	[25][33] = 25,
	[25][34] = 46,
	[25][35] = 25,
	[25][36] = 25,
	[25][37] = 25,
	[25][38] = 25,
	[25][39] = 25,
	[25][40] = 25,
	[25][41] = 25,
	[25][42] = 25,
	[25][43] = 25,
	[25][44] = 25,
	[25][45] = 25,
	[25][46] = 25,
	[25][47] = 25,
	[25][48] = 25,
	[25][49] = 25,
	[25][50] = 25,
	[25][51] = 25,
	[25][52] = 25,
	[25][53] = 25,
	[25][54] = 25,
	[25][55] = 25,
	[25][56] = 25,
	[25][57] = 25,
	[25][58] = 25,
	[25][59] = 25,
	[25][60] = 25,
	[25][61] = 25,
	[25][62] = 25,
	[25][63] = 25,
	[25][64] = 25,
	[25][65] = 25,
	[25][66] = 25,
	[25][67] = 25,
	[25][68] = 25,
	[25][69] = 25,
	[25][70] = 25,
	[25][71] = 25,
	[25][72] = 25,
	[25][73] = 25,
	[25][74] = 25,
	[25][75] = 25,
	[25][76] = 25,
	[25][77] = 25,
	[25][78] = 25,
	[25][79] = 25,
	[25][80] = 25,
	[25][81] = 25,
	[25][82] = 25,
	[25][83] = 25,
	[25][84] = 25,
	[25][85] = 25,
	[25][86] = 25,
	[25][87] = 25,
	[25][88] = 25,
	[25][89] = 25,
	[25][90] = 25,
	[25][91] = 25,
	[25][92] = 47,
	[25][93] = 25,
	[25][94] = 25,
	[25][95] = 25,
	[25][96] = 25,
	[25][97] = 25,
	[25][98] = 25,
	[25][99] = 25,
	[25][100] = 25,
	[25][101] = 25,
	[25][102] = 25,
	[25][103] = 25,
	[25][104] = 25,
	[25][105] = 25,
	[25][106] = 25,
	[25][107] = 25,
	[25][108] = 25,
	[25][109] = 25,
	[25][110] = 25,
	[25][111] = 25,
	[25][112] = 25,
	[25][113] = 25,
	[25][114] = 25,
	[25][115] = 25,
	[25][116] = 25,
	[25][117] = 25,
	[25][118] = 25,
	[25][119] = 25,
	[25][120] = 25,
	[25][121] = 25,
	[25][122] = 25,
	[25][123] = 25,
	[25][124] = 25,
	[25][125] = 25,
	[25][126] = 25,
	[25][127] = 25,
	[25][128] = 25,
	[25][129] = 25,
	[25][130] = 25,
	[25][131] = 25,
	[25][132] = 25,
	[25][133] = 25,
	[25][134] = 25,
	[25][135] = 25,
	[25][136] = 25,
	[25][137] = 25,
	[25][138] = 25,
	[25][139] = 25,
	[25][140] = 25,
	[25][141] = 25,
	[25][142] = 25,
	[25][143] = 25,
	[25][144] = 25,
	[25][145] = 25,
	[25][146] = 25,
	[25][147] = 25,
	[25][148] = 25,
	[25][149] = 25,
	[25][150] = 25,
	[25][151] = 25,
	[25][152] = 25,
	[25][153] = 25,
	[25][154] = 25,
	[25][155] = 25,
	[25][156] = 25,
	[25][157] = 25,
	[25][158] = 25,
	[25][159] = 25,
	[25][160] = 25,
	[25][161] = 25,
	[25][162] = 25,
	[25][163] = 25,
	[25][164] = 25,
	[25][165] = 25,
	[25][166] = 25,
	[25][167] = 25,
	[25][168] = 25,
	[25][169] = 25,
	[25][170] = 25,
	[25][171] = 25,
	[25][172] = 25,
	[25][173] = 25,
	[25][174] = 25,
	[25][175] = 25,
	[25][176] = 25,
	[25][177] = 25,
	[25][178] = 25,
	[25][179] = 25,
	[25][180] = 25,
	[25][181] = 25,
	[25][182] = 25,
	[25][183] = 25,
	[25][184] = 25,
	[25][185] = 25,
	[25][186] = 25,
	[25][187] = 25,
	[25][188] = 25,
	[25][189] = 25,
	[25][190] = 25,
	[25][191] = 25,
	[25][192] = 25,
	[25][193] = 25,
	[25][194] = 25,
	[25][195] = 25,
	[25][196] = 25,
	[25][197] = 25,
	[25][198] = 25,
	[25][199] = 25,
	[25][200] = 25,
	[25][201] = 25,
	[25][202] = 25,
	[25][203] = 25,
	[25][204] = 25,
	[25][205] = 25,
	[25][206] = 25,
	[25][207] = 25,
	[25][208] = 25,
	[25][209] = 25,
	[25][210] = 25,
	[25][211] = 25,
	[25][212] = 25,
	[25][213] = 25,
	[25][214] = 25,
	[25][215] = 25,
	[25][216] = 25,
	[25][217] = 25,
	[25][218] = 25,
	[25][219] = 25,
	[25][220] = 25,
	[25][221] = 25,
	[25][222] = 25,
	[25][223] = 25,
	[25][224] = 25,
	[25][225] = 25,
	[25][226] = 25,
	[25][227] = 25,
	[25][228] = 25,
	[25][229] = 25,
	[25][230] = 25,
	[25][231] = 25,
	[25][232] = 25,
	[25][233] = 25,
	[25][234] = 25,
	[25][235] = 25,
	[25][236] = 25,
	[25][237] = 25,
	[25][238] = 25,
	[25][239] = 25,
	[25][240] = 25,
	[25][241] = 25,
	[25][242] = 25,
	[25][243] = 25,
	[25][244] = 25,
	[25][245] = 25,
	[25][246] = 25,
	[25][247] = 25,
	[25][248] = 25,
	[25][249] = 25,
	[25][250] = 25,
	[25][251] = 25,
	[25][252] = 25,
	[25][253] = 25,
	[25][254] = 25,
	[25][255] = 25,
	[27][47] = 48,
	[28][48] = 28,
	[28][49] = 28,
	[28][50] = 28,
	[28][51] = 28,
	[28][52] = 28,
	[28][53] = 28,
	[28][54] = 28,
	[28][55] = 28,
	[28][56] = 28,
	[28][57] = 28,
	[29][105] = 49,
	[30][104] = 50,
	[31][61] = 51,
	[35][47] = 48,
	[38][61] = 52,
	[40][45] = 53,
	[47][34] = 25,
	[47][92] = 25,
	[47][110] = 25,
	[47][116] = 25,
	[48][0] = 48,
	[48][1] = 48,
	[48][2] = 48,
	[48][3] = 48,
	[48][4] = 48,
	[48][5] = 48,
	[48][6] = 48,
	[48][7] = 48,
	[48][8] = 48,
	[48][9] = 48,
	[48][10] = 24,
	[48][11] = 48,
	[48][12] = 48,
	[48][13] = 48,
	[48][14] = 48,
	[48][15] = 48,
	[48][16] = 48,
	[48][17] = 48,
	[48][18] = 48,
	[48][19] = 48,
	[48][20] = 48,
	[48][21] = 48,
	[48][22] = 48,
	[48][23] = 48,
	[48][24] = 48,
	[48][25] = 48,
	[48][26] = 48,
	[48][27] = 48,
	[48][28] = 48,
	[48][29] = 48,
	[48][30] = 48,
	[48][31] = 48,
	[48][32] = 48,
	[48][33] = 48,
	[48][34] = 48,
	[48][35] = 48,
	[48][36] = 48,
	[48][37] = 48,
	[48][38] = 48,
	[48][39] = 48,
	[48][40] = 48,
	[48][41] = 48,
	[48][42] = 48,
	[48][43] = 48,
	[48][44] = 48,
	[48][45] = 48,
	[48][46] = 48,
	[48][47] = 48,
	[48][48] = 48,
	[48][49] = 48,
	[48][50] = 48,
	[48][51] = 48,
	[48][52] = 48,
	[48][53] = 48,
	[48][54] = 48,
	[48][55] = 48,
	[48][56] = 48,
	[48][57] = 48,
	[48][58] = 48,
	[48][59] = 48,
	[48][60] = 48,
	[48][61] = 48,
	[48][62] = 48,
	[48][63] = 48,
	[48][64] = 48,
	[48][65] = 48,
	[48][66] = 48,
	[48][67] = 48,
	[48][68] = 48,
	[48][69] = 48,
	[48][70] = 48,
	[48][71] = 48,
	[48][72] = 48,
	[48][73] = 48,
	[48][74] = 48,
	[48][75] = 48,
	[48][76] = 48,
	[48][77] = 48,
	[48][78] = 48,
	[48][79] = 48,
	[48][80] = 48,
	[48][81] = 48,
	[48][82] = 48,
	[48][83] = 48,
	[48][84] = 48,
	[48][85] = 48,
	[48][86] = 48,
	[48][87] = 48,
	[48][88] = 48,
	[48][89] = 48,
	[48][90] = 48,
	[48][91] = 48,
	[48][92] = 48,
	[48][93] = 48,
	[48][94] = 48,
	[48][95] = 48,
	[48][96] = 48,
	[48][97] = 48,
	[48][98] = 48,
	[48][99] = 48,
	[48][100] = 48,
	[48][101] = 48,
	[48][102] = 48,
	[48][103] = 48,
	[48][104] = 48,
	[48][105] = 48,
	[48][106] = 48,
	[48][107] = 48,
	[48][108] = 48,
	[48][109] = 48,
	[48][110] = 48,
	[48][111] = 48,
	[48][112] = 48,
	[48][113] = 48,
	[48][114] = 48,
	[48][115] = 48,
	[48][116] = 48,
	[48][117] = 48,
	[48][118] = 48,
	[48][119] = 48,
	[48][120] = 48,
	[48][121] = 48,
	[48][122] = 48,
	[48][123] = 48,
	[48][124] = 48,
	[48][125] = 48,
	[48][126] = 48,
	[48][127] = 48,
	[48][128] = 48,
	[48][129] = 48,
	[48][130] = 48,
	[48][131] = 48,
	[48][132] = 48,
	[48][133] = 48,
	[48][134] = 48,
	[48][135] = 48,
	[48][136] = 48,
	[48][137] = 48,
	[48][138] = 48,
	[48][139] = 48,
	[48][140] = 48,
	[48][141] = 48,
	[48][142] = 48,
	[48][143] = 48,
	[48][144] = 48,
	[48][145] = 48,
	[48][146] = 48,
	[48][147] = 48,
	[48][148] = 48,
	[48][149] = 48,
	[48][150] = 48,
	[48][151] = 48,
	[48][152] = 48,
	[48][153] = 48,
	[48][154] = 48,
	[48][155] = 48,
	[48][156] = 48,
	[48][157] = 48,
	[48][158] = 48,
	[48][159] = 48,
	[48][160] = 48,
	[48][161] = 48,
	[48][162] = 48,
	[48][163] = 48,
	[48][164] = 48,
	[48][165] = 48,
	[48][166] = 48,
	[48][167] = 48,
	[48][168] = 48,
	[48][169] = 48,
	[48][170] = 48,
	[48][171] = 48,
	[48][172] = 48,
	[48][173] = 48,
	[48][174] = 48,
	[48][175] = 48,
	[48][176] = 48,
	[48][177] = 48,
	[48][178] = 48,
	[48][179] = 48,
	[48][180] = 48,
	[48][181] = 48,
	[48][182] = 48,
	[48][183] = 48,
	[48][184] = 48,
	[48][185] = 48,
	[48][186] = 48,
	[48][187] = 48,
	[48][188] = 48,
	[48][189] = 48,
	[48][190] = 48,
	[48][191] = 48,
	[48][192] = 48,
	[48][193] = 48,
	[48][194] = 48,
	[48][195] = 48,
	[48][196] = 48,
	[48][197] = 48,
	[48][198] = 48,
	[48][199] = 48,
	[48][200] = 48,
	[48][201] = 48,
	[48][202] = 48,
	[48][203] = 48,
	[48][204] = 48,
	[48][205] = 48,
	[48][206] = 48,
	[48][207] = 48,
	[48][208] = 48,
	[48][209] = 48,
	[48][210] = 48,
	[48][211] = 48,
	[48][212] = 48,
	[48][213] = 48,
	[48][214] = 48,
	[48][215] = 48,
	[48][216] = 48,
	[48][217] = 48,
	[48][218] = 48,
	[48][219] = 48,
	[48][220] = 48,
	[48][221] = 48,
	[48][222] = 48,
	[48][223] = 48,
	[48][224] = 48,
	[48][225] = 48,
	[48][226] = 48,
	[48][227] = 48,
	[48][228] = 48,
	[48][229] = 48,
	[48][230] = 48,
	[48][231] = 48,
	[48][232] = 48,
	[48][233] = 48,
	[48][234] = 48,
	[48][235] = 48,
	[48][236] = 48,
	[48][237] = 48,
	[48][238] = 48,
	[48][239] = 48,
	[48][240] = 48,
	[48][241] = 48,
	[48][242] = 48,
	[48][243] = 48,
	[48][244] = 48,
	[48][245] = 48,
	[48][246] = 48,
	[48][247] = 48,
	[48][248] = 48,
	[48][249] = 48,
	[48][250] = 48,
	[48][251] = 48,
	[48][252] = 48,
	[48][253] = 48,
	[48][254] = 48,
	[48][255] = 48,
	[49][108] = 54,
	[50][101] = 55,
	[53][45] = 56,
	[54][101] = 57,
	[55][108] = 58,
	[58][108] = 59,
};


const unsigned zebu_lexer_starts[175] = {
	[1] = 1,
	[2] = 2,
	[3] = 1,
	[4] = 3,
	[5] = 4,
	[6] = 4,
	[7] = 5,
	[8] = 6,
	[9] = 7,
	[10] = 8,
	[11] = 6,
	[12] = 3,
	[13] = 3,
	[14] = 3,
	[15] = 8,
	[16] = 9,
	[17] = 1,
	[18] = 10,
	[19] = 1,
	[20] = 10,
	[21] = 4,
	[22] = 4,
	[23] = 11,
	[24] = 12,
	[25] = 13,
	[26] = 10,
	[27] = 10,
	[28] = 10,
	[29] = 13,
	[30] = 1,
	[31] = 14,
	[32] = 1,
	[33] = 1,
	[34] = 9,
	[35] = 1,
	[36] = 1,
	[37] = 1,
	[38] = 6,
	[39] = 9,
	[40] = 1,
	[41] = 1,
	[42] = 1,
	[43] = 3,
	[44] = 8,
	[45] = 13,
	[46] = 1,
	[47] = 14,
	[48] = 1,
	[49] = 1,
	[50] = 1,
	[51] = 1,
	[52] = 1,
	[53] = 3,
	[54] = 1,
	[55] = 1,
	[56] = 13,
	[57] = 15,
	[58] = 1,
	[59] = 15,
	[60] = 13,
	[61] = 15,
	[62] = 16,
	[63] = 5,
	[64] = 3,
	[65] = 5,
	[66] = 7,
	[67] = 5,
	[68] = 7,
	[69] = 17,
	[70] = 1,
	[71] = 17,
	[72] = 4,
	[73] = 4,
	[74] = 18,
	[75] = 19,
	[76] = 20,
	[77] = 17,
	[78] = 17,
	[79] = 17,
	[80] = 20,
	[81] = 3,
	[82] = 3,
	[83] = 3,
	[84] = 21,
	[85] = 6,
	[86] = 10,
	[87] = 13,
	[88] = 13,
	[89] = 11,
	[90] = 10,
	[91] = 11,
	[92] = 12,
	[93] = 11,
	[94] = 12,
	[95] = 20,
	[96] = 10,
	[97] = 10,
	[98] = 10,
	[99] = 3,
	[100] = 3,
	[101] = 13,
	[102] = 3,
	[103] = 16,
	[104] = 15,
	[105] = 14,
	[106] = 14,
	[107] = 14,
	[108] = 13,
	[109] = 1,
	[110] = 14,
	[111] = 1,
	[112] = 1,
	[113] = 1,
	[114] = 1,
	[115] = 1,
	[116] = 1,
	[117] = 1,
	[118] = 1,
	[119] = 10,
	[120] = 10,
	[121] = 10,
	[122] = 1,
	[123] = 15,
	[124] = 16,
	[125] = 22,
	[126] = 1,
	[127] = 22,
	[128] = 22,
	[129] = 23,
	[130] = 1,
	[131] = 23,
	[132] = 13,
	[133] = 23,
	[134] = 22,
	[135] = 13,
	[136] = 1,
	[137] = 13,
	[138] = 13,
	[139] = 13,
	[140] = 17,
	[141] = 13,
	[142] = 13,
	[143] = 18,
	[144] = 17,
	[145] = 18,
	[146] = 19,
	[147] = 18,
	[148] = 19,
	[149] = 20,
	[150] = 8,
	[151] = 17,
	[152] = 17,
	[153] = 17,
	[154] = 13,
	[155] = 13,
	[156] = 14,
	[157] = 14,
	[158] = 13,
	[159] = 13,
	[160] = 22,
	[161] = 23,
	[162] = 13,
	[163] = 13,
	[164] = 17,
	[165] = 17,
	[166] = 17,
	[167] = 1,
	[168] = 22,
	[169] = 13,
	[170] = 13,
	[171] = 23,
	[172] = 22,
	[173] = 13,
	[174] = 20,
};


const unsigned zebu_lexer_accepts[60] = {
	[24] = 1,
	[26] = 3,
	[28] = 4,
	[32] = 9,
	[33] = 11,
	[34] = 12,
	[35] = 10,
	[36] = 7,
	[37] = 8,
	[39] = 15,
	[41] = 17,
	[42] = 18,
	[43] = 19,
	[44] = 21,
	[45] = 20,
	[46] = 2,
	[51] = 14,
	[52] = 13,
	[56] = 16,
	[57] = 5,
	[59] = 6,
};


const unsigned zebu_lexer_EOFs[22] = {
	[6] = 41,
	[9] = 41,
	[21] = 41,
};


#ifdef ZEBU_DEBUG
#include <stdbool.h>

struct link
{
	bool is_last;
	struct link* prev;
};

static void print_links(struct link* link)
{
	if (!link) return;
	
	print_links(link->prev);
	
	if (link->is_last)
		fputs("    ", stdout);
	else
		fputs("│   ", stdout);
}

static void print_tree_escape(char *out, char in)
{
	switch (in)
	{
		case ' ':
		case '~':
		case '!':
		case '@':
		case '#':
		case '$':
		case '%':
		case '^':
		case '&':
		case '*':
		case '-':
		case '+':
		case '=':
		case '|':
		case '<': case '>':
		case '(': case ')':
		case '{': case '}':
		case '[': case ']':
		case ':': case ';':
		case ',': case '.':
		case '_':
		case '/':
		case '`':
		case '0' ... '9':
		case 'a' ... 'z':
		case 'A' ... 'Z':
			*out++ = in;
			*out = 0;
			break;
		
		case '\\': *out++ = '\\', *out++ = '\\', *out = 0; break;
		
		case '\'': *out++ = '\\', *out++ = '\'', *out = 0; break;
		
		case '\"': *out++ = '\\', *out++ = '\"', *out = 0; break;
		
		case '\t': *out++ = '\\', *out++ = 't', *out = 0; break;
		
		case '\n': *out++ = '\\', *out++ = 'n', *out = 0; break;
		
		default:
			sprintf(out, "\\x%02X", in);
			break;
	}
}

enum prefix
{
	p_root,
	p_not_last_child,
	p_last_child,
};

void print_token_leaf(struct link* links, enum prefix p, const char* name, struct zebu_token* token)
{
	print_links(links);
	switch (p)
	{
		case p_root: break;
		case p_not_last_child: fputs("├── ", stdout); break;
		case p_last_child: fputs("└── ", stdout); break;
	}
	printf("\e[32m%s\e[0m (\e[35m\"", name);
	char escape[10];
	for (unsigned i = 0, n = token->len; i < n; i++)
		print_tree_escape(escape, token->data[i]), fputs(escape, stdout);
	printf("\"\e[0m) on line %u\n", token->line);
}

void print_scanf_leaf(struct link* links, enum prefix p, const char* name, const char* format, ...)
{
	va_list ap;
	print_links(links);
	switch (p)
	{
		case p_root: break;
		case p_not_last_child: fputs("├── ", stdout); break;
		case p_last_child: fputs("└── ", stdout); break;
	}
	printf("\e[32m%s\e[0m (\e[35m%s\e[m: \e[35m", name, format);
	va_start(ap, format);
	vprintf(format, ap);
	va_end(ap);
	printf("\e[0m)\n");
}

void print_empty_leaf(struct link* links, enum prefix p, const char* type, const char* name)
{
	print_links(links);
	switch (p)
	{
		case p_root: break;
		case p_not_last_child: fputs("├── ", stdout); break;
		case p_last_child: fputs("└── ", stdout); break;
	}
	printf("\e[31m%s\e[0m (\e[36m%s\e[0m)\n", name, type);
}
void print_zebu_$start(struct link* links, enum prefix p, const char* name, struct zebu_$start* ptree);

void print_zebu_additive_expression(struct link* links, enum prefix p, const char* name, struct zebu_additive_expression* ptree);

void print_zebu_assertion(struct link* links, enum prefix p, const char* name, struct zebu_assertion* ptree);

void print_zebu_complex_command(struct link* links, enum prefix p, const char* name, struct zebu_complex_command* ptree);

void print_zebu_equality_expression(struct link* links, enum prefix p, const char* name, struct zebu_equality_expression* ptree);

void print_zebu_expression(struct link* links, enum prefix p, const char* name, struct zebu_expression* ptree);

void print_zebu_file(struct link* links, enum prefix p, const char* name, struct zebu_file* ptree);

void print_zebu_multiplicative_expression(struct link* links, enum prefix p, const char* name, struct zebu_multiplicative_expression* ptree);

void print_zebu_prefix_expression(struct link* links, enum prefix p, const char* name, struct zebu_prefix_expression* ptree);

void print_zebu_primary_expression(struct link* links, enum prefix p, const char* name, struct zebu_primary_expression* ptree);

void print_zebu_simple_command(struct link* links, enum prefix p, const char* name, struct zebu_simple_command* ptree);

void print_zebu_ternary_expression(struct link* links, enum prefix p, const char* name, struct zebu_ternary_expression* ptree);

void print_zebu_test(struct link* links, enum prefix p, const char* name, struct zebu_test* ptree);

void print_zebu_$start(struct link* links, enum prefix p, const char* name, struct zebu_$start* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36m$start\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->tests.n)
	{
		for (unsigned i = 0, n = ptree->tests.n; i < n; i++)
		{
			char label[5 + 30];
			snprintf(label, sizeof(label), "tests[%u]", i);
			print_zebu_test(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->tests.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "test[]", "tests");
	}
	free(new);
}
void print_zebu_additive_expression(struct link* links, enum prefix p, const char* name, struct zebu_additive_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36madditive_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_multiplicative_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "multiplicative_expression", "inner");
	if (ptree->left)
		print_zebu_additive_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "additive_expression", "left");
	if (ptree->right)
		print_zebu_multiplicative_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "multiplicative_expression", "right");
	free(new);
}
void print_zebu_assertion(struct link* links, enum prefix p, const char* name, struct zebu_assertion* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36massertion\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->conditional)
		print_zebu_expression(new ?: links, p_last_child, "conditional", ptree->conditional);
	else
		print_empty_leaf(new ?: links, p_last_child, "expression", "conditional");
	free(new);
}
void print_zebu_complex_command(struct link* links, enum prefix p, const char* name, struct zebu_complex_command* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mcomplex_command\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->redirect_in)
		print_zebu_primary_expression(new ?: links, p_not_last_child, "redirect_in", ptree->redirect_in);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "primary_expression", "redirect_in");
	if (ptree->redirect_out)
		print_zebu_primary_expression(new ?: links, p_not_last_child, "redirect_out", ptree->redirect_out);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "primary_expression", "redirect_out");
	if (ptree->subcommands.n)
	{
		for (unsigned i = 0, n = ptree->subcommands.n; i < n; i++)
		{
			char label[11 + 30];
			snprintf(label, sizeof(label), "subcommands[%u]", i);
			print_zebu_simple_command(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->subcommands.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "simple_command[]", "subcommands");
	}
	free(new);
}
void print_zebu_equality_expression(struct link* links, enum prefix p, const char* name, struct zebu_equality_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mequality_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_additive_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "additive_expression", "inner");
	if (ptree->left)
		print_zebu_equality_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "equality_expression", "left");
	if (ptree->right)
		print_zebu_additive_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "additive_expression", "right");
	free(new);
}
void print_zebu_expression(struct link* links, enum prefix p, const char* name, struct zebu_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mexpression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_ternary_expression(new ?: links, p_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_last_child, "ternary_expression", "inner");
	free(new);
}
void print_zebu_file(struct link* links, enum prefix p, const char* name, struct zebu_file* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mfile\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->path)
		print_token_leaf(new ?: links, p_last_child, "path", ptree->path);
	else
		print_empty_leaf(new ?: links, p_last_child, "token", "path");
	free(new);
}
void print_zebu_multiplicative_expression(struct link* links, enum prefix p, const char* name, struct zebu_multiplicative_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mmultiplicative_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_prefix_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "prefix_expression", "inner");
	if (ptree->left)
		print_zebu_multiplicative_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "multiplicative_expression", "left");
	if (ptree->right)
		print_zebu_prefix_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "prefix_expression", "right");
	free(new);
}
void print_zebu_prefix_expression(struct link* links, enum prefix p, const char* name, struct zebu_prefix_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mprefix_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->file)
		print_zebu_expression(new ?: links, p_not_last_child, "file", ptree->file);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "expression", "file");
	if (ptree->inner)
		print_zebu_primary_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "primary_expression", "inner");
	if (ptree->shell)
		print_zebu_complex_command(new ?: links, p_last_child, "shell", ptree->shell);
	else
		print_empty_leaf(new ?: links, p_last_child, "complex_command", "shell");
	free(new);
}
void print_zebu_primary_expression(struct link* links, enum prefix p, const char* name, struct zebu_primary_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mprimary_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->integer)
		print_token_leaf(new ?: links, p_not_last_child, "integer", ptree->integer);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "integer");
	if (ptree->string)
		print_token_leaf(new ?: links, p_not_last_child, "string", ptree->string);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "string");
	if (ptree->sub)
		print_zebu_expression(new ?: links, p_last_child, "sub", ptree->sub);
	else
		print_empty_leaf(new ?: links, p_last_child, "expression", "sub");
	free(new);
}
void print_zebu_simple_command(struct link* links, enum prefix p, const char* name, struct zebu_simple_command* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36msimple_command\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->args.n)
	{
		for (unsigned i = 0, n = ptree->args.n; i < n; i++)
		{
			char label[4 + 30];
			snprintf(label, sizeof(label), "args[%u]", i);
			print_zebu_primary_expression(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->args.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "primary_expression[]", "args");
	}
	free(new);
}
void print_zebu_ternary_expression(struct link* links, enum prefix p, const char* name, struct zebu_ternary_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mternary_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->falsecase)
		print_zebu_ternary_expression(new ?: links, p_not_last_child, "falsecase", ptree->falsecase);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "ternary_expression", "falsecase");
	if (ptree->inner)
		print_zebu_equality_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "equality_expression", "inner");
	if (ptree->truecase)
		print_zebu_expression(new ?: links, p_last_child, "truecase", ptree->truecase);
	else
		print_empty_leaf(new ?: links, p_last_child, "expression", "truecase");
	free(new);
}
void print_zebu_test(struct link* links, enum prefix p, const char* name, struct zebu_test* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mtest\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->assertions.n)
	{
		for (unsigned i = 0, n = ptree->assertions.n; i < n; i++)
		{
			char label[10 + 30];
			snprintf(label, sizeof(label), "assertions[%u]", i);
			print_zebu_assertion(new ?: links, i + 1 < n ? p_not_last_child : p_not_last_child, label, ptree->assertions.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_not_last_child, "assertion[]", "assertions");
	}
	if (ptree->files.n)
	{
		for (unsigned i = 0, n = ptree->files.n; i < n; i++)
		{
			char label[5 + 30];
			snprintf(label, sizeof(label), "files[%u]", i);
			print_zebu_file(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->files.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "file[]", "files");
	}
	free(new);
}

#endif

struct zebu_token* inc_zebu_token(struct zebu_token* token)
{
	if (token) token->refcount++;
	return token;
}
struct zebu_$start* inc_zebu_$start(struct zebu_$start* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_additive_expression* inc_zebu_additive_expression(struct zebu_additive_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_assertion* inc_zebu_assertion(struct zebu_assertion* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_complex_command* inc_zebu_complex_command(struct zebu_complex_command* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_equality_expression* inc_zebu_equality_expression(struct zebu_equality_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_expression* inc_zebu_expression(struct zebu_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_file* inc_zebu_file(struct zebu_file* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_multiplicative_expression* inc_zebu_multiplicative_expression(struct zebu_multiplicative_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_prefix_expression* inc_zebu_prefix_expression(struct zebu_prefix_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_primary_expression* inc_zebu_primary_expression(struct zebu_primary_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_simple_command* inc_zebu_simple_command(struct zebu_simple_command* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_ternary_expression* inc_zebu_ternary_expression(struct zebu_ternary_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_test* inc_zebu_test(struct zebu_test* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}



extern void free_zebu_token(struct zebu_token* token);
extern void free_zebu_$start(struct zebu_$start* ptree);

extern void free_zebu_additive_expression(struct zebu_additive_expression* ptree);

extern void free_zebu_assertion(struct zebu_assertion* ptree);

extern void free_zebu_complex_command(struct zebu_complex_command* ptree);

extern void free_zebu_equality_expression(struct zebu_equality_expression* ptree);

extern void free_zebu_expression(struct zebu_expression* ptree);

extern void free_zebu_file(struct zebu_file* ptree);

extern void free_zebu_multiplicative_expression(struct zebu_multiplicative_expression* ptree);

extern void free_zebu_prefix_expression(struct zebu_prefix_expression* ptree);

extern void free_zebu_primary_expression(struct zebu_primary_expression* ptree);

extern void free_zebu_simple_command(struct zebu_simple_command* ptree);

extern void free_zebu_ternary_expression(struct zebu_ternary_expression* ptree);

extern void free_zebu_test(struct zebu_test* ptree);

void free_zebu_token(struct zebu_token* token)
{
	if (token && !--token->refcount)
	{
		free(token->data);
		free(token);
	}
}
void free_zebu_$start(struct zebu_$start* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		for (unsigned i = 0, n = ptree->tests.n; i < n; i++)
			free_zebu_test(ptree->tests.data[i]);
		free(ptree->tests.data);
		free(ptree);
	}
}

void free_zebu_additive_expression(struct zebu_additive_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_multiplicative_expression(ptree->inner);
		free_zebu_additive_expression(ptree->left);
		free_zebu_multiplicative_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_assertion(struct zebu_assertion* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_expression(ptree->conditional);
		free(ptree);
	}
}

void free_zebu_complex_command(struct zebu_complex_command* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_primary_expression(ptree->redirect_in);
		free_zebu_primary_expression(ptree->redirect_out);
		for (unsigned i = 0, n = ptree->subcommands.n; i < n; i++)
			free_zebu_simple_command(ptree->subcommands.data[i]);
		free(ptree->subcommands.data);
		free(ptree);
	}
}

void free_zebu_equality_expression(struct zebu_equality_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_additive_expression(ptree->inner);
		free_zebu_equality_expression(ptree->left);
		free_zebu_additive_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_expression(struct zebu_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_ternary_expression(ptree->inner);
		free(ptree);
	}
}

void free_zebu_file(struct zebu_file* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->path);
		free(ptree);
	}
}

void free_zebu_multiplicative_expression(struct zebu_multiplicative_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_prefix_expression(ptree->inner);
		free_zebu_multiplicative_expression(ptree->left);
		free_zebu_prefix_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_prefix_expression(struct zebu_prefix_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_expression(ptree->file);
		free_zebu_primary_expression(ptree->inner);
		free_zebu_complex_command(ptree->shell);
		free(ptree);
	}
}

void free_zebu_primary_expression(struct zebu_primary_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->integer);
		free_zebu_token(ptree->string);
		free_zebu_expression(ptree->sub);
		free(ptree);
	}
}

void free_zebu_simple_command(struct zebu_simple_command* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		for (unsigned i = 0, n = ptree->args.n; i < n; i++)
			free_zebu_primary_expression(ptree->args.data[i]);
		free(ptree->args.data);
		free(ptree);
	}
}

void free_zebu_ternary_expression(struct zebu_ternary_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_ternary_expression(ptree->falsecase);
		free_zebu_equality_expression(ptree->inner);
		free_zebu_expression(ptree->truecase);
		free(ptree);
	}
}

void free_zebu_test(struct zebu_test* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		for (unsigned i = 0, n = ptree->assertions.n; i < n; i++)
			free_zebu_assertion(ptree->assertions.data[i]);
		free(ptree->assertions.data);
		for (unsigned i = 0, n = ptree->files.n; i < n; i++)
			free_zebu_file(ptree->files.data[i]);
		free(ptree->files.data);
		free(ptree);
	}
}



#define argv0 (program_invocation_name)

#define N(array) (sizeof(array) / sizeof(*array))

#ifdef ZEBU_DEBUG
static void escape(char *out, unsigned char in)
{
	switch (in)
	{
		case ' ':
		case '~':
		case '!':
		case '@':
		case '#':
		case '$':
		case '%':
		case '^':
		case '&':
		case '*':
		case '-':
		case '+':
		case '=':
		case '|':
		case '/':
		case '<': case '>':
		case '(': case ')':
		case '{': case '}':
		case '[': case ']':
		case ':': case ';':
		case ',': case '.':
		case '_':
		case '0' ... '9':
		case 'a' ... 'z':
		case 'A' ... 'Z':
			*out++ = in;
			*out = 0;
			break;
		
		case '\\': *out++ = '\\', *out++ = '\\', *out = 0; break;
		
		case '\'': *out++ = '\\', *out++ = '\'', *out = 0; break;
		
		case '\"': *out++ = '\\', *out++ = '\"', *out = 0; break;
		
		case '\t': *out++ = '\\', *out++ = 't', *out = 0; break;
		
		case '\n': *out++ = '\\', *out++ = 'n', *out = 0; break;
		
		default:
			sprintf(out, "\\x%02hhX", in);
			break;
	}
}
#endif

struct zebu_$start* zebu_parse(FILE* stream)
{
	void* root;
	struct { unsigned* data, n, cap; } yacc = {};
	struct { void** data; unsigned n, cap; } data = {};
	struct { unsigned char* data; unsigned n, cap, line; } lexer = {
		.line = 1,
	};
	
	void push_state(unsigned y)
	{
		if (yacc.n + 1 >= yacc.cap)
		{
			yacc.cap = yacc.cap << 1 ?: 1;
			yacc.data = realloc(yacc.data, sizeof(*yacc.data) * yacc.cap);
		}
		yacc.data[yacc.n++] = y;
	}
	
	void push_data(void* d)
	{
		if (data.n + 1 >= data.cap)
		{
			data.cap = data.cap << 1 ?: 1;
			data.data = realloc(data.data, sizeof(*data.data) * data.cap);
		}
		data.data[data.n++] = d;
	}
	
	#ifdef ZEBU_DEBUG
	void ddprintf(const char* fmt, ...)
	{
		for (unsigned i = 0, n = yacc.n; i < n; i++)
			printf("%u ", yacc.data[i]);
		
		printf("| ");
		
		va_list va;
		va_start(va, fmt);
		vprintf(fmt, va);
		va_end(va);
	}
	#endif
	
	void push_char(unsigned char c)
	{
		while (lexer.n + 1 >= lexer.cap)
		{
			lexer.cap = lexer.cap << 1 ?: 1;
			#ifdef ZEBU_DEBUG
			ddprintf("lexer.cap == %u\n", lexer.cap);
			#endif
			lexer.data = realloc(lexer.data, lexer.cap);
		}
		
		lexer.data[lexer.n++] = c;
	}
	
	unsigned y, t, s, r;
	void* td;
	
	void read_token(unsigned l)
	{
		unsigned original_l = l, i = 0, a, b, c, f = 0;
		
		unsigned line = lexer.line;
		
		t = 0;
		
		#ifdef ZEBU_DEBUG
		ddprintf("lexer: \"%.*s\": l = %u\n", lexer.n, lexer.data, l);
		#endif
		
		while (1)
		{
			if (i < lexer.n)
			{
				c = lexer.data[i];
				
				#ifdef ZEBU_DEBUG
				char escaped[10];
				
				escape(escaped, c);
				
				ddprintf("lexer: c = '%s' (0x%X) (from cache)\n", escaped, c);
				#endif
				
				a = l < N(zebu_lexer) && c < N(*zebu_lexer) ? zebu_lexer[l][c] : 0;
			}
			else if ((c = getc(stream)) != EOF)
			{
				push_char(c);
				
				#ifdef ZEBU_DEBUG
				char escaped[10];
				
				escape(escaped, c);
				
				ddprintf("lexer: c = '%s' (0x%X)\n", escaped, c);
				#endif
				
				a = l < N(zebu_lexer) && c < N(*zebu_lexer) ? zebu_lexer[l][c] : 0;
			}
			else
			{
				c = EOF;
				
				#ifdef ZEBU_DEBUG
				ddprintf("lexer: c = <EOF>\n");
				#endif
				
				a = l < N(zebu_lexer_EOFs) ? zebu_lexer_EOFs[l] : 0;
			}
			
			b = l < N(zebu_lexer_accepts) ? zebu_lexer_accepts[l] : 0;
			
			#ifdef ZEBU_DEBUG
			ddprintf("lexer: \"%.*s\" (%u): a = %u, b = %u\n", lexer.n, lexer.data, i, a, b);
			#endif
			
			if (a)
			{
				if (b)
				{
					l = a, t = b, f = i++, lexer.line = line;
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: l = %u\n", l);
					#endif
				}
				else
				{
					l = a, i++;
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: l = %u\n", l);
					#endif
				}
				
				if (c == '\n')
				{
					line++;
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: line: %u\n", line);
					#endif
				}
			}
			else if (b)
			{
				#ifdef ZEBU_DEBUG
				ddprintf("lexer: token: \"%.*s\", line: %u\n", i, lexer.data, line);
				#endif
				
				if (!lexer.n)
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: EOF.\n");
					#endif
					t = b, td = NULL;
					break;
				}
				else if (b == 1)
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: whitespace: \"%.*s\"\n", i, lexer.data);
					#endif
					
					l = original_l, t = 0, lexer.line = line;
					memmove(lexer.data, lexer.data + i, lexer.n - i), lexer.n -= i, i = 0;
				}
				else
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: i = %u\n", i);
					#endif
					
					struct zebu_token* token = malloc(sizeof(*token));
					token->refcount = 1;
					token->line = line;
					token->data = memcpy(malloc(i + 1), lexer.data, i);
					token->data[i] = 0;
					token->len = i;
					t = b, td = token;
					
					lexer.line = line;
					memmove(lexer.data, lexer.data + i, lexer.n - i), lexer.n -= i;
					break;
				}
			}
			else if (t)
			{
				if (t == 1)
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: falling back to whitespace: \"%.*s\"\n", f, lexer.data);
					#endif
					
					l = original_l, t = 0, line = lexer.line;
					memmove(lexer.data, lexer.data + f, lexer.n - f), lexer.n -= f, f = 0, i = 0;
				}
				else
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: falling back to token: \"%.*s\"\n", f, lexer.data);
					#endif
					
					struct zebu_token* token = malloc(sizeof(*token));
					token->refcount = 1;
					token->line = lexer.line;
					token->data = memcpy(malloc(f + 1), lexer.data, f);
					token->data[f] = 0;
					token->len = f;
					td = token;
					
					memmove(lexer.data, lexer.data + f, lexer.n - f), lexer.n -= f, f = 0;
					break;
				}
			}
			else
			{
				if (i != 0)
				{
					if (c == (unsigned) EOF)
						fprintf(stderr, "%s: unexpected '<EOF>' when reading '%.*s' on line %u!\n", argv0, i, lexer.data, line);
					else
						fprintf(stderr, "%s: unexpected '%c' when reading '%.*s' on line %u!\n", argv0, c, i, lexer.data, line);
				}
				else
				{
					if (c == (unsigned) EOF)
						fprintf(stderr, "%s: unexpected '<EOF>' on line %u!\n", argv0, line);
					else
						fprintf(stderr, "%s: unexpected '%c' on line %u!\n", argv0, c, line);
				}
				exit(1);
			}
		}
	}
	
	push_state(1), y = 1, read_token(1);
	
	#ifdef ZEBU_DEBUG
	ddprintf("y = %u, t = %u\n", y, t);
	#endif
	
	while (yacc.n)
	{
		if (y < N(zebu_shifts) && t < N(*zebu_shifts) && (s = zebu_shifts[y][t]))
		{
			#ifdef ZEBU_DEBUG
			ddprintf("s == %u\n", s);
			#endif
			
			y = s, push_state(y), push_data(td);
			
			read_token(zebu_lexer_starts[y]);
			
			#ifdef ZEBU_DEBUG
			ddprintf("t = %u\n", t);
			#endif
		}
		else if (y < N( zebu_reduces) && t < N(*zebu_reduces) && (r = zebu_reduces[y][t]))
		{
			#ifdef ZEBU_DEBUG
			ddprintf("r == %u\n", r);
			#endif
			
			unsigned g;
			void* d;
			
			switch (r)
{
	case 11:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_test* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->tests.n == value->tests.cap)
{
value->tests.cap = value->tests.cap << 1 ?: 1;
value->tests.data = realloc(value->tests.data, sizeof(*value->tests.data) * value->tests.cap);
}
memmove(value->tests.data + 1, value->tests.data, sizeof(*value->tests.data) * value->tests.n);
value->tests.data[0] = inc_zebu_test(subgrammar), value->tests.n++;
free_zebu_test(subgrammar);
}
		d = value, g = 16;
		break;
	}
	case 27:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_$start* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->tests.n)
{
while (value->tests.n + trie->tests.n > value->tests.cap)
{
value->tests.cap = value->tests.cap << 1 ?: 1;
value->tests.data = realloc(value->tests.data, sizeof(*value->tests.data) * value->tests.cap);
}
memmove(value->tests.data + trie->tests.n, value->tests.data, sizeof(*value->tests.data) * value->tests.n);
for (unsigned i = 0, n = trie->tests.n; i < n; i++)
value->tests.data[i] = inc_zebu_test(trie->tests.data[i]);
value->tests.n += trie->tests.n;
}
free_zebu_$start(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_test* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->tests.n == value->tests.cap)
{
value->tests.cap = value->tests.cap << 1 ?: 1;
value->tests.data = realloc(value->tests.data, sizeof(*value->tests.data) * value->tests.cap);
}
memmove(value->tests.data + 1, value->tests.data, sizeof(*value->tests.data) * value->tests.n);
value->tests.data[0] = inc_zebu_test(subgrammar), value->tests.n++;
free_zebu_test(subgrammar);
}
		d = value, g = 16;
		break;
	}
	case 19:
	{
		struct zebu_additive_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_multiplicative_expression(value->right), value->right = inc_zebu_multiplicative_expression(subgrammar);
free_zebu_multiplicative_expression(subgrammar);
}
		d = value, g = 13;
		break;
	}
	case 43:
	{
		struct zebu_complex_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_complex_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->redirect_in) { free_zebu_primary_expression(value->redirect_in); value->redirect_in = inc_zebu_primary_expression(trie->redirect_in); }
if (trie->redirect_out) { free_zebu_primary_expression(value->redirect_out); value->redirect_out = inc_zebu_primary_expression(trie->redirect_out); }
if (trie->subcommands.n)
{
while (value->subcommands.n + trie->subcommands.n > value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + trie->subcommands.n, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
for (unsigned i = 0, n = trie->subcommands.n; i < n; i++)
value->subcommands.data[i] = inc_zebu_simple_command(trie->subcommands.data[i]);
value->subcommands.n += trie->subcommands.n;
}
free_zebu_complex_command(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 21;
		break;
	}
	case 44:
	{
		struct zebu_complex_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_complex_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->redirect_in) { free_zebu_primary_expression(value->redirect_in); value->redirect_in = inc_zebu_primary_expression(trie->redirect_in); }
if (trie->redirect_out) { free_zebu_primary_expression(value->redirect_out); value->redirect_out = inc_zebu_primary_expression(trie->redirect_out); }
if (trie->subcommands.n)
{
while (value->subcommands.n + trie->subcommands.n > value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + trie->subcommands.n, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
for (unsigned i = 0, n = trie->subcommands.n; i < n; i++)
value->subcommands.data[i] = inc_zebu_simple_command(trie->subcommands.data[i]);
value->subcommands.n += trie->subcommands.n;
}
free_zebu_complex_command(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 21;
		break;
	}
	case 42:
	{
		struct zebu_complex_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_complex_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->redirect_in) { free_zebu_primary_expression(value->redirect_in); value->redirect_in = inc_zebu_primary_expression(trie->redirect_in); }
if (trie->redirect_out) { free_zebu_primary_expression(value->redirect_out); value->redirect_out = inc_zebu_primary_expression(trie->redirect_out); }
if (trie->subcommands.n)
{
while (value->subcommands.n + trie->subcommands.n > value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + trie->subcommands.n, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
for (unsigned i = 0, n = trie->subcommands.n; i < n; i++)
value->subcommands.data[i] = inc_zebu_simple_command(trie->subcommands.data[i]);
value->subcommands.n += trie->subcommands.n;
}
free_zebu_complex_command(trie);
}
{
struct zebu_simple_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->subcommands.n == value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + 1, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
value->subcommands.data[0] = inc_zebu_simple_command(subgrammar), value->subcommands.n++;
free_zebu_simple_command(subgrammar);
}
		d = value, g = 19;
		break;
	}
	case 37:
	{
		struct zebu_complex_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_simple_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->subcommands.n == value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + 1, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
value->subcommands.data[0] = inc_zebu_simple_command(subgrammar), value->subcommands.n++;
free_zebu_simple_command(subgrammar);
}
		d = value, g = 19;
		break;
	}
	case 39:
	{
		struct zebu_complex_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_primary_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_primary_expression(value->redirect_out), value->redirect_out = inc_zebu_primary_expression(subgrammar);
free_zebu_primary_expression(subgrammar);
}
		d = value, g = 20;
		break;
	}
	case 22:
	{
		struct zebu_equality_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_additive_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_additive_expression(value->right), value->right = inc_zebu_additive_expression(subgrammar);
free_zebu_additive_expression(subgrammar);
}
		d = value, g = 14;
		break;
	}
	case 25:
	{
		struct zebu_multiplicative_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_prefix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_prefix_expression(value->right), value->right = inc_zebu_prefix_expression(subgrammar);
free_zebu_prefix_expression(subgrammar);
}
		d = value, g = 15;
		break;
	}
	case 29:
	{
		struct zebu_prefix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 17;
		break;
	}
	case 33:
	{
		struct zebu_simple_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_primary_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->args.n == value->args.cap)
{
value->args.cap = value->args.cap << 1 ?: 1;
value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
}
memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
value->args.data[0] = inc_zebu_primary_expression(subgrammar), value->args.n++;
free_zebu_primary_expression(subgrammar);
}
		d = value, g = 18;
		break;
	}
	case 34:
	{
		struct zebu_simple_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_simple_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->args.n)
{
while (value->args.n + trie->args.n > value->args.cap)
{
value->args.cap = value->args.cap << 1 ?: 1;
value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
}
memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
for (unsigned i = 0, n = trie->args.n; i < n; i++)
value->args.data[i] = inc_zebu_primary_expression(trie->args.data[i]);
value->args.n += trie->args.n;
}
free_zebu_simple_command(trie);
}
{
struct zebu_primary_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->args.n == value->args.cap)
{
value->args.cap = value->args.cap << 1 ?: 1;
value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
}
memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
value->args.data[0] = inc_zebu_primary_expression(subgrammar), value->args.n++;
free_zebu_primary_expression(subgrammar);
}
		d = value, g = 18;
		break;
	}
	case 18:
	{
		struct zebu_additive_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_additive_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_multiplicative_expression(value->inner); value->inner = inc_zebu_multiplicative_expression(trie->inner); }
if (trie->left) { free_zebu_additive_expression(value->left); value->left = inc_zebu_additive_expression(trie->left); }
if (trie->right) { free_zebu_multiplicative_expression(value->right); value->right = inc_zebu_multiplicative_expression(trie->right); }
free_zebu_additive_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_additive_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_additive_expression(value->left), value->left = inc_zebu_additive_expression(subgrammar);
free_zebu_additive_expression(subgrammar);
}
		d = value, g = 1;
		break;
	}
	case 7:
	{
		struct zebu_additive_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_multiplicative_expression(value->inner), value->inner = inc_zebu_multiplicative_expression(subgrammar);
free_zebu_multiplicative_expression(subgrammar);
}
		d = value, g = 1;
		break;
	}
	case 20:
	{
		struct zebu_additive_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_additive_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_multiplicative_expression(value->inner); value->inner = inc_zebu_multiplicative_expression(trie->inner); }
if (trie->left) { free_zebu_additive_expression(value->left); value->left = inc_zebu_additive_expression(trie->left); }
if (trie->right) { free_zebu_multiplicative_expression(value->right); value->right = inc_zebu_multiplicative_expression(trie->right); }
free_zebu_additive_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_additive_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_additive_expression(value->left), value->left = inc_zebu_additive_expression(subgrammar);
free_zebu_additive_expression(subgrammar);
}
		d = value, g = 1;
		break;
	}
	case 13:
	{
		struct zebu_assertion* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression(value->conditional), value->conditional = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
		d = value, g = 2;
		break;
	}
	case 35:
	{
		struct zebu_complex_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_primary_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_primary_expression(value->redirect_in), value->redirect_in = inc_zebu_primary_expression(subgrammar);
free_zebu_primary_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_simple_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->subcommands.n == value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + 1, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
value->subcommands.data[0] = inc_zebu_simple_command(subgrammar), value->subcommands.n++;
free_zebu_simple_command(subgrammar);
}
		d = value, g = 11;
		break;
	}
	case 41:
	{
		struct zebu_complex_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_complex_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->redirect_in) { free_zebu_primary_expression(value->redirect_in); value->redirect_in = inc_zebu_primary_expression(trie->redirect_in); }
if (trie->redirect_out) { free_zebu_primary_expression(value->redirect_out); value->redirect_out = inc_zebu_primary_expression(trie->redirect_out); }
if (trie->subcommands.n)
{
while (value->subcommands.n + trie->subcommands.n > value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + trie->subcommands.n, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
for (unsigned i = 0, n = trie->subcommands.n; i < n; i++)
value->subcommands.data[i] = inc_zebu_simple_command(trie->subcommands.data[i]);
value->subcommands.n += trie->subcommands.n;
}
free_zebu_complex_command(trie);
}
{
struct zebu_primary_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_primary_expression(value->redirect_in), value->redirect_in = inc_zebu_primary_expression(subgrammar);
free_zebu_primary_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_simple_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->subcommands.n == value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + 1, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
value->subcommands.data[0] = inc_zebu_simple_command(subgrammar), value->subcommands.n++;
free_zebu_simple_command(subgrammar);
}
		d = value, g = 11;
		break;
	}
	case 36:
	{
		struct zebu_complex_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_complex_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->redirect_in) { free_zebu_primary_expression(value->redirect_in); value->redirect_in = inc_zebu_primary_expression(trie->redirect_in); }
if (trie->redirect_out) { free_zebu_primary_expression(value->redirect_out); value->redirect_out = inc_zebu_primary_expression(trie->redirect_out); }
if (trie->subcommands.n)
{
while (value->subcommands.n + trie->subcommands.n > value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + trie->subcommands.n, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
for (unsigned i = 0, n = trie->subcommands.n; i < n; i++)
value->subcommands.data[i] = inc_zebu_simple_command(trie->subcommands.data[i]);
value->subcommands.n += trie->subcommands.n;
}
free_zebu_complex_command(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_simple_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->subcommands.n == value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + 1, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
value->subcommands.data[0] = inc_zebu_simple_command(subgrammar), value->subcommands.n++;
free_zebu_simple_command(subgrammar);
}
		d = value, g = 11;
		break;
	}
	case 38:
	{
		struct zebu_complex_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_complex_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->redirect_in) { free_zebu_primary_expression(value->redirect_in); value->redirect_in = inc_zebu_primary_expression(trie->redirect_in); }
if (trie->redirect_out) { free_zebu_primary_expression(value->redirect_out); value->redirect_out = inc_zebu_primary_expression(trie->redirect_out); }
if (trie->subcommands.n)
{
while (value->subcommands.n + trie->subcommands.n > value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + trie->subcommands.n, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
for (unsigned i = 0, n = trie->subcommands.n; i < n; i++)
value->subcommands.data[i] = inc_zebu_simple_command(trie->subcommands.data[i]);
value->subcommands.n += trie->subcommands.n;
}
free_zebu_complex_command(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_simple_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->subcommands.n == value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + 1, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
value->subcommands.data[0] = inc_zebu_simple_command(subgrammar), value->subcommands.n++;
free_zebu_simple_command(subgrammar);
}
		d = value, g = 11;
		break;
	}
	case 17:
	{
		struct zebu_complex_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_simple_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->subcommands.n == value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + 1, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
value->subcommands.data[0] = inc_zebu_simple_command(subgrammar), value->subcommands.n++;
free_zebu_simple_command(subgrammar);
}
		d = value, g = 11;
		break;
	}
	case 21:
	{
		struct zebu_equality_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_equality_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_additive_expression(value->inner); value->inner = inc_zebu_additive_expression(trie->inner); }
if (trie->left) { free_zebu_equality_expression(value->left); value->left = inc_zebu_equality_expression(trie->left); }
if (trie->right) { free_zebu_additive_expression(value->right); value->right = inc_zebu_additive_expression(trie->right); }
free_zebu_equality_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_equality_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_equality_expression(value->left), value->left = inc_zebu_equality_expression(subgrammar);
free_zebu_equality_expression(subgrammar);
}
		d = value, g = 3;
		break;
	}
	case 23:
	{
		struct zebu_equality_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_equality_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_additive_expression(value->inner); value->inner = inc_zebu_additive_expression(trie->inner); }
if (trie->left) { free_zebu_equality_expression(value->left); value->left = inc_zebu_equality_expression(trie->left); }
if (trie->right) { free_zebu_additive_expression(value->right); value->right = inc_zebu_additive_expression(trie->right); }
free_zebu_equality_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_equality_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_equality_expression(value->left), value->left = inc_zebu_equality_expression(subgrammar);
free_zebu_equality_expression(subgrammar);
}
		d = value, g = 3;
		break;
	}
	case 3:
	{
		struct zebu_equality_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_additive_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_additive_expression(value->inner), value->inner = inc_zebu_additive_expression(subgrammar);
free_zebu_additive_expression(subgrammar);
}
		d = value, g = 3;
		break;
	}
	case 10:
	{
		struct zebu_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_ternary_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_ternary_expression(value->inner), value->inner = inc_zebu_ternary_expression(subgrammar);
free_zebu_ternary_expression(subgrammar);
}
		d = value, g = 4;
		break;
	}
	case 28:
	{
		struct zebu_file* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->path), value->path = inc_zebu_token(token);
free_zebu_token(token);
}
		d = value, g = 5;
		break;
	}
	case 24:
	{
		struct zebu_multiplicative_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_multiplicative_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_prefix_expression(value->inner); value->inner = inc_zebu_prefix_expression(trie->inner); }
if (trie->left) { free_zebu_multiplicative_expression(value->left); value->left = inc_zebu_multiplicative_expression(trie->left); }
if (trie->right) { free_zebu_prefix_expression(value->right); value->right = inc_zebu_prefix_expression(trie->right); }
free_zebu_multiplicative_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_multiplicative_expression(value->left), value->left = inc_zebu_multiplicative_expression(subgrammar);
free_zebu_multiplicative_expression(subgrammar);
}
		d = value, g = 6;
		break;
	}
	case 26:
	{
		struct zebu_multiplicative_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_multiplicative_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_prefix_expression(value->inner); value->inner = inc_zebu_prefix_expression(trie->inner); }
if (trie->left) { free_zebu_multiplicative_expression(value->left); value->left = inc_zebu_multiplicative_expression(trie->left); }
if (trie->right) { free_zebu_prefix_expression(value->right); value->right = inc_zebu_prefix_expression(trie->right); }
free_zebu_multiplicative_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_multiplicative_expression(value->left), value->left = inc_zebu_multiplicative_expression(subgrammar);
free_zebu_multiplicative_expression(subgrammar);
}
		d = value, g = 6;
		break;
	}
	case 8:
	{
		struct zebu_multiplicative_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_prefix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_prefix_expression(value->inner), value->inner = inc_zebu_prefix_expression(subgrammar);
free_zebu_prefix_expression(subgrammar);
}
		d = value, g = 6;
		break;
	}
	case 30:
	{
		struct zebu_prefix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_prefix_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->file) { free_zebu_expression(value->file); value->file = inc_zebu_expression(trie->file); }
if (trie->inner) { free_zebu_primary_expression(value->inner); value->inner = inc_zebu_primary_expression(trie->inner); }
if (trie->shell) { free_zebu_complex_command(value->shell); value->shell = inc_zebu_complex_command(trie->shell); }
free_zebu_prefix_expression(trie);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression(value->file), value->file = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 7;
		break;
	}
	case 31:
	{
		struct zebu_prefix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_prefix_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->file) { free_zebu_expression(value->file); value->file = inc_zebu_expression(trie->file); }
if (trie->inner) { free_zebu_primary_expression(value->inner); value->inner = inc_zebu_primary_expression(trie->inner); }
if (trie->shell) { free_zebu_complex_command(value->shell); value->shell = inc_zebu_complex_command(trie->shell); }
free_zebu_prefix_expression(trie);
}
{
struct zebu_complex_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_complex_command(value->shell), value->shell = inc_zebu_complex_command(subgrammar);
free_zebu_complex_command(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 7;
		break;
	}
	case 9:
	{
		struct zebu_prefix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_primary_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_primary_expression(value->inner), value->inner = inc_zebu_primary_expression(subgrammar);
free_zebu_primary_expression(subgrammar);
}
		d = value, g = 7;
		break;
	}
	case 1:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->string), value->string = inc_zebu_token(token);
free_zebu_token(token);
}
		d = value, g = 8;
		break;
	}
	case 15:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression(value->sub), value->sub = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 8;
		break;
	}
	case 2:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->integer), value->integer = inc_zebu_token(token);
free_zebu_token(token);
}
		d = value, g = 8;
		break;
	}
	case 16:
	{
		struct zebu_simple_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_primary_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->args.n == value->args.cap)
{
value->args.cap = value->args.cap << 1 ?: 1;
value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
}
memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
value->args.data[0] = inc_zebu_primary_expression(subgrammar), value->args.n++;
free_zebu_primary_expression(subgrammar);
}
		d = value, g = 12;
		break;
	}
	case 32:
	{
		struct zebu_simple_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_simple_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->args.n)
{
while (value->args.n + trie->args.n > value->args.cap)
{
value->args.cap = value->args.cap << 1 ?: 1;
value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
}
memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
for (unsigned i = 0, n = trie->args.n; i < n; i++)
value->args.data[i] = inc_zebu_primary_expression(trie->args.data[i]);
value->args.n += trie->args.n;
}
free_zebu_simple_command(trie);
}
{
struct zebu_primary_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->args.n == value->args.cap)
{
value->args.cap = value->args.cap << 1 ?: 1;
value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
}
memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
value->args.data[0] = inc_zebu_primary_expression(subgrammar), value->args.n++;
free_zebu_primary_expression(subgrammar);
}
		d = value, g = 12;
		break;
	}
	case 5:
	{
		struct zebu_ternary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_equality_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_equality_expression(value->inner), value->inner = inc_zebu_equality_expression(subgrammar);
free_zebu_equality_expression(subgrammar);
}
		d = value, g = 9;
		break;
	}
	case 40:
	{
		struct zebu_ternary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_ternary_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_ternary_expression(value->falsecase), value->falsecase = inc_zebu_ternary_expression(subgrammar);
free_zebu_ternary_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression(value->truecase), value->truecase = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_equality_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_equality_expression(value->inner), value->inner = inc_zebu_equality_expression(subgrammar);
free_zebu_equality_expression(subgrammar);
}
		d = value, g = 9;
		break;
	}
	case 4:
	{
		struct zebu_test* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->assertions.n == value->assertions.cap)
{
value->assertions.cap = value->assertions.cap << 1 ?: 1;
value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
}
memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
free_zebu_assertion(subgrammar);
}
		d = value, g = 10;
		break;
	}
	case 12:
	{
		struct zebu_test* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_test* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->assertions.n)
{
while (value->assertions.n + trie->assertions.n > value->assertions.cap)
{
value->assertions.cap = value->assertions.cap << 1 ?: 1;
value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
}
memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
value->assertions.n += trie->assertions.n;
}
if (trie->files.n)
{
while (value->files.n + trie->files.n > value->files.cap)
{
value->files.cap = value->files.cap << 1 ?: 1;
value->files.data = realloc(value->files.data, sizeof(*value->files.data) * value->files.cap);
}
memmove(value->files.data + trie->files.n, value->files.data, sizeof(*value->files.data) * value->files.n);
for (unsigned i = 0, n = trie->files.n; i < n; i++)
value->files.data[i] = inc_zebu_file(trie->files.data[i]);
value->files.n += trie->files.n;
}
free_zebu_test(trie);
}
{
struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->assertions.n == value->assertions.cap)
{
value->assertions.cap = value->assertions.cap << 1 ?: 1;
value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
}
memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
free_zebu_assertion(subgrammar);
}
		d = value, g = 10;
		break;
	}
	case 6:
	{
		struct zebu_test* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_file* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->files.n == value->files.cap)
{
value->files.cap = value->files.cap << 1 ?: 1;
value->files.data = realloc(value->files.data, sizeof(*value->files.data) * value->files.cap);
}
memmove(value->files.data + 1, value->files.data, sizeof(*value->files.data) * value->files.n);
value->files.data[0] = inc_zebu_file(subgrammar), value->files.n++;
free_zebu_file(subgrammar);
}
		d = value, g = 10;
		break;
	}
	case 14:
	{
		struct zebu_test* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_test* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->assertions.n)
{
while (value->assertions.n + trie->assertions.n > value->assertions.cap)
{
value->assertions.cap = value->assertions.cap << 1 ?: 1;
value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
}
memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
value->assertions.n += trie->assertions.n;
}
if (trie->files.n)
{
while (value->files.n + trie->files.n > value->files.cap)
{
value->files.cap = value->files.cap << 1 ?: 1;
value->files.data = realloc(value->files.data, sizeof(*value->files.data) * value->files.cap);
}
memmove(value->files.data + trie->files.n, value->files.data, sizeof(*value->files.data) * value->files.n);
for (unsigned i = 0, n = trie->files.n; i < n; i++)
value->files.data[i] = inc_zebu_file(trie->files.data[i]);
value->files.n += trie->files.n;
}
free_zebu_test(trie);
}
{
struct zebu_file* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->files.n == value->files.cap)
{
value->files.cap = value->files.cap << 1 ?: 1;
value->files.data = realloc(value->files.data, sizeof(*value->files.data) * value->files.cap);
}
memmove(value->files.data + 1, value->files.data, sizeof(*value->files.data) * value->files.n);
value->files.data[0] = inc_zebu_file(subgrammar), value->files.n++;
free_zebu_file(subgrammar);
}
		d = value, g = 10;
		break;
	}
}
			
			if (g == 16)
			{
				free_zebu_token(td);
				yacc.n = 0, root = d;
			}
			else
			{
				y = yacc.data[yacc.n - 1];
				
				#ifdef ZEBU_DEBUG
				ddprintf("y = %u\n", y);
				#endif
				
				assert(y < N(zebu_gotos) && g < N(*zebu_gotos));
				
				s = zebu_gotos[y][g];
				
				#ifdef ZEBU_DEBUG
				ddprintf("s = %u\n", s);
				#endif
				
				y = s, push_state(y), push_data(d);
			}
		}
		else
		{
			struct zebu_token* token = td;
			
			fprintf(stderr, "zebu: unexpected token '%.*s'!\n", token->len, token->data);
			
			exit(1);
		}
	}
	
	#ifdef ZEBU_DEBUG
	print_zebu_$start(NULL, p_root, "start", root);
	#endif
	
	free(yacc.data);
	free(data.data);
	free(lexer.data);
	
	return root;
}

















