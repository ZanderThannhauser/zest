#include "zebu.h"

#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif

#include <limits.h>
#include <stdarg.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <assert.h>
#include <stdio.h>
#include <errno.h>

const unsigned zebu_shifts[295][33] = {
	[1][2] = 2,
	[1][3] = 3,
	[1][4] = 4,
	[1][5] = 5,
	[1][6] = 6,
	[1][7] = 7,
	[1][8] = 8,
	[1][9] = 9,
	[1][10] = 10,
	[2][11] = 29,
	[3][2] = 30,
	[3][3] = 31,
	[3][4] = 32,
	[3][5] = 33,
	[3][6] = 34,
	[3][7] = 35,
	[3][8] = 36,
	[3][9] = 37,
	[3][10] = 38,
	[5][3] = 53,
	[6][3] = 54,
	[7][2] = 55,
	[7][3] = 3,
	[7][4] = 4,
	[7][5] = 5,
	[7][6] = 6,
	[7][7] = 7,
	[7][8] = 8,
	[7][9] = 9,
	[7][10] = 10,
	[8][2] = 55,
	[8][3] = 3,
	[8][4] = 4,
	[8][5] = 5,
	[8][6] = 6,
	[8][7] = 7,
	[8][8] = 8,
	[8][9] = 9,
	[8][10] = 10,
	[9][2] = 55,
	[9][3] = 3,
	[9][4] = 4,
	[9][5] = 5,
	[9][6] = 6,
	[9][7] = 7,
	[9][8] = 8,
	[9][9] = 9,
	[9][10] = 10,
	[10][2] = 55,
	[10][3] = 3,
	[10][4] = 4,
	[10][5] = 5,
	[10][6] = 6,
	[10][7] = 7,
	[10][8] = 8,
	[10][9] = 9,
	[10][10] = 10,
	[11][8] = 61,
	[11][9] = 62,
	[12][25] = 63,
	[13][2] = 2,
	[13][3] = 3,
	[13][4] = 4,
	[13][5] = 5,
	[13][6] = 6,
	[13][7] = 7,
	[13][8] = 8,
	[13][9] = 9,
	[13][10] = 10,
	[15][23] = 65,
	[15][24] = 66,
	[16][26] = 67,
	[17][12] = 68,
	[18][2] = 2,
	[18][3] = 3,
	[18][4] = 4,
	[18][5] = 5,
	[18][6] = 6,
	[18][7] = 7,
	[18][8] = 8,
	[18][9] = 9,
	[18][10] = 10,
	[19][14] = 70,
	[20][27] = 71,
	[21][28] = 72,
	[21][29] = 73,
	[22][16] = 74,
	[22][17] = 75,
	[22][18] = 76,
	[25][13] = 77,
	[25][15] = 78,
	[25][21] = 79,
	[25][22] = 80,
	[27][19] = 81,
	[27][20] = 82,
	[28][30] = 83,
	[29][2] = 55,
	[29][3] = 3,
	[29][4] = 4,
	[29][5] = 5,
	[29][6] = 6,
	[29][7] = 7,
	[29][8] = 8,
	[29][9] = 9,
	[29][10] = 10,
	[31][2] = 30,
	[31][3] = 31,
	[31][4] = 32,
	[31][5] = 33,
	[31][6] = 34,
	[31][7] = 35,
	[31][8] = 36,
	[31][9] = 37,
	[31][10] = 38,
	[33][3] = 86,
	[34][3] = 87,
	[35][2] = 30,
	[35][3] = 31,
	[35][4] = 32,
	[35][5] = 33,
	[35][6] = 34,
	[35][7] = 35,
	[35][8] = 36,
	[35][9] = 37,
	[35][10] = 38,
	[36][2] = 30,
	[36][3] = 31,
	[36][4] = 32,
	[36][5] = 33,
	[36][6] = 34,
	[36][7] = 35,
	[36][8] = 36,
	[36][9] = 37,
	[36][10] = 38,
	[37][2] = 30,
	[37][3] = 31,
	[37][4] = 32,
	[37][5] = 33,
	[37][6] = 34,
	[37][7] = 35,
	[37][8] = 36,
	[37][9] = 37,
	[37][10] = 38,
	[38][2] = 30,
	[38][3] = 31,
	[38][4] = 32,
	[38][5] = 33,
	[38][6] = 34,
	[38][7] = 35,
	[38][8] = 36,
	[38][9] = 37,
	[38][10] = 38,
	[39][8] = 93,
	[39][9] = 94,
	[40][25] = 95,
	[42][23] = 96,
	[42][24] = 97,
	[43][26] = 98,
	[44][32] = 99,
	[45][14] = 100,
	[46][27] = 101,
	[47][28] = 102,
	[47][29] = 103,
	[48][16] = 104,
	[48][17] = 105,
	[48][18] = 106,
	[51][13] = 107,
	[51][15] = 108,
	[51][21] = 109,
	[51][22] = 110,
	[52][19] = 111,
	[52][20] = 112,
	[53][2] = 30,
	[53][3] = 31,
	[53][4] = 32,
	[53][5] = 33,
	[53][6] = 34,
	[53][7] = 35,
	[53][8] = 36,
	[53][9] = 37,
	[53][10] = 38,
	[54][2] = 114,
	[54][3] = 115,
	[54][4] = 116,
	[61][2] = 55,
	[61][3] = 3,
	[61][4] = 4,
	[61][5] = 5,
	[61][6] = 6,
	[61][7] = 7,
	[61][8] = 8,
	[61][9] = 9,
	[61][10] = 10,
	[62][2] = 55,
	[62][3] = 3,
	[62][4] = 4,
	[62][5] = 5,
	[62][6] = 6,
	[62][7] = 7,
	[62][8] = 8,
	[62][9] = 9,
	[62][10] = 10,
	[63][2] = 55,
	[63][3] = 3,
	[63][4] = 4,
	[63][5] = 5,
	[63][6] = 6,
	[63][7] = 7,
	[63][8] = 8,
	[63][9] = 9,
	[63][10] = 10,
	[65][2] = 55,
	[65][3] = 3,
	[65][4] = 4,
	[65][5] = 5,
	[65][6] = 6,
	[65][7] = 7,
	[65][8] = 8,
	[65][9] = 9,
	[65][10] = 10,
	[66][2] = 55,
	[66][3] = 3,
	[66][4] = 4,
	[66][5] = 5,
	[66][6] = 6,
	[66][7] = 7,
	[66][8] = 8,
	[66][9] = 9,
	[66][10] = 10,
	[67][2] = 55,
	[67][3] = 3,
	[67][4] = 4,
	[67][5] = 5,
	[67][6] = 6,
	[67][7] = 7,
	[67][8] = 8,
	[67][9] = 9,
	[67][10] = 10,
	[70][2] = 55,
	[70][3] = 3,
	[70][4] = 4,
	[70][5] = 5,
	[70][6] = 6,
	[70][7] = 7,
	[70][8] = 8,
	[70][9] = 9,
	[70][10] = 10,
	[71][2] = 55,
	[71][3] = 3,
	[71][4] = 4,
	[71][5] = 5,
	[71][6] = 6,
	[71][7] = 7,
	[71][8] = 8,
	[71][9] = 9,
	[71][10] = 10,
	[72][2] = 55,
	[72][3] = 3,
	[72][4] = 4,
	[72][5] = 5,
	[72][6] = 6,
	[72][7] = 7,
	[72][8] = 8,
	[72][9] = 9,
	[72][10] = 10,
	[73][2] = 131,
	[73][3] = 132,
	[73][4] = 133,
	[73][5] = 134,
	[73][6] = 135,
	[73][7] = 136,
	[73][8] = 137,
	[73][9] = 138,
	[73][10] = 139,
	[74][2] = 55,
	[74][3] = 3,
	[74][4] = 4,
	[74][5] = 5,
	[74][6] = 6,
	[74][7] = 7,
	[74][8] = 8,
	[74][9] = 9,
	[74][10] = 10,
	[75][2] = 55,
	[75][3] = 3,
	[75][4] = 4,
	[75][5] = 5,
	[75][6] = 6,
	[75][7] = 7,
	[75][8] = 8,
	[75][9] = 9,
	[75][10] = 10,
	[76][2] = 55,
	[76][3] = 3,
	[76][4] = 4,
	[76][5] = 5,
	[76][6] = 6,
	[76][7] = 7,
	[76][8] = 8,
	[76][9] = 9,
	[76][10] = 10,
	[77][2] = 55,
	[77][3] = 3,
	[77][4] = 4,
	[77][5] = 5,
	[77][6] = 6,
	[77][7] = 7,
	[77][8] = 8,
	[77][9] = 9,
	[77][10] = 10,
	[78][2] = 55,
	[78][3] = 3,
	[78][4] = 4,
	[78][5] = 5,
	[78][6] = 6,
	[78][7] = 7,
	[78][8] = 8,
	[78][9] = 9,
	[78][10] = 10,
	[79][2] = 55,
	[79][3] = 3,
	[79][4] = 4,
	[79][5] = 5,
	[79][6] = 6,
	[79][7] = 7,
	[79][8] = 8,
	[79][9] = 9,
	[79][10] = 10,
	[80][2] = 55,
	[80][3] = 3,
	[80][4] = 4,
	[80][5] = 5,
	[80][6] = 6,
	[80][7] = 7,
	[80][8] = 8,
	[80][9] = 9,
	[80][10] = 10,
	[81][2] = 55,
	[81][3] = 3,
	[81][4] = 4,
	[81][5] = 5,
	[81][6] = 6,
	[81][7] = 7,
	[81][8] = 8,
	[81][9] = 9,
	[81][10] = 10,
	[82][2] = 55,
	[82][3] = 3,
	[82][4] = 4,
	[82][5] = 5,
	[82][6] = 6,
	[82][7] = 7,
	[82][8] = 8,
	[82][9] = 9,
	[82][10] = 10,
	[83][2] = 2,
	[83][3] = 3,
	[83][4] = 4,
	[83][5] = 5,
	[83][6] = 6,
	[83][7] = 7,
	[83][8] = 8,
	[83][9] = 9,
	[83][10] = 10,
	[84][12] = 167,
	[85][32] = 168,
	[86][2] = 30,
	[86][3] = 31,
	[86][4] = 32,
	[86][5] = 33,
	[86][6] = 34,
	[86][7] = 35,
	[86][8] = 36,
	[86][9] = 37,
	[86][10] = 38,
	[87][2] = 114,
	[87][3] = 115,
	[87][4] = 116,
	[93][2] = 30,
	[93][3] = 31,
	[93][4] = 32,
	[93][5] = 33,
	[93][6] = 34,
	[93][7] = 35,
	[93][8] = 36,
	[93][9] = 37,
	[93][10] = 38,
	[94][2] = 30,
	[94][3] = 31,
	[94][4] = 32,
	[94][5] = 33,
	[94][6] = 34,
	[94][7] = 35,
	[94][8] = 36,
	[94][9] = 37,
	[94][10] = 38,
	[95][2] = 30,
	[95][3] = 31,
	[95][4] = 32,
	[95][5] = 33,
	[95][6] = 34,
	[95][7] = 35,
	[95][8] = 36,
	[95][9] = 37,
	[95][10] = 38,
	[96][2] = 30,
	[96][3] = 31,
	[96][4] = 32,
	[96][5] = 33,
	[96][6] = 34,
	[96][7] = 35,
	[96][8] = 36,
	[96][9] = 37,
	[96][10] = 38,
	[97][2] = 30,
	[97][3] = 31,
	[97][4] = 32,
	[97][5] = 33,
	[97][6] = 34,
	[97][7] = 35,
	[97][8] = 36,
	[97][9] = 37,
	[97][10] = 38,
	[98][2] = 30,
	[98][3] = 31,
	[98][4] = 32,
	[98][5] = 33,
	[98][6] = 34,
	[98][7] = 35,
	[98][8] = 36,
	[98][9] = 37,
	[98][10] = 38,
	[100][2] = 30,
	[100][3] = 31,
	[100][4] = 32,
	[100][5] = 33,
	[100][6] = 34,
	[100][7] = 35,
	[100][8] = 36,
	[100][9] = 37,
	[100][10] = 38,
	[101][2] = 30,
	[101][3] = 31,
	[101][4] = 32,
	[101][5] = 33,
	[101][6] = 34,
	[101][7] = 35,
	[101][8] = 36,
	[101][9] = 37,
	[101][10] = 38,
	[102][2] = 30,
	[102][3] = 31,
	[102][4] = 32,
	[102][5] = 33,
	[102][6] = 34,
	[102][7] = 35,
	[102][8] = 36,
	[102][9] = 37,
	[102][10] = 38,
	[103][2] = 131,
	[103][3] = 132,
	[103][4] = 133,
	[103][5] = 134,
	[103][6] = 135,
	[103][7] = 136,
	[103][8] = 137,
	[103][9] = 138,
	[103][10] = 139,
	[104][2] = 30,
	[104][3] = 31,
	[104][4] = 32,
	[104][5] = 33,
	[104][6] = 34,
	[104][7] = 35,
	[104][8] = 36,
	[104][9] = 37,
	[104][10] = 38,
	[105][2] = 30,
	[105][3] = 31,
	[105][4] = 32,
	[105][5] = 33,
	[105][6] = 34,
	[105][7] = 35,
	[105][8] = 36,
	[105][9] = 37,
	[105][10] = 38,
	[106][2] = 30,
	[106][3] = 31,
	[106][4] = 32,
	[106][5] = 33,
	[106][6] = 34,
	[106][7] = 35,
	[106][8] = 36,
	[106][9] = 37,
	[106][10] = 38,
	[107][2] = 30,
	[107][3] = 31,
	[107][4] = 32,
	[107][5] = 33,
	[107][6] = 34,
	[107][7] = 35,
	[107][8] = 36,
	[107][9] = 37,
	[107][10] = 38,
	[108][2] = 30,
	[108][3] = 31,
	[108][4] = 32,
	[108][5] = 33,
	[108][6] = 34,
	[108][7] = 35,
	[108][8] = 36,
	[108][9] = 37,
	[108][10] = 38,
	[109][2] = 30,
	[109][3] = 31,
	[109][4] = 32,
	[109][5] = 33,
	[109][6] = 34,
	[109][7] = 35,
	[109][8] = 36,
	[109][9] = 37,
	[109][10] = 38,
	[110][2] = 30,
	[110][3] = 31,
	[110][4] = 32,
	[110][5] = 33,
	[110][6] = 34,
	[110][7] = 35,
	[110][8] = 36,
	[110][9] = 37,
	[110][10] = 38,
	[111][2] = 30,
	[111][3] = 31,
	[111][4] = 32,
	[111][5] = 33,
	[111][6] = 34,
	[111][7] = 35,
	[111][8] = 36,
	[111][9] = 37,
	[111][10] = 38,
	[112][2] = 30,
	[112][3] = 31,
	[112][4] = 32,
	[112][5] = 33,
	[112][6] = 34,
	[112][7] = 35,
	[112][8] = 36,
	[112][9] = 37,
	[112][10] = 38,
	[113][32] = 195,
	[115][2] = 30,
	[115][3] = 31,
	[115][4] = 32,
	[115][5] = 33,
	[115][6] = 34,
	[115][7] = 35,
	[115][8] = 36,
	[115][9] = 37,
	[115][10] = 38,
	[117][32] = 195,
	[118][2] = 114,
	[118][3] = 115,
	[118][4] = 116,
	[119][13] = 201,
	[119][14] = 202,
	[119][15] = 203,
	[121][16] = 74,
	[121][17] = 75,
	[121][18] = 76,
	[123][23] = 65,
	[123][24] = 66,
	[125][13] = 77,
	[125][15] = 78,
	[125][21] = 79,
	[125][22] = 80,
	[127][25] = 63,
	[128][26] = 67,
	[129][14] = 70,
	[130][27] = 71,
	[132][2] = 30,
	[132][3] = 31,
	[132][4] = 32,
	[132][5] = 33,
	[132][6] = 34,
	[132][7] = 35,
	[132][8] = 36,
	[132][9] = 37,
	[132][10] = 38,
	[134][3] = 205,
	[135][3] = 206,
	[136][2] = 131,
	[136][3] = 132,
	[136][4] = 133,
	[136][5] = 134,
	[136][6] = 135,
	[136][7] = 136,
	[136][8] = 137,
	[136][9] = 138,
	[136][10] = 139,
	[137][2] = 131,
	[137][3] = 132,
	[137][4] = 133,
	[137][5] = 134,
	[137][6] = 135,
	[137][7] = 136,
	[137][8] = 137,
	[137][9] = 138,
	[137][10] = 139,
	[138][2] = 131,
	[138][3] = 132,
	[138][4] = 133,
	[138][5] = 134,
	[138][6] = 135,
	[138][7] = 136,
	[138][8] = 137,
	[138][9] = 138,
	[138][10] = 139,
	[139][2] = 131,
	[139][3] = 132,
	[139][4] = 133,
	[139][5] = 134,
	[139][6] = 135,
	[139][7] = 136,
	[139][8] = 137,
	[139][9] = 138,
	[139][10] = 139,
	[140][8] = 212,
	[140][9] = 213,
	[141][25] = 214,
	[143][23] = 215,
	[143][24] = 216,
	[144][26] = 217,
	[145][11] = 218,
	[146][14] = 219,
	[147][27] = 220,
	[148][28] = 221,
	[148][29] = 222,
	[149][16] = 223,
	[149][17] = 224,
	[149][18] = 225,
	[152][13] = 226,
	[152][15] = 227,
	[152][21] = 228,
	[152][22] = 229,
	[153][19] = 230,
	[153][20] = 231,
	[159][19] = 81,
	[159][20] = 82,
	[164][8] = 61,
	[164][9] = 62,
	[169][32] = 232,
	[170][32] = 232,
	[172][16] = 104,
	[172][17] = 105,
	[172][18] = 106,
	[174][23] = 96,
	[174][24] = 97,
	[176][13] = 107,
	[176][15] = 108,
	[176][21] = 109,
	[176][22] = 110,
	[178][25] = 95,
	[179][26] = 98,
	[180][14] = 100,
	[181][27] = 101,
	[182][11] = 235,
	[188][19] = 111,
	[188][20] = 112,
	[193][8] = 93,
	[193][9] = 94,
	[197][32] = 236,
	[200][2] = 114,
	[200][3] = 115,
	[200][4] = 116,
	[201][2] = 238,
	[201][3] = 239,
	[201][4] = 240,
	[202][2] = 242,
	[202][3] = 243,
	[202][4] = 244,
	[203][2] = 248,
	[203][3] = 249,
	[203][4] = 250,
	[204][32] = 253,
	[205][2] = 30,
	[205][3] = 31,
	[205][4] = 32,
	[205][5] = 33,
	[205][6] = 34,
	[205][7] = 35,
	[205][8] = 36,
	[205][9] = 37,
	[205][10] = 38,
	[206][2] = 114,
	[206][3] = 115,
	[206][4] = 116,
	[212][2] = 131,
	[212][3] = 132,
	[212][4] = 133,
	[212][5] = 134,
	[212][6] = 135,
	[212][7] = 136,
	[212][8] = 137,
	[212][9] = 138,
	[212][10] = 139,
	[213][2] = 131,
	[213][3] = 132,
	[213][4] = 133,
	[213][5] = 134,
	[213][6] = 135,
	[213][7] = 136,
	[213][8] = 137,
	[213][9] = 138,
	[213][10] = 139,
	[214][2] = 131,
	[214][3] = 132,
	[214][4] = 133,
	[214][5] = 134,
	[214][6] = 135,
	[214][7] = 136,
	[214][8] = 137,
	[214][9] = 138,
	[214][10] = 139,
	[215][2] = 131,
	[215][3] = 132,
	[215][4] = 133,
	[215][5] = 134,
	[215][6] = 135,
	[215][7] = 136,
	[215][8] = 137,
	[215][9] = 138,
	[215][10] = 139,
	[216][2] = 131,
	[216][3] = 132,
	[216][4] = 133,
	[216][5] = 134,
	[216][6] = 135,
	[216][7] = 136,
	[216][8] = 137,
	[216][9] = 138,
	[216][10] = 139,
	[217][2] = 131,
	[217][3] = 132,
	[217][4] = 133,
	[217][5] = 134,
	[217][6] = 135,
	[217][7] = 136,
	[217][8] = 137,
	[217][9] = 138,
	[217][10] = 139,
	[218][2] = 55,
	[218][3] = 3,
	[218][4] = 4,
	[218][5] = 5,
	[218][6] = 6,
	[218][7] = 7,
	[218][8] = 8,
	[218][9] = 9,
	[218][10] = 10,
	[219][2] = 131,
	[219][3] = 132,
	[219][4] = 133,
	[219][5] = 134,
	[219][6] = 135,
	[219][7] = 136,
	[219][8] = 137,
	[219][9] = 138,
	[219][10] = 139,
	[220][2] = 131,
	[220][3] = 132,
	[220][4] = 133,
	[220][5] = 134,
	[220][6] = 135,
	[220][7] = 136,
	[220][8] = 137,
	[220][9] = 138,
	[220][10] = 139,
	[221][2] = 131,
	[221][3] = 132,
	[221][4] = 133,
	[221][5] = 134,
	[221][6] = 135,
	[221][7] = 136,
	[221][8] = 137,
	[221][9] = 138,
	[221][10] = 139,
	[222][2] = 131,
	[222][3] = 132,
	[222][4] = 133,
	[222][5] = 134,
	[222][6] = 135,
	[222][7] = 136,
	[222][8] = 137,
	[222][9] = 138,
	[222][10] = 139,
	[223][2] = 131,
	[223][3] = 132,
	[223][4] = 133,
	[223][5] = 134,
	[223][6] = 135,
	[223][7] = 136,
	[223][8] = 137,
	[223][9] = 138,
	[223][10] = 139,
	[224][2] = 131,
	[224][3] = 132,
	[224][4] = 133,
	[224][5] = 134,
	[224][6] = 135,
	[224][7] = 136,
	[224][8] = 137,
	[224][9] = 138,
	[224][10] = 139,
	[225][2] = 131,
	[225][3] = 132,
	[225][4] = 133,
	[225][5] = 134,
	[225][6] = 135,
	[225][7] = 136,
	[225][8] = 137,
	[225][9] = 138,
	[225][10] = 139,
	[226][2] = 131,
	[226][3] = 132,
	[226][4] = 133,
	[226][5] = 134,
	[226][6] = 135,
	[226][7] = 136,
	[226][8] = 137,
	[226][9] = 138,
	[226][10] = 139,
	[227][2] = 131,
	[227][3] = 132,
	[227][4] = 133,
	[227][5] = 134,
	[227][6] = 135,
	[227][7] = 136,
	[227][8] = 137,
	[227][9] = 138,
	[227][10] = 139,
	[228][2] = 131,
	[228][3] = 132,
	[228][4] = 133,
	[228][5] = 134,
	[228][6] = 135,
	[228][7] = 136,
	[228][8] = 137,
	[228][9] = 138,
	[228][10] = 139,
	[229][2] = 131,
	[229][3] = 132,
	[229][4] = 133,
	[229][5] = 134,
	[229][6] = 135,
	[229][7] = 136,
	[229][8] = 137,
	[229][9] = 138,
	[229][10] = 139,
	[230][2] = 131,
	[230][3] = 132,
	[230][4] = 133,
	[230][5] = 134,
	[230][6] = 135,
	[230][7] = 136,
	[230][8] = 137,
	[230][9] = 138,
	[230][10] = 139,
	[231][2] = 131,
	[231][3] = 132,
	[231][4] = 133,
	[231][5] = 134,
	[231][6] = 135,
	[231][7] = 136,
	[231][8] = 137,
	[231][9] = 138,
	[231][10] = 139,
	[235][2] = 30,
	[235][3] = 31,
	[235][4] = 32,
	[235][5] = 33,
	[235][6] = 34,
	[235][7] = 35,
	[235][8] = 36,
	[235][9] = 37,
	[235][10] = 38,
	[239][2] = 30,
	[239][3] = 31,
	[239][4] = 32,
	[239][5] = 33,
	[239][6] = 34,
	[239][7] = 35,
	[239][8] = 36,
	[239][9] = 37,
	[239][10] = 38,
	[241][14] = 283,
	[241][15] = 284,
	[243][2] = 30,
	[243][3] = 31,
	[243][4] = 32,
	[243][5] = 33,
	[243][6] = 34,
	[243][7] = 35,
	[243][8] = 36,
	[243][9] = 37,
	[243][10] = 38,
	[246][2] = 242,
	[246][3] = 243,
	[246][4] = 244,
	[247][14] = 283,
	[247][15] = 284,
	[249][2] = 30,
	[249][3] = 31,
	[249][4] = 32,
	[249][5] = 33,
	[249][6] = 34,
	[249][7] = 35,
	[249][8] = 36,
	[249][9] = 37,
	[249][10] = 38,
	[254][32] = 291,
	[255][32] = 291,
	[257][16] = 223,
	[257][17] = 224,
	[257][18] = 225,
	[259][23] = 215,
	[259][24] = 216,
	[261][13] = 226,
	[261][15] = 227,
	[261][21] = 228,
	[261][22] = 229,
	[263][25] = 214,
	[265][26] = 217,
	[266][14] = 219,
	[267][27] = 220,
	[268][11] = 294,
	[274][19] = 230,
	[274][20] = 231,
	[279][8] = 212,
	[279][9] = 213,
	[282][32] = 295,
	[283][2] = 242,
	[283][3] = 243,
	[283][4] = 244,
	[284][2] = 248,
	[284][3] = 249,
	[284][4] = 250,
	[286][32] = 298,
	[288][2] = 242,
	[288][3] = 243,
	[288][4] = 244,
	[290][32] = 300,
	[294][2] = 131,
	[294][3] = 132,
	[294][4] = 133,
	[294][5] = 134,
	[294][6] = 135,
	[294][7] = 136,
	[294][8] = 137,
	[294][9] = 138,
	[294][10] = 139,
};


const unsigned zebu_reduces[302][33] = {
	[2][8] = 1,
	[2][9] = 1,
	[2][12] = 1,
	[2][13] = 1,
	[2][14] = 1,
	[2][15] = 1,
	[2][16] = 1,
	[2][17] = 1,
	[2][18] = 1,
	[2][19] = 1,
	[2][20] = 1,
	[2][21] = 1,
	[2][22] = 1,
	[2][23] = 1,
	[2][24] = 1,
	[2][25] = 1,
	[2][26] = 1,
	[2][27] = 1,
	[2][28] = 1,
	[2][29] = 1,
	[4][8] = 2,
	[4][9] = 2,
	[4][12] = 2,
	[4][13] = 2,
	[4][14] = 2,
	[4][15] = 2,
	[4][16] = 2,
	[4][17] = 2,
	[4][18] = 2,
	[4][19] = 2,
	[4][20] = 2,
	[4][21] = 2,
	[4][22] = 2,
	[4][23] = 2,
	[4][24] = 2,
	[4][25] = 2,
	[4][26] = 2,
	[4][27] = 2,
	[4][28] = 2,
	[4][29] = 2,
	[11][12] = 3,
	[11][13] = 3,
	[11][14] = 3,
	[11][15] = 3,
	[11][19] = 3,
	[11][20] = 3,
	[11][21] = 3,
	[11][22] = 3,
	[11][23] = 3,
	[11][24] = 3,
	[11][25] = 3,
	[11][26] = 3,
	[11][27] = 3,
	[11][28] = 3,
	[11][29] = 3,
	[12][12] = 4,
	[12][14] = 4,
	[12][26] = 4,
	[12][27] = 4,
	[12][28] = 4,
	[12][29] = 4,
	[13][30] = 5,
	[13][31] = 5,
	[14][12] = 6,
	[15][12] = 7,
	[15][14] = 7,
	[15][25] = 7,
	[15][26] = 7,
	[15][27] = 7,
	[15][28] = 7,
	[15][29] = 7,
	[16][12] = 8,
	[16][14] = 8,
	[16][27] = 8,
	[16][28] = 8,
	[16][29] = 8,
	[18][30] = 9,
	[18][31] = 9,
	[19][12] = 10,
	[19][27] = 10,
	[19][28] = 10,
	[19][29] = 10,
	[20][12] = 11,
	[20][28] = 11,
	[20][29] = 11,
	[21][12] = 12,
	[22][8] = 13,
	[22][9] = 13,
	[22][12] = 13,
	[22][13] = 13,
	[22][14] = 13,
	[22][15] = 13,
	[22][19] = 13,
	[22][20] = 13,
	[22][21] = 13,
	[22][22] = 13,
	[22][23] = 13,
	[22][24] = 13,
	[22][25] = 13,
	[22][26] = 13,
	[22][27] = 13,
	[22][28] = 13,
	[22][29] = 13,
	[23][8] = 14,
	[23][9] = 14,
	[23][12] = 14,
	[23][13] = 14,
	[23][14] = 14,
	[23][15] = 14,
	[23][16] = 14,
	[23][17] = 14,
	[23][18] = 14,
	[23][19] = 14,
	[23][20] = 14,
	[23][21] = 14,
	[23][22] = 14,
	[23][23] = 14,
	[23][24] = 14,
	[23][25] = 14,
	[23][26] = 14,
	[23][27] = 14,
	[23][28] = 14,
	[23][29] = 14,
	[24][8] = 15,
	[24][9] = 15,
	[24][12] = 15,
	[24][13] = 15,
	[24][14] = 15,
	[24][15] = 15,
	[24][16] = 15,
	[24][17] = 15,
	[24][18] = 15,
	[24][19] = 15,
	[24][20] = 15,
	[24][21] = 15,
	[24][22] = 15,
	[24][23] = 15,
	[24][24] = 15,
	[24][25] = 15,
	[24][26] = 15,
	[24][27] = 15,
	[24][28] = 15,
	[24][29] = 15,
	[25][12] = 16,
	[25][14] = 16,
	[25][23] = 16,
	[25][24] = 16,
	[25][25] = 16,
	[25][26] = 16,
	[25][27] = 16,
	[25][28] = 16,
	[25][29] = 16,
	[26][31] = 17,
	[27][12] = 18,
	[27][13] = 18,
	[27][14] = 18,
	[27][15] = 18,
	[27][21] = 18,
	[27][22] = 18,
	[27][23] = 18,
	[27][24] = 18,
	[27][25] = 18,
	[27][26] = 18,
	[27][27] = 18,
	[27][28] = 18,
	[27][29] = 18,
	[28][31] = 19,
	[30][8] = 1,
	[30][9] = 1,
	[30][13] = 1,
	[30][14] = 1,
	[30][15] = 1,
	[30][16] = 1,
	[30][17] = 1,
	[30][18] = 1,
	[30][19] = 1,
	[30][20] = 1,
	[30][21] = 1,
	[30][22] = 1,
	[30][23] = 1,
	[30][24] = 1,
	[30][25] = 1,
	[30][26] = 1,
	[30][27] = 1,
	[30][28] = 1,
	[30][29] = 1,
	[30][32] = 1,
	[32][8] = 2,
	[32][9] = 2,
	[32][13] = 2,
	[32][14] = 2,
	[32][15] = 2,
	[32][16] = 2,
	[32][17] = 2,
	[32][18] = 2,
	[32][19] = 2,
	[32][20] = 2,
	[32][21] = 2,
	[32][22] = 2,
	[32][23] = 2,
	[32][24] = 2,
	[32][25] = 2,
	[32][26] = 2,
	[32][27] = 2,
	[32][28] = 2,
	[32][29] = 2,
	[32][32] = 2,
	[39][13] = 3,
	[39][14] = 3,
	[39][15] = 3,
	[39][19] = 3,
	[39][20] = 3,
	[39][21] = 3,
	[39][22] = 3,
	[39][23] = 3,
	[39][24] = 3,
	[39][25] = 3,
	[39][26] = 3,
	[39][27] = 3,
	[39][28] = 3,
	[39][29] = 3,
	[39][32] = 3,
	[40][14] = 4,
	[40][26] = 4,
	[40][27] = 4,
	[40][28] = 4,
	[40][29] = 4,
	[40][32] = 4,
	[41][32] = 6,
	[42][14] = 7,
	[42][25] = 7,
	[42][26] = 7,
	[42][27] = 7,
	[42][28] = 7,
	[42][29] = 7,
	[42][32] = 7,
	[43][14] = 8,
	[43][27] = 8,
	[43][28] = 8,
	[43][29] = 8,
	[43][32] = 8,
	[45][27] = 10,
	[45][28] = 10,
	[45][29] = 10,
	[45][32] = 10,
	[46][28] = 11,
	[46][29] = 11,
	[46][32] = 11,
	[47][32] = 12,
	[48][8] = 13,
	[48][9] = 13,
	[48][13] = 13,
	[48][14] = 13,
	[48][15] = 13,
	[48][19] = 13,
	[48][20] = 13,
	[48][21] = 13,
	[48][22] = 13,
	[48][23] = 13,
	[48][24] = 13,
	[48][25] = 13,
	[48][26] = 13,
	[48][27] = 13,
	[48][28] = 13,
	[48][29] = 13,
	[48][32] = 13,
	[49][8] = 14,
	[49][9] = 14,
	[49][13] = 14,
	[49][14] = 14,
	[49][15] = 14,
	[49][16] = 14,
	[49][17] = 14,
	[49][18] = 14,
	[49][19] = 14,
	[49][20] = 14,
	[49][21] = 14,
	[49][22] = 14,
	[49][23] = 14,
	[49][24] = 14,
	[49][25] = 14,
	[49][26] = 14,
	[49][27] = 14,
	[49][28] = 14,
	[49][29] = 14,
	[49][32] = 14,
	[50][8] = 15,
	[50][9] = 15,
	[50][13] = 15,
	[50][14] = 15,
	[50][15] = 15,
	[50][16] = 15,
	[50][17] = 15,
	[50][18] = 15,
	[50][19] = 15,
	[50][20] = 15,
	[50][21] = 15,
	[50][22] = 15,
	[50][23] = 15,
	[50][24] = 15,
	[50][25] = 15,
	[50][26] = 15,
	[50][27] = 15,
	[50][28] = 15,
	[50][29] = 15,
	[50][32] = 15,
	[51][14] = 16,
	[51][23] = 16,
	[51][24] = 16,
	[51][25] = 16,
	[51][26] = 16,
	[51][27] = 16,
	[51][28] = 16,
	[51][29] = 16,
	[51][32] = 16,
	[52][13] = 18,
	[52][14] = 18,
	[52][15] = 18,
	[52][21] = 18,
	[52][22] = 18,
	[52][23] = 18,
	[52][24] = 18,
	[52][25] = 18,
	[52][26] = 18,
	[52][27] = 18,
	[52][28] = 18,
	[52][29] = 18,
	[52][32] = 18,
	[55][8] = 1,
	[55][9] = 1,
	[55][12] = 1,
	[55][13] = 1,
	[55][14] = 1,
	[55][15] = 1,
	[55][16] = 1,
	[55][17] = 1,
	[55][18] = 1,
	[55][19] = 1,
	[55][20] = 1,
	[55][21] = 1,
	[55][22] = 1,
	[55][23] = 1,
	[55][24] = 1,
	[55][25] = 1,
	[55][26] = 1,
	[55][27] = 1,
	[55][28] = 1,
	[55][29] = 1,
	[56][8] = 20,
	[56][9] = 20,
	[56][12] = 20,
	[56][13] = 20,
	[56][14] = 20,
	[56][15] = 20,
	[56][16] = 20,
	[56][17] = 20,
	[56][18] = 20,
	[56][19] = 20,
	[56][20] = 20,
	[56][21] = 20,
	[56][22] = 20,
	[56][23] = 20,
	[56][24] = 20,
	[56][25] = 20,
	[56][26] = 20,
	[56][27] = 20,
	[56][28] = 20,
	[56][29] = 20,
	[57][8] = 21,
	[57][9] = 21,
	[57][12] = 21,
	[57][13] = 21,
	[57][14] = 21,
	[57][15] = 21,
	[57][16] = 21,
	[57][17] = 21,
	[57][18] = 21,
	[57][19] = 21,
	[57][20] = 21,
	[57][21] = 21,
	[57][22] = 21,
	[57][23] = 21,
	[57][24] = 21,
	[57][25] = 21,
	[57][26] = 21,
	[57][27] = 21,
	[57][28] = 21,
	[57][29] = 21,
	[58][8] = 22,
	[58][9] = 22,
	[58][12] = 22,
	[58][13] = 22,
	[58][14] = 22,
	[58][15] = 22,
	[58][16] = 22,
	[58][17] = 22,
	[58][18] = 22,
	[58][19] = 22,
	[58][20] = 22,
	[58][21] = 22,
	[58][22] = 22,
	[58][23] = 22,
	[58][24] = 22,
	[58][25] = 22,
	[58][26] = 22,
	[58][27] = 22,
	[58][28] = 22,
	[58][29] = 22,
	[59][8] = 23,
	[59][9] = 23,
	[59][12] = 23,
	[59][13] = 23,
	[59][14] = 23,
	[59][15] = 23,
	[59][16] = 23,
	[59][17] = 23,
	[59][18] = 23,
	[59][19] = 23,
	[59][20] = 23,
	[59][21] = 23,
	[59][22] = 23,
	[59][23] = 23,
	[59][24] = 23,
	[59][25] = 23,
	[59][26] = 23,
	[59][27] = 23,
	[59][28] = 23,
	[59][29] = 23,
	[60][8] = 24,
	[60][9] = 24,
	[60][12] = 24,
	[60][13] = 24,
	[60][14] = 24,
	[60][15] = 24,
	[60][16] = 24,
	[60][17] = 24,
	[60][18] = 24,
	[60][19] = 24,
	[60][20] = 24,
	[60][21] = 24,
	[60][22] = 24,
	[60][23] = 24,
	[60][24] = 24,
	[60][25] = 24,
	[60][26] = 24,
	[60][27] = 24,
	[60][28] = 24,
	[60][29] = 24,
	[64][30] = 25,
	[64][31] = 25,
	[68][2] = 26,
	[68][3] = 26,
	[68][4] = 26,
	[68][5] = 26,
	[68][6] = 26,
	[68][7] = 26,
	[68][8] = 26,
	[68][9] = 26,
	[68][10] = 26,
	[68][30] = 26,
	[68][31] = 26,
	[69][30] = 27,
	[69][31] = 27,
	[88][8] = 20,
	[88][9] = 20,
	[88][13] = 20,
	[88][14] = 20,
	[88][15] = 20,
	[88][16] = 20,
	[88][17] = 20,
	[88][18] = 20,
	[88][19] = 20,
	[88][20] = 20,
	[88][21] = 20,
	[88][22] = 20,
	[88][23] = 20,
	[88][24] = 20,
	[88][25] = 20,
	[88][26] = 20,
	[88][27] = 20,
	[88][28] = 20,
	[88][29] = 20,
	[88][32] = 20,
	[89][8] = 21,
	[89][9] = 21,
	[89][13] = 21,
	[89][14] = 21,
	[89][15] = 21,
	[89][16] = 21,
	[89][17] = 21,
	[89][18] = 21,
	[89][19] = 21,
	[89][20] = 21,
	[89][21] = 21,
	[89][22] = 21,
	[89][23] = 21,
	[89][24] = 21,
	[89][25] = 21,
	[89][26] = 21,
	[89][27] = 21,
	[89][28] = 21,
	[89][29] = 21,
	[89][32] = 21,
	[90][8] = 22,
	[90][9] = 22,
	[90][13] = 22,
	[90][14] = 22,
	[90][15] = 22,
	[90][16] = 22,
	[90][17] = 22,
	[90][18] = 22,
	[90][19] = 22,
	[90][20] = 22,
	[90][21] = 22,
	[90][22] = 22,
	[90][23] = 22,
	[90][24] = 22,
	[90][25] = 22,
	[90][26] = 22,
	[90][27] = 22,
	[90][28] = 22,
	[90][29] = 22,
	[90][32] = 22,
	[91][8] = 23,
	[91][9] = 23,
	[91][13] = 23,
	[91][14] = 23,
	[91][15] = 23,
	[91][16] = 23,
	[91][17] = 23,
	[91][18] = 23,
	[91][19] = 23,
	[91][20] = 23,
	[91][21] = 23,
	[91][22] = 23,
	[91][23] = 23,
	[91][24] = 23,
	[91][25] = 23,
	[91][26] = 23,
	[91][27] = 23,
	[91][28] = 23,
	[91][29] = 23,
	[91][32] = 23,
	[92][8] = 24,
	[92][9] = 24,
	[92][13] = 24,
	[92][14] = 24,
	[92][15] = 24,
	[92][16] = 24,
	[92][17] = 24,
	[92][18] = 24,
	[92][19] = 24,
	[92][20] = 24,
	[92][21] = 24,
	[92][22] = 24,
	[92][23] = 24,
	[92][24] = 24,
	[92][25] = 24,
	[92][26] = 24,
	[92][27] = 24,
	[92][28] = 24,
	[92][29] = 24,
	[92][32] = 24,
	[99][8] = 28,
	[99][9] = 28,
	[99][12] = 28,
	[99][13] = 28,
	[99][14] = 28,
	[99][15] = 28,
	[99][16] = 28,
	[99][17] = 28,
	[99][18] = 28,
	[99][19] = 28,
	[99][20] = 28,
	[99][21] = 28,
	[99][22] = 28,
	[99][23] = 28,
	[99][24] = 28,
	[99][25] = 28,
	[99][26] = 28,
	[99][27] = 28,
	[99][28] = 28,
	[99][29] = 28,
	[114][2] = 1,
	[114][3] = 1,
	[114][4] = 1,
	[114][13] = 1,
	[114][14] = 1,
	[114][15] = 1,
	[114][32] = 1,
	[116][2] = 2,
	[116][3] = 2,
	[116][4] = 2,
	[116][13] = 2,
	[116][14] = 2,
	[116][15] = 2,
	[116][32] = 2,
	[118][13] = 29,
	[118][14] = 29,
	[118][15] = 29,
	[118][32] = 29,
	[119][32] = 30,
	[120][8] = 31,
	[120][9] = 31,
	[120][12] = 31,
	[120][13] = 31,
	[120][14] = 31,
	[120][15] = 31,
	[120][19] = 31,
	[120][20] = 31,
	[120][21] = 31,
	[120][22] = 31,
	[120][23] = 31,
	[120][24] = 31,
	[120][25] = 31,
	[120][26] = 31,
	[120][27] = 31,
	[120][28] = 31,
	[120][29] = 31,
	[121][8] = 32,
	[121][9] = 32,
	[121][12] = 32,
	[121][13] = 32,
	[121][14] = 32,
	[121][15] = 32,
	[121][19] = 32,
	[121][20] = 32,
	[121][21] = 32,
	[121][22] = 32,
	[121][23] = 32,
	[121][24] = 32,
	[121][25] = 32,
	[121][26] = 32,
	[121][27] = 32,
	[121][28] = 32,
	[121][29] = 32,
	[122][8] = 33,
	[122][9] = 33,
	[122][12] = 33,
	[122][13] = 33,
	[122][14] = 33,
	[122][15] = 33,
	[122][19] = 33,
	[122][20] = 33,
	[122][21] = 33,
	[122][22] = 33,
	[122][23] = 33,
	[122][24] = 33,
	[122][25] = 33,
	[122][26] = 33,
	[122][27] = 33,
	[122][28] = 33,
	[122][29] = 33,
	[123][12] = 34,
	[123][14] = 34,
	[123][25] = 34,
	[123][26] = 34,
	[123][27] = 34,
	[123][28] = 34,
	[123][29] = 34,
	[124][12] = 35,
	[124][14] = 35,
	[124][23] = 35,
	[124][24] = 35,
	[124][25] = 35,
	[124][26] = 35,
	[124][27] = 35,
	[124][28] = 35,
	[124][29] = 35,
	[125][12] = 36,
	[125][14] = 36,
	[125][23] = 36,
	[125][24] = 36,
	[125][25] = 36,
	[125][26] = 36,
	[125][27] = 36,
	[125][28] = 36,
	[125][29] = 36,
	[126][12] = 37,
	[126][14] = 37,
	[126][23] = 37,
	[126][24] = 37,
	[126][25] = 37,
	[126][26] = 37,
	[126][27] = 37,
	[126][28] = 37,
	[126][29] = 37,
	[127][12] = 38,
	[127][14] = 38,
	[127][26] = 38,
	[127][27] = 38,
	[127][28] = 38,
	[127][29] = 38,
	[128][12] = 39,
	[128][14] = 39,
	[128][27] = 39,
	[128][28] = 39,
	[128][29] = 39,
	[129][12] = 40,
	[129][27] = 40,
	[129][28] = 40,
	[129][29] = 40,
	[130][12] = 41,
	[130][28] = 41,
	[130][29] = 41,
	[131][8] = 1,
	[131][9] = 1,
	[131][11] = 1,
	[131][13] = 1,
	[131][14] = 1,
	[131][15] = 1,
	[131][16] = 1,
	[131][17] = 1,
	[131][18] = 1,
	[131][19] = 1,
	[131][20] = 1,
	[131][21] = 1,
	[131][22] = 1,
	[131][23] = 1,
	[131][24] = 1,
	[131][25] = 1,
	[131][26] = 1,
	[131][27] = 1,
	[131][28] = 1,
	[131][29] = 1,
	[133][8] = 2,
	[133][9] = 2,
	[133][11] = 2,
	[133][13] = 2,
	[133][14] = 2,
	[133][15] = 2,
	[133][16] = 2,
	[133][17] = 2,
	[133][18] = 2,
	[133][19] = 2,
	[133][20] = 2,
	[133][21] = 2,
	[133][22] = 2,
	[133][23] = 2,
	[133][24] = 2,
	[133][25] = 2,
	[133][26] = 2,
	[133][27] = 2,
	[133][28] = 2,
	[133][29] = 2,
	[140][11] = 3,
	[140][13] = 3,
	[140][14] = 3,
	[140][15] = 3,
	[140][19] = 3,
	[140][20] = 3,
	[140][21] = 3,
	[140][22] = 3,
	[140][23] = 3,
	[140][24] = 3,
	[140][25] = 3,
	[140][26] = 3,
	[140][27] = 3,
	[140][28] = 3,
	[140][29] = 3,
	[141][11] = 4,
	[141][14] = 4,
	[141][26] = 4,
	[141][27] = 4,
	[141][28] = 4,
	[141][29] = 4,
	[142][11] = 6,
	[143][11] = 7,
	[143][14] = 7,
	[143][25] = 7,
	[143][26] = 7,
	[143][27] = 7,
	[143][28] = 7,
	[143][29] = 7,
	[144][11] = 8,
	[144][14] = 8,
	[144][27] = 8,
	[144][28] = 8,
	[144][29] = 8,
	[146][11] = 10,
	[146][27] = 10,
	[146][28] = 10,
	[146][29] = 10,
	[147][11] = 11,
	[147][28] = 11,
	[147][29] = 11,
	[148][11] = 12,
	[149][8] = 13,
	[149][9] = 13,
	[149][11] = 13,
	[149][13] = 13,
	[149][14] = 13,
	[149][15] = 13,
	[149][19] = 13,
	[149][20] = 13,
	[149][21] = 13,
	[149][22] = 13,
	[149][23] = 13,
	[149][24] = 13,
	[149][25] = 13,
	[149][26] = 13,
	[149][27] = 13,
	[149][28] = 13,
	[149][29] = 13,
	[150][8] = 14,
	[150][9] = 14,
	[150][11] = 14,
	[150][13] = 14,
	[150][14] = 14,
	[150][15] = 14,
	[150][16] = 14,
	[150][17] = 14,
	[150][18] = 14,
	[150][19] = 14,
	[150][20] = 14,
	[150][21] = 14,
	[150][22] = 14,
	[150][23] = 14,
	[150][24] = 14,
	[150][25] = 14,
	[150][26] = 14,
	[150][27] = 14,
	[150][28] = 14,
	[150][29] = 14,
	[151][8] = 15,
	[151][9] = 15,
	[151][11] = 15,
	[151][13] = 15,
	[151][14] = 15,
	[151][15] = 15,
	[151][16] = 15,
	[151][17] = 15,
	[151][18] = 15,
	[151][19] = 15,
	[151][20] = 15,
	[151][21] = 15,
	[151][22] = 15,
	[151][23] = 15,
	[151][24] = 15,
	[151][25] = 15,
	[151][26] = 15,
	[151][27] = 15,
	[151][28] = 15,
	[151][29] = 15,
	[152][11] = 16,
	[152][14] = 16,
	[152][23] = 16,
	[152][24] = 16,
	[152][25] = 16,
	[152][26] = 16,
	[152][27] = 16,
	[152][28] = 16,
	[152][29] = 16,
	[153][11] = 18,
	[153][13] = 18,
	[153][14] = 18,
	[153][15] = 18,
	[153][21] = 18,
	[153][22] = 18,
	[153][23] = 18,
	[153][24] = 18,
	[153][25] = 18,
	[153][26] = 18,
	[153][27] = 18,
	[153][28] = 18,
	[153][29] = 18,
	[154][8] = 42,
	[154][9] = 42,
	[154][12] = 42,
	[154][13] = 42,
	[154][14] = 42,
	[154][15] = 42,
	[154][16] = 42,
	[154][17] = 42,
	[154][18] = 42,
	[154][19] = 42,
	[154][20] = 42,
	[154][21] = 42,
	[154][22] = 42,
	[154][23] = 42,
	[154][24] = 42,
	[154][25] = 42,
	[154][26] = 42,
	[154][27] = 42,
	[154][28] = 42,
	[154][29] = 42,
	[155][8] = 43,
	[155][9] = 43,
	[155][12] = 43,
	[155][13] = 43,
	[155][14] = 43,
	[155][15] = 43,
	[155][16] = 43,
	[155][17] = 43,
	[155][18] = 43,
	[155][19] = 43,
	[155][20] = 43,
	[155][21] = 43,
	[155][22] = 43,
	[155][23] = 43,
	[155][24] = 43,
	[155][25] = 43,
	[155][26] = 43,
	[155][27] = 43,
	[155][28] = 43,
	[155][29] = 43,
	[156][8] = 44,
	[156][9] = 44,
	[156][12] = 44,
	[156][13] = 44,
	[156][14] = 44,
	[156][15] = 44,
	[156][16] = 44,
	[156][17] = 44,
	[156][18] = 44,
	[156][19] = 44,
	[156][20] = 44,
	[156][21] = 44,
	[156][22] = 44,
	[156][23] = 44,
	[156][24] = 44,
	[156][25] = 44,
	[156][26] = 44,
	[156][27] = 44,
	[156][28] = 44,
	[156][29] = 44,
	[157][8] = 45,
	[157][9] = 45,
	[157][12] = 45,
	[157][13] = 45,
	[157][14] = 45,
	[157][15] = 45,
	[157][16] = 45,
	[157][17] = 45,
	[157][18] = 45,
	[157][19] = 45,
	[157][20] = 45,
	[157][21] = 45,
	[157][22] = 45,
	[157][23] = 45,
	[157][24] = 45,
	[157][25] = 45,
	[157][26] = 45,
	[157][27] = 45,
	[157][28] = 45,
	[157][29] = 45,
	[158][12] = 46,
	[158][13] = 46,
	[158][14] = 46,
	[158][15] = 46,
	[158][21] = 46,
	[158][22] = 46,
	[158][23] = 46,
	[158][24] = 46,
	[158][25] = 46,
	[158][26] = 46,
	[158][27] = 46,
	[158][28] = 46,
	[158][29] = 46,
	[159][12] = 47,
	[159][13] = 47,
	[159][14] = 47,
	[159][15] = 47,
	[159][21] = 47,
	[159][22] = 47,
	[159][23] = 47,
	[159][24] = 47,
	[159][25] = 47,
	[159][26] = 47,
	[159][27] = 47,
	[159][28] = 47,
	[159][29] = 47,
	[160][12] = 48,
	[160][13] = 48,
	[160][14] = 48,
	[160][15] = 48,
	[160][21] = 48,
	[160][22] = 48,
	[160][23] = 48,
	[160][24] = 48,
	[160][25] = 48,
	[160][26] = 48,
	[160][27] = 48,
	[160][28] = 48,
	[160][29] = 48,
	[161][12] = 49,
	[161][13] = 49,
	[161][14] = 49,
	[161][15] = 49,
	[161][21] = 49,
	[161][22] = 49,
	[161][23] = 49,
	[161][24] = 49,
	[161][25] = 49,
	[161][26] = 49,
	[161][27] = 49,
	[161][28] = 49,
	[161][29] = 49,
	[162][12] = 50,
	[162][13] = 50,
	[162][14] = 50,
	[162][15] = 50,
	[162][21] = 50,
	[162][22] = 50,
	[162][23] = 50,
	[162][24] = 50,
	[162][25] = 50,
	[162][26] = 50,
	[162][27] = 50,
	[162][28] = 50,
	[162][29] = 50,
	[163][12] = 51,
	[163][13] = 51,
	[163][14] = 51,
	[163][15] = 51,
	[163][19] = 51,
	[163][20] = 51,
	[163][21] = 51,
	[163][22] = 51,
	[163][23] = 51,
	[163][24] = 51,
	[163][25] = 51,
	[163][26] = 51,
	[163][27] = 51,
	[163][28] = 51,
	[163][29] = 51,
	[164][12] = 52,
	[164][13] = 52,
	[164][14] = 52,
	[164][15] = 52,
	[164][19] = 52,
	[164][20] = 52,
	[164][21] = 52,
	[164][22] = 52,
	[164][23] = 52,
	[164][24] = 52,
	[164][25] = 52,
	[164][26] = 52,
	[164][27] = 52,
	[164][28] = 52,
	[164][29] = 52,
	[165][12] = 53,
	[165][13] = 53,
	[165][14] = 53,
	[165][15] = 53,
	[165][19] = 53,
	[165][20] = 53,
	[165][21] = 53,
	[165][22] = 53,
	[165][23] = 53,
	[165][24] = 53,
	[165][25] = 53,
	[165][26] = 53,
	[165][27] = 53,
	[165][28] = 53,
	[165][29] = 53,
	[166][31] = 54,
	[167][2] = 55,
	[167][3] = 55,
	[167][4] = 55,
	[167][5] = 55,
	[167][6] = 55,
	[167][7] = 55,
	[167][8] = 55,
	[167][9] = 55,
	[167][10] = 55,
	[167][30] = 55,
	[167][31] = 55,
	[168][8] = 28,
	[168][9] = 28,
	[168][13] = 28,
	[168][14] = 28,
	[168][15] = 28,
	[168][16] = 28,
	[168][17] = 28,
	[168][18] = 28,
	[168][19] = 28,
	[168][20] = 28,
	[168][21] = 28,
	[168][22] = 28,
	[168][23] = 28,
	[168][24] = 28,
	[168][25] = 28,
	[168][26] = 28,
	[168][27] = 28,
	[168][28] = 28,
	[168][29] = 28,
	[168][32] = 28,
	[171][8] = 31,
	[171][9] = 31,
	[171][13] = 31,
	[171][14] = 31,
	[171][15] = 31,
	[171][19] = 31,
	[171][20] = 31,
	[171][21] = 31,
	[171][22] = 31,
	[171][23] = 31,
	[171][24] = 31,
	[171][25] = 31,
	[171][26] = 31,
	[171][27] = 31,
	[171][28] = 31,
	[171][29] = 31,
	[171][32] = 31,
	[172][8] = 32,
	[172][9] = 32,
	[172][13] = 32,
	[172][14] = 32,
	[172][15] = 32,
	[172][19] = 32,
	[172][20] = 32,
	[172][21] = 32,
	[172][22] = 32,
	[172][23] = 32,
	[172][24] = 32,
	[172][25] = 32,
	[172][26] = 32,
	[172][27] = 32,
	[172][28] = 32,
	[172][29] = 32,
	[172][32] = 32,
	[173][8] = 33,
	[173][9] = 33,
	[173][13] = 33,
	[173][14] = 33,
	[173][15] = 33,
	[173][19] = 33,
	[173][20] = 33,
	[173][21] = 33,
	[173][22] = 33,
	[173][23] = 33,
	[173][24] = 33,
	[173][25] = 33,
	[173][26] = 33,
	[173][27] = 33,
	[173][28] = 33,
	[173][29] = 33,
	[173][32] = 33,
	[174][14] = 34,
	[174][25] = 34,
	[174][26] = 34,
	[174][27] = 34,
	[174][28] = 34,
	[174][29] = 34,
	[174][32] = 34,
	[175][14] = 35,
	[175][23] = 35,
	[175][24] = 35,
	[175][25] = 35,
	[175][26] = 35,
	[175][27] = 35,
	[175][28] = 35,
	[175][29] = 35,
	[175][32] = 35,
	[176][14] = 36,
	[176][23] = 36,
	[176][24] = 36,
	[176][25] = 36,
	[176][26] = 36,
	[176][27] = 36,
	[176][28] = 36,
	[176][29] = 36,
	[176][32] = 36,
	[177][14] = 37,
	[177][23] = 37,
	[177][24] = 37,
	[177][25] = 37,
	[177][26] = 37,
	[177][27] = 37,
	[177][28] = 37,
	[177][29] = 37,
	[177][32] = 37,
	[178][14] = 38,
	[178][26] = 38,
	[178][27] = 38,
	[178][28] = 38,
	[178][29] = 38,
	[178][32] = 38,
	[179][14] = 39,
	[179][27] = 39,
	[179][28] = 39,
	[179][29] = 39,
	[179][32] = 39,
	[180][27] = 40,
	[180][28] = 40,
	[180][29] = 40,
	[180][32] = 40,
	[181][28] = 41,
	[181][29] = 41,
	[181][32] = 41,
	[183][8] = 42,
	[183][9] = 42,
	[183][13] = 42,
	[183][14] = 42,
	[183][15] = 42,
	[183][16] = 42,
	[183][17] = 42,
	[183][18] = 42,
	[183][19] = 42,
	[183][20] = 42,
	[183][21] = 42,
	[183][22] = 42,
	[183][23] = 42,
	[183][24] = 42,
	[183][25] = 42,
	[183][26] = 42,
	[183][27] = 42,
	[183][28] = 42,
	[183][29] = 42,
	[183][32] = 42,
	[184][8] = 43,
	[184][9] = 43,
	[184][13] = 43,
	[184][14] = 43,
	[184][15] = 43,
	[184][16] = 43,
	[184][17] = 43,
	[184][18] = 43,
	[184][19] = 43,
	[184][20] = 43,
	[184][21] = 43,
	[184][22] = 43,
	[184][23] = 43,
	[184][24] = 43,
	[184][25] = 43,
	[184][26] = 43,
	[184][27] = 43,
	[184][28] = 43,
	[184][29] = 43,
	[184][32] = 43,
	[185][8] = 44,
	[185][9] = 44,
	[185][13] = 44,
	[185][14] = 44,
	[185][15] = 44,
	[185][16] = 44,
	[185][17] = 44,
	[185][18] = 44,
	[185][19] = 44,
	[185][20] = 44,
	[185][21] = 44,
	[185][22] = 44,
	[185][23] = 44,
	[185][24] = 44,
	[185][25] = 44,
	[185][26] = 44,
	[185][27] = 44,
	[185][28] = 44,
	[185][29] = 44,
	[185][32] = 44,
	[186][8] = 45,
	[186][9] = 45,
	[186][13] = 45,
	[186][14] = 45,
	[186][15] = 45,
	[186][16] = 45,
	[186][17] = 45,
	[186][18] = 45,
	[186][19] = 45,
	[186][20] = 45,
	[186][21] = 45,
	[186][22] = 45,
	[186][23] = 45,
	[186][24] = 45,
	[186][25] = 45,
	[186][26] = 45,
	[186][27] = 45,
	[186][28] = 45,
	[186][29] = 45,
	[186][32] = 45,
	[187][13] = 46,
	[187][14] = 46,
	[187][15] = 46,
	[187][21] = 46,
	[187][22] = 46,
	[187][23] = 46,
	[187][24] = 46,
	[187][25] = 46,
	[187][26] = 46,
	[187][27] = 46,
	[187][28] = 46,
	[187][29] = 46,
	[187][32] = 46,
	[188][13] = 47,
	[188][14] = 47,
	[188][15] = 47,
	[188][21] = 47,
	[188][22] = 47,
	[188][23] = 47,
	[188][24] = 47,
	[188][25] = 47,
	[188][26] = 47,
	[188][27] = 47,
	[188][28] = 47,
	[188][29] = 47,
	[188][32] = 47,
	[189][13] = 48,
	[189][14] = 48,
	[189][15] = 48,
	[189][21] = 48,
	[189][22] = 48,
	[189][23] = 48,
	[189][24] = 48,
	[189][25] = 48,
	[189][26] = 48,
	[189][27] = 48,
	[189][28] = 48,
	[189][29] = 48,
	[189][32] = 48,
	[190][13] = 49,
	[190][14] = 49,
	[190][15] = 49,
	[190][21] = 49,
	[190][22] = 49,
	[190][23] = 49,
	[190][24] = 49,
	[190][25] = 49,
	[190][26] = 49,
	[190][27] = 49,
	[190][28] = 49,
	[190][29] = 49,
	[190][32] = 49,
	[191][13] = 50,
	[191][14] = 50,
	[191][15] = 50,
	[191][21] = 50,
	[191][22] = 50,
	[191][23] = 50,
	[191][24] = 50,
	[191][25] = 50,
	[191][26] = 50,
	[191][27] = 50,
	[191][28] = 50,
	[191][29] = 50,
	[191][32] = 50,
	[192][13] = 51,
	[192][14] = 51,
	[192][15] = 51,
	[192][19] = 51,
	[192][20] = 51,
	[192][21] = 51,
	[192][22] = 51,
	[192][23] = 51,
	[192][24] = 51,
	[192][25] = 51,
	[192][26] = 51,
	[192][27] = 51,
	[192][28] = 51,
	[192][29] = 51,
	[192][32] = 51,
	[193][13] = 52,
	[193][14] = 52,
	[193][15] = 52,
	[193][19] = 52,
	[193][20] = 52,
	[193][21] = 52,
	[193][22] = 52,
	[193][23] = 52,
	[193][24] = 52,
	[193][25] = 52,
	[193][26] = 52,
	[193][27] = 52,
	[193][28] = 52,
	[193][29] = 52,
	[193][32] = 52,
	[194][13] = 53,
	[194][14] = 53,
	[194][15] = 53,
	[194][19] = 53,
	[194][20] = 53,
	[194][21] = 53,
	[194][22] = 53,
	[194][23] = 53,
	[194][24] = 53,
	[194][25] = 53,
	[194][26] = 53,
	[194][27] = 53,
	[194][28] = 53,
	[194][29] = 53,
	[194][32] = 53,
	[195][8] = 56,
	[195][9] = 56,
	[195][12] = 56,
	[195][13] = 56,
	[195][14] = 56,
	[195][15] = 56,
	[195][16] = 56,
	[195][17] = 56,
	[195][18] = 56,
	[195][19] = 56,
	[195][20] = 56,
	[195][21] = 56,
	[195][22] = 56,
	[195][23] = 56,
	[195][24] = 56,
	[195][25] = 56,
	[195][26] = 56,
	[195][27] = 56,
	[195][28] = 56,
	[195][29] = 56,
	[196][8] = 57,
	[196][9] = 57,
	[196][12] = 57,
	[196][13] = 57,
	[196][14] = 57,
	[196][15] = 57,
	[196][16] = 57,
	[196][17] = 57,
	[196][18] = 57,
	[196][19] = 57,
	[196][20] = 57,
	[196][21] = 57,
	[196][22] = 57,
	[196][23] = 57,
	[196][24] = 57,
	[196][25] = 57,
	[196][26] = 57,
	[196][27] = 57,
	[196][28] = 57,
	[196][29] = 57,
	[198][8] = 58,
	[198][9] = 58,
	[198][12] = 58,
	[198][13] = 58,
	[198][14] = 58,
	[198][15] = 58,
	[198][16] = 58,
	[198][17] = 58,
	[198][18] = 58,
	[198][19] = 58,
	[198][20] = 58,
	[198][21] = 58,
	[198][22] = 58,
	[198][23] = 58,
	[198][24] = 58,
	[198][25] = 58,
	[198][26] = 58,
	[198][27] = 58,
	[198][28] = 58,
	[198][29] = 58,
	[199][13] = 59,
	[199][14] = 59,
	[199][15] = 59,
	[199][32] = 59,
	[200][13] = 60,
	[200][14] = 60,
	[200][15] = 60,
	[200][32] = 60,
	[207][8] = 20,
	[207][9] = 20,
	[207][11] = 20,
	[207][13] = 20,
	[207][14] = 20,
	[207][15] = 20,
	[207][16] = 20,
	[207][17] = 20,
	[207][18] = 20,
	[207][19] = 20,
	[207][20] = 20,
	[207][21] = 20,
	[207][22] = 20,
	[207][23] = 20,
	[207][24] = 20,
	[207][25] = 20,
	[207][26] = 20,
	[207][27] = 20,
	[207][28] = 20,
	[207][29] = 20,
	[208][8] = 21,
	[208][9] = 21,
	[208][11] = 21,
	[208][13] = 21,
	[208][14] = 21,
	[208][15] = 21,
	[208][16] = 21,
	[208][17] = 21,
	[208][18] = 21,
	[208][19] = 21,
	[208][20] = 21,
	[208][21] = 21,
	[208][22] = 21,
	[208][23] = 21,
	[208][24] = 21,
	[208][25] = 21,
	[208][26] = 21,
	[208][27] = 21,
	[208][28] = 21,
	[208][29] = 21,
	[209][8] = 22,
	[209][9] = 22,
	[209][11] = 22,
	[209][13] = 22,
	[209][14] = 22,
	[209][15] = 22,
	[209][16] = 22,
	[209][17] = 22,
	[209][18] = 22,
	[209][19] = 22,
	[209][20] = 22,
	[209][21] = 22,
	[209][22] = 22,
	[209][23] = 22,
	[209][24] = 22,
	[209][25] = 22,
	[209][26] = 22,
	[209][27] = 22,
	[209][28] = 22,
	[209][29] = 22,
	[210][8] = 23,
	[210][9] = 23,
	[210][11] = 23,
	[210][13] = 23,
	[210][14] = 23,
	[210][15] = 23,
	[210][16] = 23,
	[210][17] = 23,
	[210][18] = 23,
	[210][19] = 23,
	[210][20] = 23,
	[210][21] = 23,
	[210][22] = 23,
	[210][23] = 23,
	[210][24] = 23,
	[210][25] = 23,
	[210][26] = 23,
	[210][27] = 23,
	[210][28] = 23,
	[210][29] = 23,
	[211][8] = 24,
	[211][9] = 24,
	[211][11] = 24,
	[211][13] = 24,
	[211][14] = 24,
	[211][15] = 24,
	[211][16] = 24,
	[211][17] = 24,
	[211][18] = 24,
	[211][19] = 24,
	[211][20] = 24,
	[211][21] = 24,
	[211][22] = 24,
	[211][23] = 24,
	[211][24] = 24,
	[211][25] = 24,
	[211][26] = 24,
	[211][27] = 24,
	[211][28] = 24,
	[211][29] = 24,
	[232][8] = 56,
	[232][9] = 56,
	[232][13] = 56,
	[232][14] = 56,
	[232][15] = 56,
	[232][16] = 56,
	[232][17] = 56,
	[232][18] = 56,
	[232][19] = 56,
	[232][20] = 56,
	[232][21] = 56,
	[232][22] = 56,
	[232][23] = 56,
	[232][24] = 56,
	[232][25] = 56,
	[232][26] = 56,
	[232][27] = 56,
	[232][28] = 56,
	[232][29] = 56,
	[232][32] = 56,
	[233][8] = 57,
	[233][9] = 57,
	[233][13] = 57,
	[233][14] = 57,
	[233][15] = 57,
	[233][16] = 57,
	[233][17] = 57,
	[233][18] = 57,
	[233][19] = 57,
	[233][20] = 57,
	[233][21] = 57,
	[233][22] = 57,
	[233][23] = 57,
	[233][24] = 57,
	[233][25] = 57,
	[233][26] = 57,
	[233][27] = 57,
	[233][28] = 57,
	[233][29] = 57,
	[233][32] = 57,
	[234][8] = 58,
	[234][9] = 58,
	[234][13] = 58,
	[234][14] = 58,
	[234][15] = 58,
	[234][16] = 58,
	[234][17] = 58,
	[234][18] = 58,
	[234][19] = 58,
	[234][20] = 58,
	[234][21] = 58,
	[234][22] = 58,
	[234][23] = 58,
	[234][24] = 58,
	[234][25] = 58,
	[234][26] = 58,
	[234][27] = 58,
	[234][28] = 58,
	[234][29] = 58,
	[234][32] = 58,
	[236][2] = 28,
	[236][3] = 28,
	[236][4] = 28,
	[236][13] = 28,
	[236][14] = 28,
	[236][15] = 28,
	[236][32] = 28,
	[237][13] = 61,
	[237][14] = 61,
	[237][15] = 61,
	[237][32] = 61,
	[238][14] = 1,
	[238][15] = 1,
	[238][32] = 1,
	[240][14] = 2,
	[240][15] = 2,
	[240][32] = 2,
	[241][32] = 62,
	[242][2] = 1,
	[242][3] = 1,
	[242][4] = 1,
	[242][14] = 1,
	[242][15] = 1,
	[242][32] = 1,
	[244][2] = 2,
	[244][3] = 2,
	[244][4] = 2,
	[244][14] = 2,
	[244][15] = 2,
	[244][32] = 2,
	[245][32] = 63,
	[246][14] = 29,
	[246][15] = 29,
	[246][32] = 29,
	[247][32] = 64,
	[248][32] = 1,
	[250][32] = 2,
	[251][32] = 65,
	[252][32] = 66,
	[253][8] = 28,
	[253][9] = 28,
	[253][11] = 28,
	[253][13] = 28,
	[253][14] = 28,
	[253][15] = 28,
	[253][16] = 28,
	[253][17] = 28,
	[253][18] = 28,
	[253][19] = 28,
	[253][20] = 28,
	[253][21] = 28,
	[253][22] = 28,
	[253][23] = 28,
	[253][24] = 28,
	[253][25] = 28,
	[253][26] = 28,
	[253][27] = 28,
	[253][28] = 28,
	[253][29] = 28,
	[256][8] = 31,
	[256][9] = 31,
	[256][11] = 31,
	[256][13] = 31,
	[256][14] = 31,
	[256][15] = 31,
	[256][19] = 31,
	[256][20] = 31,
	[256][21] = 31,
	[256][22] = 31,
	[256][23] = 31,
	[256][24] = 31,
	[256][25] = 31,
	[256][26] = 31,
	[256][27] = 31,
	[256][28] = 31,
	[256][29] = 31,
	[257][8] = 32,
	[257][9] = 32,
	[257][11] = 32,
	[257][13] = 32,
	[257][14] = 32,
	[257][15] = 32,
	[257][19] = 32,
	[257][20] = 32,
	[257][21] = 32,
	[257][22] = 32,
	[257][23] = 32,
	[257][24] = 32,
	[257][25] = 32,
	[257][26] = 32,
	[257][27] = 32,
	[257][28] = 32,
	[257][29] = 32,
	[258][8] = 33,
	[258][9] = 33,
	[258][11] = 33,
	[258][13] = 33,
	[258][14] = 33,
	[258][15] = 33,
	[258][19] = 33,
	[258][20] = 33,
	[258][21] = 33,
	[258][22] = 33,
	[258][23] = 33,
	[258][24] = 33,
	[258][25] = 33,
	[258][26] = 33,
	[258][27] = 33,
	[258][28] = 33,
	[258][29] = 33,
	[259][11] = 34,
	[259][14] = 34,
	[259][25] = 34,
	[259][26] = 34,
	[259][27] = 34,
	[259][28] = 34,
	[259][29] = 34,
	[260][11] = 35,
	[260][14] = 35,
	[260][23] = 35,
	[260][24] = 35,
	[260][25] = 35,
	[260][26] = 35,
	[260][27] = 35,
	[260][28] = 35,
	[260][29] = 35,
	[261][11] = 36,
	[261][14] = 36,
	[261][23] = 36,
	[261][24] = 36,
	[261][25] = 36,
	[261][26] = 36,
	[261][27] = 36,
	[261][28] = 36,
	[261][29] = 36,
	[262][11] = 37,
	[262][14] = 37,
	[262][23] = 37,
	[262][24] = 37,
	[262][25] = 37,
	[262][26] = 37,
	[262][27] = 37,
	[262][28] = 37,
	[262][29] = 37,
	[263][11] = 38,
	[263][14] = 38,
	[263][26] = 38,
	[263][27] = 38,
	[263][28] = 38,
	[263][29] = 38,
	[264][12] = 67,
	[265][11] = 39,
	[265][14] = 39,
	[265][27] = 39,
	[265][28] = 39,
	[265][29] = 39,
	[266][11] = 40,
	[266][27] = 40,
	[266][28] = 40,
	[266][29] = 40,
	[267][11] = 41,
	[267][28] = 41,
	[267][29] = 41,
	[269][8] = 42,
	[269][9] = 42,
	[269][11] = 42,
	[269][13] = 42,
	[269][14] = 42,
	[269][15] = 42,
	[269][16] = 42,
	[269][17] = 42,
	[269][18] = 42,
	[269][19] = 42,
	[269][20] = 42,
	[269][21] = 42,
	[269][22] = 42,
	[269][23] = 42,
	[269][24] = 42,
	[269][25] = 42,
	[269][26] = 42,
	[269][27] = 42,
	[269][28] = 42,
	[269][29] = 42,
	[270][8] = 43,
	[270][9] = 43,
	[270][11] = 43,
	[270][13] = 43,
	[270][14] = 43,
	[270][15] = 43,
	[270][16] = 43,
	[270][17] = 43,
	[270][18] = 43,
	[270][19] = 43,
	[270][20] = 43,
	[270][21] = 43,
	[270][22] = 43,
	[270][23] = 43,
	[270][24] = 43,
	[270][25] = 43,
	[270][26] = 43,
	[270][27] = 43,
	[270][28] = 43,
	[270][29] = 43,
	[271][8] = 44,
	[271][9] = 44,
	[271][11] = 44,
	[271][13] = 44,
	[271][14] = 44,
	[271][15] = 44,
	[271][16] = 44,
	[271][17] = 44,
	[271][18] = 44,
	[271][19] = 44,
	[271][20] = 44,
	[271][21] = 44,
	[271][22] = 44,
	[271][23] = 44,
	[271][24] = 44,
	[271][25] = 44,
	[271][26] = 44,
	[271][27] = 44,
	[271][28] = 44,
	[271][29] = 44,
	[272][8] = 45,
	[272][9] = 45,
	[272][11] = 45,
	[272][13] = 45,
	[272][14] = 45,
	[272][15] = 45,
	[272][16] = 45,
	[272][17] = 45,
	[272][18] = 45,
	[272][19] = 45,
	[272][20] = 45,
	[272][21] = 45,
	[272][22] = 45,
	[272][23] = 45,
	[272][24] = 45,
	[272][25] = 45,
	[272][26] = 45,
	[272][27] = 45,
	[272][28] = 45,
	[272][29] = 45,
	[273][11] = 46,
	[273][13] = 46,
	[273][14] = 46,
	[273][15] = 46,
	[273][21] = 46,
	[273][22] = 46,
	[273][23] = 46,
	[273][24] = 46,
	[273][25] = 46,
	[273][26] = 46,
	[273][27] = 46,
	[273][28] = 46,
	[273][29] = 46,
	[274][11] = 47,
	[274][13] = 47,
	[274][14] = 47,
	[274][15] = 47,
	[274][21] = 47,
	[274][22] = 47,
	[274][23] = 47,
	[274][24] = 47,
	[274][25] = 47,
	[274][26] = 47,
	[274][27] = 47,
	[274][28] = 47,
	[274][29] = 47,
	[275][11] = 48,
	[275][13] = 48,
	[275][14] = 48,
	[275][15] = 48,
	[275][21] = 48,
	[275][22] = 48,
	[275][23] = 48,
	[275][24] = 48,
	[275][25] = 48,
	[275][26] = 48,
	[275][27] = 48,
	[275][28] = 48,
	[275][29] = 48,
	[276][11] = 49,
	[276][13] = 49,
	[276][14] = 49,
	[276][15] = 49,
	[276][21] = 49,
	[276][22] = 49,
	[276][23] = 49,
	[276][24] = 49,
	[276][25] = 49,
	[276][26] = 49,
	[276][27] = 49,
	[276][28] = 49,
	[276][29] = 49,
	[277][11] = 50,
	[277][13] = 50,
	[277][14] = 50,
	[277][15] = 50,
	[277][21] = 50,
	[277][22] = 50,
	[277][23] = 50,
	[277][24] = 50,
	[277][25] = 50,
	[277][26] = 50,
	[277][27] = 50,
	[277][28] = 50,
	[277][29] = 50,
	[278][11] = 51,
	[278][13] = 51,
	[278][14] = 51,
	[278][15] = 51,
	[278][19] = 51,
	[278][20] = 51,
	[278][21] = 51,
	[278][22] = 51,
	[278][23] = 51,
	[278][24] = 51,
	[278][25] = 51,
	[278][26] = 51,
	[278][27] = 51,
	[278][28] = 51,
	[278][29] = 51,
	[279][11] = 52,
	[279][13] = 52,
	[279][14] = 52,
	[279][15] = 52,
	[279][19] = 52,
	[279][20] = 52,
	[279][21] = 52,
	[279][22] = 52,
	[279][23] = 52,
	[279][24] = 52,
	[279][25] = 52,
	[279][26] = 52,
	[279][27] = 52,
	[279][28] = 52,
	[279][29] = 52,
	[280][11] = 53,
	[280][13] = 53,
	[280][14] = 53,
	[280][15] = 53,
	[280][19] = 53,
	[280][20] = 53,
	[280][21] = 53,
	[280][22] = 53,
	[280][23] = 53,
	[280][24] = 53,
	[280][25] = 53,
	[280][26] = 53,
	[280][27] = 53,
	[280][28] = 53,
	[280][29] = 53,
	[281][32] = 67,
	[285][32] = 68,
	[287][14] = 59,
	[287][15] = 59,
	[287][32] = 59,
	[288][14] = 60,
	[288][15] = 60,
	[288][32] = 60,
	[289][32] = 69,
	[291][8] = 56,
	[291][9] = 56,
	[291][11] = 56,
	[291][13] = 56,
	[291][14] = 56,
	[291][15] = 56,
	[291][16] = 56,
	[291][17] = 56,
	[291][18] = 56,
	[291][19] = 56,
	[291][20] = 56,
	[291][21] = 56,
	[291][22] = 56,
	[291][23] = 56,
	[291][24] = 56,
	[291][25] = 56,
	[291][26] = 56,
	[291][27] = 56,
	[291][28] = 56,
	[291][29] = 56,
	[292][8] = 57,
	[292][9] = 57,
	[292][11] = 57,
	[292][13] = 57,
	[292][14] = 57,
	[292][15] = 57,
	[292][16] = 57,
	[292][17] = 57,
	[292][18] = 57,
	[292][19] = 57,
	[292][20] = 57,
	[292][21] = 57,
	[292][22] = 57,
	[292][23] = 57,
	[292][24] = 57,
	[292][25] = 57,
	[292][26] = 57,
	[292][27] = 57,
	[292][28] = 57,
	[292][29] = 57,
	[293][8] = 58,
	[293][9] = 58,
	[293][11] = 58,
	[293][13] = 58,
	[293][14] = 58,
	[293][15] = 58,
	[293][16] = 58,
	[293][17] = 58,
	[293][18] = 58,
	[293][19] = 58,
	[293][20] = 58,
	[293][21] = 58,
	[293][22] = 58,
	[293][23] = 58,
	[293][24] = 58,
	[293][25] = 58,
	[293][26] = 58,
	[293][27] = 58,
	[293][28] = 58,
	[293][29] = 58,
	[295][14] = 28,
	[295][15] = 28,
	[295][32] = 28,
	[296][32] = 70,
	[297][32] = 71,
	[298][2] = 28,
	[298][3] = 28,
	[298][4] = 28,
	[298][14] = 28,
	[298][15] = 28,
	[298][32] = 28,
	[299][14] = 61,
	[299][15] = 61,
	[299][32] = 61,
	[300][32] = 28,
	[301][11] = 67,
};


const unsigned zebu_gotos[295][32] = {
	[1][1] = 11,
	[1][2] = 12,
	[1][3] = 13,
	[1][4] = 14,
	[1][5] = 15,
	[1][6] = 16,
	[1][7] = 17,
	[1][8] = 18,
	[1][9] = 19,
	[1][10] = 20,
	[1][11] = 21,
	[1][12] = 22,
	[1][13] = 23,
	[1][14] = 24,
	[1][15] = 25,
	[1][16] = 26,
	[1][17] = 27,
	[1][18] = 28,
	[3][1] = 39,
	[3][2] = 40,
	[3][4] = 41,
	[3][5] = 42,
	[3][6] = 43,
	[3][7] = 44,
	[3][9] = 45,
	[3][10] = 46,
	[3][11] = 47,
	[3][12] = 48,
	[3][13] = 49,
	[3][14] = 50,
	[3][15] = 51,
	[3][17] = 52,
	[7][13] = 57,
	[7][14] = 24,
	[7][19] = 56,
	[8][13] = 57,
	[8][14] = 24,
	[8][19] = 58,
	[9][13] = 57,
	[9][14] = 24,
	[9][19] = 59,
	[10][13] = 57,
	[10][14] = 24,
	[10][19] = 60,
	[13][1] = 11,
	[13][2] = 12,
	[13][3] = 13,
	[13][4] = 14,
	[13][5] = 15,
	[13][6] = 16,
	[13][7] = 17,
	[13][8] = 18,
	[13][9] = 19,
	[13][10] = 20,
	[13][11] = 21,
	[13][12] = 22,
	[13][13] = 23,
	[13][14] = 24,
	[13][15] = 25,
	[13][17] = 27,
	[13][18] = 64,
	[18][1] = 11,
	[18][2] = 12,
	[18][3] = 13,
	[18][4] = 14,
	[18][5] = 15,
	[18][6] = 16,
	[18][7] = 17,
	[18][8] = 18,
	[18][9] = 19,
	[18][10] = 20,
	[18][11] = 21,
	[18][12] = 22,
	[18][13] = 23,
	[18][14] = 24,
	[18][15] = 25,
	[18][17] = 27,
	[18][18] = 69,
	[29][1] = 11,
	[29][2] = 12,
	[29][4] = 14,
	[29][5] = 15,
	[29][6] = 16,
	[29][7] = 84,
	[29][9] = 19,
	[29][10] = 20,
	[29][11] = 21,
	[29][12] = 22,
	[29][13] = 23,
	[29][14] = 24,
	[29][15] = 25,
	[29][17] = 27,
	[31][1] = 39,
	[31][2] = 40,
	[31][4] = 41,
	[31][5] = 42,
	[31][6] = 43,
	[31][7] = 85,
	[31][9] = 45,
	[31][10] = 46,
	[31][11] = 47,
	[31][12] = 48,
	[31][13] = 49,
	[31][14] = 50,
	[31][15] = 51,
	[31][17] = 52,
	[35][13] = 89,
	[35][14] = 50,
	[35][19] = 88,
	[36][13] = 89,
	[36][14] = 50,
	[36][19] = 90,
	[37][13] = 89,
	[37][14] = 50,
	[37][19] = 91,
	[38][13] = 89,
	[38][14] = 50,
	[38][19] = 92,
	[53][1] = 39,
	[53][2] = 40,
	[53][4] = 41,
	[53][5] = 42,
	[53][6] = 43,
	[53][7] = 113,
	[53][9] = 45,
	[53][10] = 46,
	[53][11] = 47,
	[53][12] = 48,
	[53][13] = 49,
	[53][14] = 50,
	[53][15] = 51,
	[53][17] = 52,
	[54][14] = 118,
	[54][20] = 117,
	[54][21] = 119,
	[61][12] = 121,
	[61][13] = 23,
	[61][14] = 24,
	[61][22] = 120,
	[62][12] = 121,
	[62][13] = 23,
	[62][14] = 24,
	[62][22] = 122,
	[63][1] = 11,
	[63][5] = 123,
	[63][12] = 22,
	[63][13] = 23,
	[63][14] = 24,
	[63][15] = 25,
	[63][17] = 27,
	[65][1] = 11,
	[65][12] = 22,
	[65][13] = 23,
	[65][14] = 24,
	[65][15] = 125,
	[65][17] = 27,
	[65][23] = 124,
	[66][1] = 11,
	[66][12] = 22,
	[66][13] = 23,
	[66][14] = 24,
	[66][15] = 125,
	[66][17] = 27,
	[66][23] = 126,
	[67][1] = 11,
	[67][2] = 127,
	[67][5] = 15,
	[67][12] = 22,
	[67][13] = 23,
	[67][14] = 24,
	[67][15] = 25,
	[67][17] = 27,
	[70][1] = 11,
	[70][2] = 12,
	[70][5] = 15,
	[70][6] = 128,
	[70][12] = 22,
	[70][13] = 23,
	[70][14] = 24,
	[70][15] = 25,
	[70][17] = 27,
	[71][1] = 11,
	[71][2] = 12,
	[71][5] = 15,
	[71][6] = 16,
	[71][9] = 129,
	[71][12] = 22,
	[71][13] = 23,
	[71][14] = 24,
	[71][15] = 25,
	[71][17] = 27,
	[72][1] = 11,
	[72][2] = 12,
	[72][5] = 15,
	[72][6] = 16,
	[72][9] = 19,
	[72][10] = 130,
	[72][12] = 22,
	[72][13] = 23,
	[72][14] = 24,
	[72][15] = 25,
	[72][17] = 27,
	[73][1] = 140,
	[73][2] = 141,
	[73][4] = 142,
	[73][5] = 143,
	[73][6] = 144,
	[73][7] = 145,
	[73][9] = 146,
	[73][10] = 147,
	[73][11] = 148,
	[73][12] = 149,
	[73][13] = 150,
	[73][14] = 151,
	[73][15] = 152,
	[73][17] = 153,
	[74][13] = 155,
	[74][14] = 24,
	[74][24] = 154,
	[75][13] = 155,
	[75][14] = 24,
	[75][24] = 156,
	[76][13] = 155,
	[76][14] = 24,
	[76][24] = 157,
	[77][1] = 11,
	[77][12] = 22,
	[77][13] = 23,
	[77][14] = 24,
	[77][17] = 159,
	[77][25] = 158,
	[78][1] = 11,
	[78][12] = 22,
	[78][13] = 23,
	[78][14] = 24,
	[78][17] = 159,
	[78][25] = 160,
	[79][1] = 11,
	[79][12] = 22,
	[79][13] = 23,
	[79][14] = 24,
	[79][17] = 159,
	[79][25] = 161,
	[80][1] = 11,
	[80][12] = 22,
	[80][13] = 23,
	[80][14] = 24,
	[80][17] = 159,
	[80][25] = 162,
	[81][1] = 164,
	[81][12] = 22,
	[81][13] = 23,
	[81][14] = 24,
	[81][26] = 163,
	[82][1] = 164,
	[82][12] = 22,
	[82][13] = 23,
	[82][14] = 24,
	[82][26] = 165,
	[83][1] = 11,
	[83][2] = 12,
	[83][3] = 13,
	[83][4] = 14,
	[83][5] = 15,
	[83][6] = 16,
	[83][7] = 17,
	[83][8] = 18,
	[83][9] = 19,
	[83][10] = 20,
	[83][11] = 21,
	[83][12] = 22,
	[83][13] = 23,
	[83][14] = 24,
	[83][15] = 25,
	[83][16] = 166,
	[83][17] = 27,
	[83][18] = 28,
	[86][1] = 39,
	[86][2] = 40,
	[86][4] = 41,
	[86][5] = 42,
	[86][6] = 43,
	[86][7] = 169,
	[86][9] = 45,
	[86][10] = 46,
	[86][11] = 47,
	[86][12] = 48,
	[86][13] = 49,
	[86][14] = 50,
	[86][15] = 51,
	[86][17] = 52,
	[87][14] = 118,
	[87][20] = 170,
	[87][21] = 119,
	[93][12] = 172,
	[93][13] = 49,
	[93][14] = 50,
	[93][22] = 171,
	[94][12] = 172,
	[94][13] = 49,
	[94][14] = 50,
	[94][22] = 173,
	[95][1] = 39,
	[95][5] = 174,
	[95][12] = 48,
	[95][13] = 49,
	[95][14] = 50,
	[95][15] = 51,
	[95][17] = 52,
	[96][1] = 39,
	[96][12] = 48,
	[96][13] = 49,
	[96][14] = 50,
	[96][15] = 176,
	[96][17] = 52,
	[96][23] = 175,
	[97][1] = 39,
	[97][12] = 48,
	[97][13] = 49,
	[97][14] = 50,
	[97][15] = 176,
	[97][17] = 52,
	[97][23] = 177,
	[98][1] = 39,
	[98][2] = 178,
	[98][5] = 42,
	[98][12] = 48,
	[98][13] = 49,
	[98][14] = 50,
	[98][15] = 51,
	[98][17] = 52,
	[100][1] = 39,
	[100][2] = 40,
	[100][5] = 42,
	[100][6] = 179,
	[100][12] = 48,
	[100][13] = 49,
	[100][14] = 50,
	[100][15] = 51,
	[100][17] = 52,
	[101][1] = 39,
	[101][2] = 40,
	[101][5] = 42,
	[101][6] = 43,
	[101][9] = 180,
	[101][12] = 48,
	[101][13] = 49,
	[101][14] = 50,
	[101][15] = 51,
	[101][17] = 52,
	[102][1] = 39,
	[102][2] = 40,
	[102][5] = 42,
	[102][6] = 43,
	[102][9] = 45,
	[102][10] = 181,
	[102][12] = 48,
	[102][13] = 49,
	[102][14] = 50,
	[102][15] = 51,
	[102][17] = 52,
	[103][1] = 140,
	[103][2] = 141,
	[103][4] = 142,
	[103][5] = 143,
	[103][6] = 144,
	[103][7] = 182,
	[103][9] = 146,
	[103][10] = 147,
	[103][11] = 148,
	[103][12] = 149,
	[103][13] = 150,
	[103][14] = 151,
	[103][15] = 152,
	[103][17] = 153,
	[104][13] = 184,
	[104][14] = 50,
	[104][24] = 183,
	[105][13] = 184,
	[105][14] = 50,
	[105][24] = 185,
	[106][13] = 184,
	[106][14] = 50,
	[106][24] = 186,
	[107][1] = 39,
	[107][12] = 48,
	[107][13] = 49,
	[107][14] = 50,
	[107][17] = 188,
	[107][25] = 187,
	[108][1] = 39,
	[108][12] = 48,
	[108][13] = 49,
	[108][14] = 50,
	[108][17] = 188,
	[108][25] = 189,
	[109][1] = 39,
	[109][12] = 48,
	[109][13] = 49,
	[109][14] = 50,
	[109][17] = 188,
	[109][25] = 190,
	[110][1] = 39,
	[110][12] = 48,
	[110][13] = 49,
	[110][14] = 50,
	[110][17] = 188,
	[110][25] = 191,
	[111][1] = 193,
	[111][12] = 48,
	[111][13] = 49,
	[111][14] = 50,
	[111][26] = 192,
	[112][1] = 193,
	[112][12] = 48,
	[112][13] = 49,
	[112][14] = 50,
	[112][26] = 194,
	[113][27] = 196,
	[115][1] = 39,
	[115][2] = 40,
	[115][4] = 41,
	[115][5] = 42,
	[115][6] = 43,
	[115][7] = 197,
	[115][9] = 45,
	[115][10] = 46,
	[115][11] = 47,
	[115][12] = 48,
	[115][13] = 49,
	[115][14] = 50,
	[115][15] = 51,
	[115][17] = 52,
	[117][27] = 198,
	[118][14] = 200,
	[118][28] = 199,
	[132][1] = 39,
	[132][2] = 40,
	[132][4] = 41,
	[132][5] = 42,
	[132][6] = 43,
	[132][7] = 204,
	[132][9] = 45,
	[132][10] = 46,
	[132][11] = 47,
	[132][12] = 48,
	[132][13] = 49,
	[132][14] = 50,
	[132][15] = 51,
	[132][17] = 52,
	[136][13] = 208,
	[136][14] = 151,
	[136][19] = 207,
	[137][13] = 208,
	[137][14] = 151,
	[137][19] = 209,
	[138][13] = 208,
	[138][14] = 151,
	[138][19] = 210,
	[139][13] = 208,
	[139][14] = 151,
	[139][19] = 211,
	[169][27] = 233,
	[170][27] = 234,
	[200][14] = 200,
	[200][28] = 237,
	[201][14] = 241,
	[202][14] = 246,
	[202][21] = 247,
	[202][29] = 245,
	[203][14] = 252,
	[203][30] = 251,
	[205][1] = 39,
	[205][2] = 40,
	[205][4] = 41,
	[205][5] = 42,
	[205][6] = 43,
	[205][7] = 254,
	[205][9] = 45,
	[205][10] = 46,
	[205][11] = 47,
	[205][12] = 48,
	[205][13] = 49,
	[205][14] = 50,
	[205][15] = 51,
	[205][17] = 52,
	[206][14] = 118,
	[206][20] = 255,
	[206][21] = 119,
	[212][12] = 257,
	[212][13] = 150,
	[212][14] = 151,
	[212][22] = 256,
	[213][12] = 257,
	[213][13] = 150,
	[213][14] = 151,
	[213][22] = 258,
	[214][1] = 140,
	[214][5] = 259,
	[214][12] = 149,
	[214][13] = 150,
	[214][14] = 151,
	[214][15] = 152,
	[214][17] = 153,
	[215][1] = 140,
	[215][12] = 149,
	[215][13] = 150,
	[215][14] = 151,
	[215][15] = 261,
	[215][17] = 153,
	[215][23] = 260,
	[216][1] = 140,
	[216][12] = 149,
	[216][13] = 150,
	[216][14] = 151,
	[216][15] = 261,
	[216][17] = 153,
	[216][23] = 262,
	[217][1] = 140,
	[217][2] = 263,
	[217][5] = 143,
	[217][12] = 149,
	[217][13] = 150,
	[217][14] = 151,
	[217][15] = 152,
	[217][17] = 153,
	[218][1] = 11,
	[218][2] = 12,
	[218][4] = 264,
	[218][5] = 15,
	[218][6] = 16,
	[218][9] = 19,
	[218][10] = 20,
	[218][11] = 21,
	[218][12] = 22,
	[218][13] = 23,
	[218][14] = 24,
	[218][15] = 25,
	[218][17] = 27,
	[219][1] = 140,
	[219][2] = 141,
	[219][5] = 143,
	[219][6] = 265,
	[219][12] = 149,
	[219][13] = 150,
	[219][14] = 151,
	[219][15] = 152,
	[219][17] = 153,
	[220][1] = 140,
	[220][2] = 141,
	[220][5] = 143,
	[220][6] = 144,
	[220][9] = 266,
	[220][12] = 149,
	[220][13] = 150,
	[220][14] = 151,
	[220][15] = 152,
	[220][17] = 153,
	[221][1] = 140,
	[221][2] = 141,
	[221][5] = 143,
	[221][6] = 144,
	[221][9] = 146,
	[221][10] = 267,
	[221][12] = 149,
	[221][13] = 150,
	[221][14] = 151,
	[221][15] = 152,
	[221][17] = 153,
	[222][1] = 140,
	[222][2] = 141,
	[222][4] = 142,
	[222][5] = 143,
	[222][6] = 144,
	[222][7] = 268,
	[222][9] = 146,
	[222][10] = 147,
	[222][11] = 148,
	[222][12] = 149,
	[222][13] = 150,
	[222][14] = 151,
	[222][15] = 152,
	[222][17] = 153,
	[223][13] = 270,
	[223][14] = 151,
	[223][24] = 269,
	[224][13] = 270,
	[224][14] = 151,
	[224][24] = 271,
	[225][13] = 270,
	[225][14] = 151,
	[225][24] = 272,
	[226][1] = 140,
	[226][12] = 149,
	[226][13] = 150,
	[226][14] = 151,
	[226][17] = 274,
	[226][25] = 273,
	[227][1] = 140,
	[227][12] = 149,
	[227][13] = 150,
	[227][14] = 151,
	[227][17] = 274,
	[227][25] = 275,
	[228][1] = 140,
	[228][12] = 149,
	[228][13] = 150,
	[228][14] = 151,
	[228][17] = 274,
	[228][25] = 276,
	[229][1] = 140,
	[229][12] = 149,
	[229][13] = 150,
	[229][14] = 151,
	[229][17] = 274,
	[229][25] = 277,
	[230][1] = 279,
	[230][12] = 149,
	[230][13] = 150,
	[230][14] = 151,
	[230][26] = 278,
	[231][1] = 279,
	[231][12] = 149,
	[231][13] = 150,
	[231][14] = 151,
	[231][26] = 280,
	[235][1] = 39,
	[235][2] = 40,
	[235][4] = 281,
	[235][5] = 42,
	[235][6] = 43,
	[235][9] = 45,
	[235][10] = 46,
	[235][11] = 47,
	[235][12] = 48,
	[235][13] = 49,
	[235][14] = 50,
	[235][15] = 51,
	[235][17] = 52,
	[239][1] = 39,
	[239][2] = 40,
	[239][4] = 41,
	[239][5] = 42,
	[239][6] = 43,
	[239][7] = 282,
	[239][9] = 45,
	[239][10] = 46,
	[239][11] = 47,
	[239][12] = 48,
	[239][13] = 49,
	[239][14] = 50,
	[239][15] = 51,
	[239][17] = 52,
	[241][31] = 285,
	[243][1] = 39,
	[243][2] = 40,
	[243][4] = 41,
	[243][5] = 42,
	[243][6] = 43,
	[243][7] = 286,
	[243][9] = 45,
	[243][10] = 46,
	[243][11] = 47,
	[243][12] = 48,
	[243][13] = 49,
	[243][14] = 50,
	[243][15] = 51,
	[243][17] = 52,
	[246][14] = 288,
	[246][28] = 287,
	[247][31] = 289,
	[249][1] = 39,
	[249][2] = 40,
	[249][4] = 41,
	[249][5] = 42,
	[249][6] = 43,
	[249][7] = 290,
	[249][9] = 45,
	[249][10] = 46,
	[249][11] = 47,
	[249][12] = 48,
	[249][13] = 49,
	[249][14] = 50,
	[249][15] = 51,
	[249][17] = 52,
	[254][27] = 292,
	[255][27] = 293,
	[283][14] = 246,
	[283][21] = 247,
	[283][29] = 296,
	[284][14] = 252,
	[284][30] = 297,
	[288][14] = 288,
	[288][28] = 299,
	[294][1] = 140,
	[294][2] = 141,
	[294][4] = 301,
	[294][5] = 143,
	[294][6] = 144,
	[294][9] = 146,
	[294][10] = 147,
	[294][11] = 148,
	[294][12] = 149,
	[294][13] = 150,
	[294][14] = 151,
	[294][15] = 152,
	[294][17] = 153,
};


const unsigned zebu_lexer[99][256] = {
	[1][9] = 45,
	[1][10] = 45,
	[1][32] = 45,
	[1][33] = 46,
	[1][34] = 47,
	[1][40] = 48,
	[1][43] = 49,
	[1][45] = 50,
	[1][47] = 51,
	[1][48] = 52,
	[1][49] = 52,
	[1][50] = 52,
	[1][51] = 52,
	[1][52] = 52,
	[1][53] = 52,
	[1][54] = 52,
	[1][55] = 52,
	[1][56] = 52,
	[1][57] = 52,
	[1][102] = 53,
	[1][115] = 54,
	[1][126] = 55,
	[2][9] = 45,
	[2][10] = 45,
	[2][32] = 45,
	[2][33] = 56,
	[2][37] = 57,
	[2][38] = 58,
	[2][42] = 59,
	[2][43] = 49,
	[2][45] = 50,
	[2][47] = 60,
	[2][58] = 61,
	[2][59] = 62,
	[2][60] = 63,
	[2][61] = 64,
	[2][62] = 65,
	[2][63] = 66,
	[2][94] = 67,
	[2][124] = 68,
	[3][9] = 45,
	[3][10] = 45,
	[3][32] = 45,
	[3][33] = 56,
	[3][37] = 57,
	[3][38] = 58,
	[3][42] = 59,
	[3][43] = 49,
	[3][45] = 50,
	[3][47] = 60,
	[3][59] = 62,
	[3][60] = 63,
	[3][61] = 64,
	[3][62] = 65,
	[3][63] = 66,
	[3][94] = 67,
	[3][124] = 68,
	[4][9] = 45,
	[4][10] = 45,
	[4][32] = 45,
	[4][40] = 48,
	[4][47] = 51,
	[5][9] = 45,
	[5][10] = 45,
	[5][32] = 45,
	[5][33] = 56,
	[5][38] = 58,
	[5][43] = 49,
	[5][45] = 50,
	[5][47] = 51,
	[5][59] = 62,
	[5][60] = 63,
	[5][61] = 64,
	[5][62] = 65,
	[5][63] = 66,
	[5][94] = 67,
	[5][124] = 68,
	[6][9] = 45,
	[6][10] = 45,
	[6][32] = 45,
	[6][38] = 58,
	[6][47] = 51,
	[6][59] = 62,
	[6][63] = 66,
	[6][94] = 67,
	[6][124] = 68,
	[7][9] = 45,
	[7][10] = 45,
	[7][32] = 45,
	[7][33] = 46,
	[7][34] = 47,
	[7][40] = 48,
	[7][43] = 49,
	[7][45] = 69,
	[7][47] = 51,
	[7][48] = 52,
	[7][49] = 52,
	[7][50] = 52,
	[7][51] = 52,
	[7][52] = 52,
	[7][53] = 52,
	[7][54] = 52,
	[7][55] = 52,
	[7][56] = 52,
	[7][57] = 52,
	[7][102] = 53,
	[7][115] = 54,
	[7][126] = 55,
	[8][9] = 45,
	[8][10] = 45,
	[8][32] = 45,
	[8][47] = 51,
	[8][59] = 62,
	[9][9] = 45,
	[9][10] = 45,
	[9][32] = 45,
	[9][33] = 56,
	[9][38] = 58,
	[9][47] = 51,
	[9][59] = 62,
	[9][61] = 64,
	[9][63] = 66,
	[9][94] = 67,
	[9][124] = 68,
	[10][9] = 45,
	[10][10] = 45,
	[10][32] = 45,
	[10][38] = 71,
	[10][47] = 51,
	[10][59] = 62,
	[10][63] = 66,
	[10][94] = 67,
	[10][124] = 68,
	[11][9] = 45,
	[11][10] = 45,
	[11][32] = 45,
	[11][38] = 71,
	[11][47] = 51,
	[11][59] = 62,
	[11][63] = 66,
	[11][124] = 68,
	[12][9] = 45,
	[12][10] = 45,
	[12][32] = 45,
	[12][38] = 71,
	[12][47] = 51,
	[12][59] = 62,
	[12][63] = 66,
	[12][124] = 72,
	[13][9] = 45,
	[13][10] = 45,
	[13][32] = 45,
	[13][47] = 51,
	[13][59] = 62,
	[13][63] = 66,
	[13][124] = 72,
	[14][9] = 45,
	[14][10] = 45,
	[14][32] = 45,
	[14][33] = 56,
	[14][38] = 58,
	[14][47] = 51,
	[14][59] = 62,
	[14][60] = 73,
	[14][61] = 64,
	[14][62] = 74,
	[14][63] = 66,
	[14][94] = 67,
	[14][124] = 68,
	[15][9] = 45,
	[15][10] = 45,
	[15][32] = 45,
	[15][47] = 51,
	[16][9] = 45,
	[16][10] = 45,
	[16][32] = 45,
	[16][33] = 56,
	[16][38] = 58,
	[16][47] = 51,
	[16][59] = 62,
	[16][60] = 63,
	[16][61] = 64,
	[16][62] = 65,
	[16][63] = 66,
	[16][94] = 67,
	[16][124] = 68,
	[17][9] = 45,
	[17][10] = 45,
	[17][32] = 45,
	[17][45] = 75,
	[17][47] = 51,
	[18][9] = 45,
	[18][10] = 45,
	[18][32] = 45,
	[18][33] = 56,
	[18][37] = 57,
	[18][38] = 58,
	[18][41] = 76,
	[18][42] = 59,
	[18][43] = 49,
	[18][45] = 50,
	[18][47] = 60,
	[18][60] = 63,
	[18][61] = 64,
	[18][62] = 65,
	[18][63] = 66,
	[18][94] = 67,
	[18][124] = 68,
	[19][9] = 45,
	[19][10] = 45,
	[19][32] = 45,
	[19][33] = 56,
	[19][38] = 58,
	[19][41] = 76,
	[19][43] = 49,
	[19][45] = 50,
	[19][47] = 51,
	[19][60] = 63,
	[19][61] = 64,
	[19][62] = 65,
	[19][63] = 66,
	[19][94] = 67,
	[19][124] = 68,
	[20][9] = 45,
	[20][10] = 45,
	[20][32] = 45,
	[20][38] = 58,
	[20][41] = 76,
	[20][47] = 51,
	[20][63] = 66,
	[20][94] = 67,
	[20][124] = 68,
	[21][9] = 45,
	[21][10] = 45,
	[21][32] = 45,
	[21][41] = 76,
	[21][47] = 51,
	[22][9] = 45,
	[22][10] = 45,
	[22][32] = 45,
	[22][33] = 56,
	[22][38] = 58,
	[22][41] = 76,
	[22][47] = 51,
	[22][61] = 64,
	[22][63] = 66,
	[22][94] = 67,
	[22][124] = 68,
	[23][9] = 45,
	[23][10] = 45,
	[23][32] = 45,
	[23][38] = 71,
	[23][41] = 76,
	[23][47] = 51,
	[23][63] = 66,
	[23][94] = 67,
	[23][124] = 68,
	[24][9] = 45,
	[24][10] = 45,
	[24][32] = 45,
	[24][38] = 71,
	[24][41] = 76,
	[24][47] = 51,
	[24][63] = 66,
	[24][124] = 68,
	[25][9] = 45,
	[25][10] = 45,
	[25][32] = 45,
	[25][38] = 71,
	[25][41] = 76,
	[25][47] = 51,
	[25][63] = 66,
	[25][124] = 72,
	[26][9] = 45,
	[26][10] = 45,
	[26][32] = 45,
	[26][41] = 76,
	[26][47] = 51,
	[26][63] = 66,
	[26][124] = 72,
	[27][9] = 45,
	[27][10] = 45,
	[27][32] = 45,
	[27][33] = 56,
	[27][38] = 58,
	[27][41] = 76,
	[27][47] = 51,
	[27][60] = 73,
	[27][61] = 64,
	[27][62] = 74,
	[27][63] = 66,
	[27][94] = 67,
	[27][124] = 68,
	[28][9] = 45,
	[28][10] = 45,
	[28][32] = 45,
	[28][33] = 56,
	[28][38] = 58,
	[28][41] = 76,
	[28][47] = 51,
	[28][60] = 63,
	[28][61] = 64,
	[28][62] = 65,
	[28][63] = 66,
	[28][94] = 67,
	[28][124] = 68,
	[29][9] = 45,
	[29][10] = 45,
	[29][32] = 45,
	[29][34] = 47,
	[29][40] = 48,
	[29][47] = 51,
	[29][48] = 52,
	[29][49] = 52,
	[29][50] = 52,
	[29][51] = 52,
	[29][52] = 52,
	[29][53] = 52,
	[29][54] = 52,
	[29][55] = 52,
	[29][56] = 52,
	[29][57] = 52,
	[30][9] = 45,
	[30][10] = 45,
	[30][32] = 45,
	[30][34] = 47,
	[30][40] = 48,
	[30][41] = 76,
	[30][47] = 51,
	[30][48] = 52,
	[30][49] = 52,
	[30][50] = 52,
	[30][51] = 52,
	[30][52] = 52,
	[30][53] = 52,
	[30][54] = 52,
	[30][55] = 52,
	[30][56] = 52,
	[30][57] = 52,
	[30][60] = 77,
	[30][62] = 78,
	[30][124] = 79,
	[31][9] = 45,
	[31][10] = 45,
	[31][32] = 45,
	[31][41] = 76,
	[31][47] = 51,
	[31][60] = 77,
	[31][62] = 78,
	[31][124] = 79,
	[32][9] = 45,
	[32][10] = 45,
	[32][32] = 45,
	[32][33] = 56,
	[32][37] = 57,
	[32][38] = 58,
	[32][42] = 59,
	[32][43] = 49,
	[32][45] = 50,
	[32][47] = 60,
	[32][58] = 61,
	[32][60] = 63,
	[32][61] = 64,
	[32][62] = 65,
	[32][63] = 66,
	[32][94] = 67,
	[32][124] = 68,
	[33][9] = 45,
	[33][10] = 45,
	[33][32] = 45,
	[33][33] = 56,
	[33][38] = 58,
	[33][43] = 49,
	[33][45] = 50,
	[33][47] = 51,
	[33][58] = 61,
	[33][60] = 63,
	[33][61] = 64,
	[33][62] = 65,
	[33][63] = 66,
	[33][94] = 67,
	[33][124] = 68,
	[34][9] = 45,
	[34][10] = 45,
	[34][32] = 45,
	[34][38] = 58,
	[34][47] = 51,
	[34][58] = 61,
	[34][63] = 66,
	[34][94] = 67,
	[34][124] = 68,
	[35][9] = 45,
	[35][10] = 45,
	[35][32] = 45,
	[35][47] = 51,
	[35][58] = 61,
	[36][9] = 45,
	[36][10] = 45,
	[36][32] = 45,
	[36][33] = 56,
	[36][38] = 58,
	[36][47] = 51,
	[36][58] = 61,
	[36][61] = 64,
	[36][63] = 66,
	[36][94] = 67,
	[36][124] = 68,
	[37][9] = 45,
	[37][10] = 45,
	[37][32] = 45,
	[37][38] = 71,
	[37][47] = 51,
	[37][58] = 61,
	[37][63] = 66,
	[37][94] = 67,
	[37][124] = 68,
	[38][9] = 45,
	[38][10] = 45,
	[38][32] = 45,
	[38][38] = 71,
	[38][47] = 51,
	[38][58] = 61,
	[38][63] = 66,
	[38][124] = 68,
	[39][9] = 45,
	[39][10] = 45,
	[39][32] = 45,
	[39][38] = 71,
	[39][47] = 51,
	[39][58] = 61,
	[39][63] = 66,
	[39][124] = 72,
	[40][9] = 45,
	[40][10] = 45,
	[40][32] = 45,
	[40][47] = 51,
	[40][58] = 61,
	[40][63] = 66,
	[40][124] = 72,
	[41][9] = 45,
	[41][10] = 45,
	[41][32] = 45,
	[41][33] = 56,
	[41][38] = 58,
	[41][47] = 51,
	[41][58] = 61,
	[41][60] = 73,
	[41][61] = 64,
	[41][62] = 74,
	[41][63] = 66,
	[41][94] = 67,
	[41][124] = 68,
	[42][9] = 45,
	[42][10] = 45,
	[42][32] = 45,
	[42][33] = 56,
	[42][38] = 58,
	[42][47] = 51,
	[42][58] = 61,
	[42][60] = 63,
	[42][61] = 64,
	[42][62] = 65,
	[42][63] = 66,
	[42][94] = 67,
	[42][124] = 68,
	[43][9] = 45,
	[43][10] = 45,
	[43][32] = 45,
	[43][41] = 76,
	[43][47] = 51,
	[43][62] = 78,
	[43][124] = 79,
	[44][9] = 45,
	[44][10] = 45,
	[44][32] = 45,
	[44][34] = 47,
	[44][40] = 48,
	[44][41] = 76,
	[44][47] = 51,
	[44][48] = 52,
	[44][49] = 52,
	[44][50] = 52,
	[44][51] = 52,
	[44][52] = 52,
	[44][53] = 52,
	[44][54] = 52,
	[44][55] = 52,
	[44][56] = 52,
	[44][57] = 52,
	[44][62] = 78,
	[44][124] = 79,
	[45][9] = 45,
	[45][10] = 45,
	[45][32] = 45,
	[45][47] = 51,
	[47][0] = 47,
	[47][1] = 47,
	[47][2] = 47,
	[47][3] = 47,
	[47][4] = 47,
	[47][5] = 47,
	[47][6] = 47,
	[47][7] = 47,
	[47][8] = 47,
	[47][9] = 47,
	[47][10] = 47,
	[47][11] = 47,
	[47][12] = 47,
	[47][13] = 47,
	[47][14] = 47,
	[47][15] = 47,
	[47][16] = 47,
	[47][17] = 47,
	[47][18] = 47,
	[47][19] = 47,
	[47][20] = 47,
	[47][21] = 47,
	[47][22] = 47,
	[47][23] = 47,
	[47][24] = 47,
	[47][25] = 47,
	[47][26] = 47,
	[47][27] = 47,
	[47][28] = 47,
	[47][29] = 47,
	[47][30] = 47,
	[47][31] = 47,
	[47][32] = 47,
	[47][33] = 47,
	[47][34] = 80,
	[47][35] = 47,
	[47][36] = 47,
	[47][37] = 47,
	[47][38] = 47,
	[47][39] = 47,
	[47][40] = 47,
	[47][41] = 47,
	[47][42] = 47,
	[47][43] = 47,
	[47][44] = 47,
	[47][45] = 47,
	[47][46] = 47,
	[47][47] = 47,
	[47][48] = 47,
	[47][49] = 47,
	[47][50] = 47,
	[47][51] = 47,
	[47][52] = 47,
	[47][53] = 47,
	[47][54] = 47,
	[47][55] = 47,
	[47][56] = 47,
	[47][57] = 47,
	[47][58] = 47,
	[47][59] = 47,
	[47][60] = 47,
	[47][61] = 47,
	[47][62] = 47,
	[47][63] = 47,
	[47][64] = 47,
	[47][65] = 47,
	[47][66] = 47,
	[47][67] = 47,
	[47][68] = 47,
	[47][69] = 47,
	[47][70] = 47,
	[47][71] = 47,
	[47][72] = 47,
	[47][73] = 47,
	[47][74] = 47,
	[47][75] = 47,
	[47][76] = 47,
	[47][77] = 47,
	[47][78] = 47,
	[47][79] = 47,
	[47][80] = 47,
	[47][81] = 47,
	[47][82] = 47,
	[47][83] = 47,
	[47][84] = 47,
	[47][85] = 47,
	[47][86] = 47,
	[47][87] = 47,
	[47][88] = 47,
	[47][89] = 47,
	[47][90] = 47,
	[47][91] = 47,
	[47][92] = 81,
	[47][93] = 47,
	[47][94] = 47,
	[47][95] = 47,
	[47][96] = 47,
	[47][97] = 47,
	[47][98] = 47,
	[47][99] = 47,
	[47][100] = 47,
	[47][101] = 47,
	[47][102] = 47,
	[47][103] = 47,
	[47][104] = 47,
	[47][105] = 47,
	[47][106] = 47,
	[47][107] = 47,
	[47][108] = 47,
	[47][109] = 47,
	[47][110] = 47,
	[47][111] = 47,
	[47][112] = 47,
	[47][113] = 47,
	[47][114] = 47,
	[47][115] = 47,
	[47][116] = 47,
	[47][117] = 47,
	[47][118] = 47,
	[47][119] = 47,
	[47][120] = 47,
	[47][121] = 47,
	[47][122] = 47,
	[47][123] = 47,
	[47][124] = 47,
	[47][125] = 47,
	[47][126] = 47,
	[47][127] = 47,
	[47][128] = 47,
	[47][129] = 47,
	[47][130] = 47,
	[47][131] = 47,
	[47][132] = 47,
	[47][133] = 47,
	[47][134] = 47,
	[47][135] = 47,
	[47][136] = 47,
	[47][137] = 47,
	[47][138] = 47,
	[47][139] = 47,
	[47][140] = 47,
	[47][141] = 47,
	[47][142] = 47,
	[47][143] = 47,
	[47][144] = 47,
	[47][145] = 47,
	[47][146] = 47,
	[47][147] = 47,
	[47][148] = 47,
	[47][149] = 47,
	[47][150] = 47,
	[47][151] = 47,
	[47][152] = 47,
	[47][153] = 47,
	[47][154] = 47,
	[47][155] = 47,
	[47][156] = 47,
	[47][157] = 47,
	[47][158] = 47,
	[47][159] = 47,
	[47][160] = 47,
	[47][161] = 47,
	[47][162] = 47,
	[47][163] = 47,
	[47][164] = 47,
	[47][165] = 47,
	[47][166] = 47,
	[47][167] = 47,
	[47][168] = 47,
	[47][169] = 47,
	[47][170] = 47,
	[47][171] = 47,
	[47][172] = 47,
	[47][173] = 47,
	[47][174] = 47,
	[47][175] = 47,
	[47][176] = 47,
	[47][177] = 47,
	[47][178] = 47,
	[47][179] = 47,
	[47][180] = 47,
	[47][181] = 47,
	[47][182] = 47,
	[47][183] = 47,
	[47][184] = 47,
	[47][185] = 47,
	[47][186] = 47,
	[47][187] = 47,
	[47][188] = 47,
	[47][189] = 47,
	[47][190] = 47,
	[47][191] = 47,
	[47][192] = 47,
	[47][193] = 47,
	[47][194] = 47,
	[47][195] = 47,
	[47][196] = 47,
	[47][197] = 47,
	[47][198] = 47,
	[47][199] = 47,
	[47][200] = 47,
	[47][201] = 47,
	[47][202] = 47,
	[47][203] = 47,
	[47][204] = 47,
	[47][205] = 47,
	[47][206] = 47,
	[47][207] = 47,
	[47][208] = 47,
	[47][209] = 47,
	[47][210] = 47,
	[47][211] = 47,
	[47][212] = 47,
	[47][213] = 47,
	[47][214] = 47,
	[47][215] = 47,
	[47][216] = 47,
	[47][217] = 47,
	[47][218] = 47,
	[47][219] = 47,
	[47][220] = 47,
	[47][221] = 47,
	[47][222] = 47,
	[47][223] = 47,
	[47][224] = 47,
	[47][225] = 47,
	[47][226] = 47,
	[47][227] = 47,
	[47][228] = 47,
	[47][229] = 47,
	[47][230] = 47,
	[47][231] = 47,
	[47][232] = 47,
	[47][233] = 47,
	[47][234] = 47,
	[47][235] = 47,
	[47][236] = 47,
	[47][237] = 47,
	[47][238] = 47,
	[47][239] = 47,
	[47][240] = 47,
	[47][241] = 47,
	[47][242] = 47,
	[47][243] = 47,
	[47][244] = 47,
	[47][245] = 47,
	[47][246] = 47,
	[47][247] = 47,
	[47][248] = 47,
	[47][249] = 47,
	[47][250] = 47,
	[47][251] = 47,
	[47][252] = 47,
	[47][253] = 47,
	[47][254] = 47,
	[47][255] = 47,
	[51][47] = 82,
	[52][48] = 52,
	[52][49] = 52,
	[52][50] = 52,
	[52][51] = 52,
	[52][52] = 52,
	[52][53] = 52,
	[52][54] = 52,
	[52][55] = 52,
	[52][56] = 52,
	[52][57] = 52,
	[53][105] = 83,
	[54][104] = 84,
	[56][61] = 85,
	[58][38] = 86,
	[60][47] = 82,
	[63][60] = 87,
	[63][61] = 88,
	[64][61] = 89,
	[65][61] = 90,
	[65][62] = 91,
	[68][124] = 92,
	[69][45] = 93,
	[71][38] = 86,
	[72][124] = 92,
	[73][61] = 88,
	[74][61] = 90,
	[75][45] = 93,
	[81][34] = 47,
	[81][92] = 47,
	[81][110] = 47,
	[81][116] = 47,
	[82][0] = 82,
	[82][1] = 82,
	[82][2] = 82,
	[82][3] = 82,
	[82][4] = 82,
	[82][5] = 82,
	[82][6] = 82,
	[82][7] = 82,
	[82][8] = 82,
	[82][9] = 82,
	[82][10] = 45,
	[82][11] = 82,
	[82][12] = 82,
	[82][13] = 82,
	[82][14] = 82,
	[82][15] = 82,
	[82][16] = 82,
	[82][17] = 82,
	[82][18] = 82,
	[82][19] = 82,
	[82][20] = 82,
	[82][21] = 82,
	[82][22] = 82,
	[82][23] = 82,
	[82][24] = 82,
	[82][25] = 82,
	[82][26] = 82,
	[82][27] = 82,
	[82][28] = 82,
	[82][29] = 82,
	[82][30] = 82,
	[82][31] = 82,
	[82][32] = 82,
	[82][33] = 82,
	[82][34] = 82,
	[82][35] = 82,
	[82][36] = 82,
	[82][37] = 82,
	[82][38] = 82,
	[82][39] = 82,
	[82][40] = 82,
	[82][41] = 82,
	[82][42] = 82,
	[82][43] = 82,
	[82][44] = 82,
	[82][45] = 82,
	[82][46] = 82,
	[82][47] = 82,
	[82][48] = 82,
	[82][49] = 82,
	[82][50] = 82,
	[82][51] = 82,
	[82][52] = 82,
	[82][53] = 82,
	[82][54] = 82,
	[82][55] = 82,
	[82][56] = 82,
	[82][57] = 82,
	[82][58] = 82,
	[82][59] = 82,
	[82][60] = 82,
	[82][61] = 82,
	[82][62] = 82,
	[82][63] = 82,
	[82][64] = 82,
	[82][65] = 82,
	[82][66] = 82,
	[82][67] = 82,
	[82][68] = 82,
	[82][69] = 82,
	[82][70] = 82,
	[82][71] = 82,
	[82][72] = 82,
	[82][73] = 82,
	[82][74] = 82,
	[82][75] = 82,
	[82][76] = 82,
	[82][77] = 82,
	[82][78] = 82,
	[82][79] = 82,
	[82][80] = 82,
	[82][81] = 82,
	[82][82] = 82,
	[82][83] = 82,
	[82][84] = 82,
	[82][85] = 82,
	[82][86] = 82,
	[82][87] = 82,
	[82][88] = 82,
	[82][89] = 82,
	[82][90] = 82,
	[82][91] = 82,
	[82][92] = 82,
	[82][93] = 82,
	[82][94] = 82,
	[82][95] = 82,
	[82][96] = 82,
	[82][97] = 82,
	[82][98] = 82,
	[82][99] = 82,
	[82][100] = 82,
	[82][101] = 82,
	[82][102] = 82,
	[82][103] = 82,
	[82][104] = 82,
	[82][105] = 82,
	[82][106] = 82,
	[82][107] = 82,
	[82][108] = 82,
	[82][109] = 82,
	[82][110] = 82,
	[82][111] = 82,
	[82][112] = 82,
	[82][113] = 82,
	[82][114] = 82,
	[82][115] = 82,
	[82][116] = 82,
	[82][117] = 82,
	[82][118] = 82,
	[82][119] = 82,
	[82][120] = 82,
	[82][121] = 82,
	[82][122] = 82,
	[82][123] = 82,
	[82][124] = 82,
	[82][125] = 82,
	[82][126] = 82,
	[82][127] = 82,
	[82][128] = 82,
	[82][129] = 82,
	[82][130] = 82,
	[82][131] = 82,
	[82][132] = 82,
	[82][133] = 82,
	[82][134] = 82,
	[82][135] = 82,
	[82][136] = 82,
	[82][137] = 82,
	[82][138] = 82,
	[82][139] = 82,
	[82][140] = 82,
	[82][141] = 82,
	[82][142] = 82,
	[82][143] = 82,
	[82][144] = 82,
	[82][145] = 82,
	[82][146] = 82,
	[82][147] = 82,
	[82][148] = 82,
	[82][149] = 82,
	[82][150] = 82,
	[82][151] = 82,
	[82][152] = 82,
	[82][153] = 82,
	[82][154] = 82,
	[82][155] = 82,
	[82][156] = 82,
	[82][157] = 82,
	[82][158] = 82,
	[82][159] = 82,
	[82][160] = 82,
	[82][161] = 82,
	[82][162] = 82,
	[82][163] = 82,
	[82][164] = 82,
	[82][165] = 82,
	[82][166] = 82,
	[82][167] = 82,
	[82][168] = 82,
	[82][169] = 82,
	[82][170] = 82,
	[82][171] = 82,
	[82][172] = 82,
	[82][173] = 82,
	[82][174] = 82,
	[82][175] = 82,
	[82][176] = 82,
	[82][177] = 82,
	[82][178] = 82,
	[82][179] = 82,
	[82][180] = 82,
	[82][181] = 82,
	[82][182] = 82,
	[82][183] = 82,
	[82][184] = 82,
	[82][185] = 82,
	[82][186] = 82,
	[82][187] = 82,
	[82][188] = 82,
	[82][189] = 82,
	[82][190] = 82,
	[82][191] = 82,
	[82][192] = 82,
	[82][193] = 82,
	[82][194] = 82,
	[82][195] = 82,
	[82][196] = 82,
	[82][197] = 82,
	[82][198] = 82,
	[82][199] = 82,
	[82][200] = 82,
	[82][201] = 82,
	[82][202] = 82,
	[82][203] = 82,
	[82][204] = 82,
	[82][205] = 82,
	[82][206] = 82,
	[82][207] = 82,
	[82][208] = 82,
	[82][209] = 82,
	[82][210] = 82,
	[82][211] = 82,
	[82][212] = 82,
	[82][213] = 82,
	[82][214] = 82,
	[82][215] = 82,
	[82][216] = 82,
	[82][217] = 82,
	[82][218] = 82,
	[82][219] = 82,
	[82][220] = 82,
	[82][221] = 82,
	[82][222] = 82,
	[82][223] = 82,
	[82][224] = 82,
	[82][225] = 82,
	[82][226] = 82,
	[82][227] = 82,
	[82][228] = 82,
	[82][229] = 82,
	[82][230] = 82,
	[82][231] = 82,
	[82][232] = 82,
	[82][233] = 82,
	[82][234] = 82,
	[82][235] = 82,
	[82][236] = 82,
	[82][237] = 82,
	[82][238] = 82,
	[82][239] = 82,
	[82][240] = 82,
	[82][241] = 82,
	[82][242] = 82,
	[82][243] = 82,
	[82][244] = 82,
	[82][245] = 82,
	[82][246] = 82,
	[82][247] = 82,
	[82][248] = 82,
	[82][249] = 82,
	[82][250] = 82,
	[82][251] = 82,
	[82][252] = 82,
	[82][253] = 82,
	[82][254] = 82,
	[82][255] = 82,
	[83][108] = 94,
	[84][101] = 95,
	[93][45] = 96,
	[94][101] = 97,
	[95][108] = 98,
	[98][108] = 99,
};


const unsigned zebu_lexer_starts[302] = {
	[1] = 1,
	[2] = 2,
	[3] = 1,
	[4] = 3,
	[5] = 4,
	[6] = 4,
	[7] = 1,
	[8] = 1,
	[9] = 1,
	[10] = 1,
	[11] = 5,
	[12] = 6,
	[13] = 7,
	[14] = 8,
	[15] = 9,
	[16] = 10,
	[17] = 8,
	[18] = 7,
	[19] = 11,
	[20] = 12,
	[21] = 13,
	[22] = 3,
	[23] = 3,
	[24] = 3,
	[25] = 14,
	[26] = 15,
	[27] = 16,
	[28] = 17,
	[29] = 1,
	[30] = 18,
	[31] = 1,
	[32] = 18,
	[33] = 4,
	[34] = 4,
	[35] = 1,
	[36] = 1,
	[37] = 1,
	[38] = 1,
	[39] = 19,
	[40] = 20,
	[41] = 21,
	[42] = 22,
	[43] = 23,
	[44] = 21,
	[45] = 24,
	[46] = 25,
	[47] = 26,
	[48] = 18,
	[49] = 18,
	[50] = 18,
	[51] = 27,
	[52] = 28,
	[53] = 1,
	[54] = 29,
	[55] = 3,
	[56] = 3,
	[57] = 3,
	[58] = 3,
	[59] = 3,
	[60] = 3,
	[61] = 1,
	[62] = 1,
	[63] = 1,
	[64] = 17,
	[65] = 1,
	[66] = 1,
	[67] = 1,
	[68] = 7,
	[69] = 17,
	[70] = 1,
	[71] = 1,
	[72] = 1,
	[73] = 1,
	[74] = 1,
	[75] = 1,
	[76] = 1,
	[77] = 1,
	[78] = 1,
	[79] = 1,
	[80] = 1,
	[81] = 1,
	[82] = 1,
	[83] = 1,
	[84] = 8,
	[85] = 21,
	[86] = 1,
	[87] = 29,
	[88] = 18,
	[89] = 18,
	[90] = 18,
	[91] = 18,
	[92] = 18,
	[93] = 1,
	[94] = 1,
	[95] = 1,
	[96] = 1,
	[97] = 1,
	[98] = 1,
	[99] = 3,
	[100] = 1,
	[101] = 1,
	[102] = 1,
	[103] = 1,
	[104] = 1,
	[105] = 1,
	[106] = 1,
	[107] = 1,
	[108] = 1,
	[109] = 1,
	[110] = 1,
	[111] = 1,
	[112] = 1,
	[113] = 21,
	[114] = 30,
	[115] = 1,
	[116] = 30,
	[117] = 21,
	[118] = 30,
	[119] = 31,
	[120] = 5,
	[121] = 3,
	[122] = 5,
	[123] = 9,
	[124] = 9,
	[125] = 14,
	[126] = 9,
	[127] = 6,
	[128] = 10,
	[129] = 11,
	[130] = 12,
	[131] = 32,
	[132] = 1,
	[133] = 32,
	[134] = 4,
	[135] = 4,
	[136] = 1,
	[137] = 1,
	[138] = 1,
	[139] = 1,
	[140] = 33,
	[141] = 34,
	[142] = 35,
	[143] = 36,
	[144] = 37,
	[145] = 35,
	[146] = 38,
	[147] = 39,
	[148] = 40,
	[149] = 32,
	[150] = 32,
	[151] = 32,
	[152] = 41,
	[153] = 42,
	[154] = 3,
	[155] = 3,
	[156] = 3,
	[157] = 3,
	[158] = 14,
	[159] = 16,
	[160] = 14,
	[161] = 14,
	[162] = 14,
	[163] = 16,
	[164] = 5,
	[165] = 16,
	[166] = 15,
	[167] = 7,
	[168] = 18,
	[169] = 21,
	[170] = 21,
	[171] = 19,
	[172] = 18,
	[173] = 19,
	[174] = 22,
	[175] = 22,
	[176] = 27,
	[177] = 22,
	[178] = 20,
	[179] = 23,
	[180] = 24,
	[181] = 25,
	[182] = 35,
	[183] = 18,
	[184] = 18,
	[185] = 18,
	[186] = 18,
	[187] = 27,
	[188] = 28,
	[189] = 27,
	[190] = 27,
	[191] = 27,
	[192] = 28,
	[193] = 19,
	[194] = 28,
	[195] = 3,
	[196] = 3,
	[197] = 21,
	[198] = 3,
	[199] = 31,
	[200] = 30,
	[201] = 29,
	[202] = 29,
	[203] = 29,
	[204] = 21,
	[205] = 1,
	[206] = 29,
	[207] = 32,
	[208] = 32,
	[209] = 32,
	[210] = 32,
	[211] = 32,
	[212] = 1,
	[213] = 1,
	[214] = 1,
	[215] = 1,
	[216] = 1,
	[217] = 1,
	[218] = 1,
	[219] = 1,
	[220] = 1,
	[221] = 1,
	[222] = 1,
	[223] = 1,
	[224] = 1,
	[225] = 1,
	[226] = 1,
	[227] = 1,
	[228] = 1,
	[229] = 1,
	[230] = 1,
	[231] = 1,
	[232] = 18,
	[233] = 18,
	[234] = 18,
	[235] = 1,
	[236] = 30,
	[237] = 31,
	[238] = 43,
	[239] = 1,
	[240] = 43,
	[241] = 43,
	[242] = 44,
	[243] = 1,
	[244] = 44,
	[245] = 21,
	[246] = 44,
	[247] = 43,
	[248] = 21,
	[249] = 1,
	[250] = 21,
	[251] = 21,
	[252] = 21,
	[253] = 32,
	[254] = 21,
	[255] = 21,
	[256] = 33,
	[257] = 32,
	[258] = 33,
	[259] = 36,
	[260] = 36,
	[261] = 41,
	[262] = 36,
	[263] = 34,
	[264] = 8,
	[265] = 37,
	[266] = 38,
	[267] = 39,
	[268] = 35,
	[269] = 32,
	[270] = 32,
	[271] = 32,
	[272] = 32,
	[273] = 41,
	[274] = 42,
	[275] = 41,
	[276] = 41,
	[277] = 41,
	[278] = 42,
	[279] = 33,
	[280] = 42,
	[281] = 21,
	[282] = 21,
	[283] = 29,
	[284] = 29,
	[285] = 21,
	[286] = 21,
	[287] = 43,
	[288] = 44,
	[289] = 21,
	[290] = 21,
	[291] = 32,
	[292] = 32,
	[293] = 32,
	[294] = 1,
	[295] = 43,
	[296] = 21,
	[297] = 21,
	[298] = 44,
	[299] = 43,
	[300] = 21,
	[301] = 35,
};


const unsigned zebu_lexer_accepts[100] = {
	[45] = 1,
	[46] = 7,
	[48] = 3,
	[49] = 8,
	[50] = 9,
	[52] = 4,
	[55] = 10,
	[57] = 18,
	[58] = 25,
	[59] = 16,
	[60] = 17,
	[61] = 11,
	[62] = 12,
	[63] = 13,
	[65] = 15,
	[66] = 29,
	[67] = 26,
	[68] = 14,
	[69] = 9,
	[70] = 31,
	[73] = 13,
	[74] = 15,
	[76] = 32,
	[77] = 13,
	[78] = 15,
	[79] = 14,
	[80] = 2,
	[85] = 24,
	[86] = 27,
	[87] = 19,
	[88] = 21,
	[89] = 23,
	[90] = 22,
	[91] = 20,
	[92] = 28,
	[96] = 30,
	[97] = 5,
	[99] = 6,
};


const unsigned zebu_lexer_EOFs[18] = {
	[7] = 70,
	[15] = 70,
	[17] = 70,
};


#ifdef ZEBU_DEBUG
#include <stdbool.h>

struct link
{
	bool is_last;
	struct link* prev;
};

static void print_links(struct link* link)
{
	if (!link) return;
	
	print_links(link->prev);
	
	if (link->is_last)
		fputs("    ", stdout);
	else
		fputs("│   ", stdout);
}

static void print_tree_escape(char *out, char in)
{
	switch (in)
	{
		case ' ':
		case '~':
		case '!':
		case '@':
		case '#':
		case '$':
		case '%':
		case '^':
		case '&':
		case '*':
		case '-':
		case '+':
		case '=':
		case '|':
		case '<': case '>':
		case '(': case ')':
		case '{': case '}':
		case '[': case ']':
		case ':': case ';':
		case ',': case '.':
		case '_':
		case '/':
		case '`':
		case '0' ... '9':
		case 'a' ... 'z':
		case 'A' ... 'Z':
			*out++ = in;
			*out = 0;
			break;
		
		case '\\': *out++ = '\\', *out++ = '\\', *out = 0; break;
		
		case '\'': *out++ = '\\', *out++ = '\'', *out = 0; break;
		
		case '\"': *out++ = '\\', *out++ = '\"', *out = 0; break;
		
		case '\t': *out++ = '\\', *out++ = 't', *out = 0; break;
		
		case '\n': *out++ = '\\', *out++ = 'n', *out = 0; break;
		
		default:
			sprintf(out, "\\x%02X", in);
			break;
	}
}

enum prefix
{
	p_root,
	p_not_last_child,
	p_last_child,
};

void print_token_leaf(struct link* links, enum prefix p, const char* name, struct zebu_token* token)
{
	print_links(links);
	switch (p)
	{
		case p_root: break;
		case p_not_last_child: fputs("├── ", stdout); break;
		case p_last_child: fputs("└── ", stdout); break;
	}
	printf("\e[32m%s\e[0m (\e[35m\"", name);
	char escape[10];
	for (unsigned i = 0, n = token->len; i < n; i++)
		print_tree_escape(escape, token->data[i]), fputs(escape, stdout);
	printf("\"\e[0m) on line %u\n", token->line);
}

void print_scanf_leaf(struct link* links, enum prefix p, const char* name, const char* format, ...)
{
	va_list ap;
	print_links(links);
	switch (p)
	{
		case p_root: break;
		case p_not_last_child: fputs("├── ", stdout); break;
		case p_last_child: fputs("└── ", stdout); break;
	}
	printf("\e[32m%s\e[0m (\e[35m%s\e[m: \e[35m", name, format);
	va_start(ap, format);
	vprintf(format, ap);
	va_end(ap);
	printf("\e[0m)\n");
}

void print_empty_leaf(struct link* links, enum prefix p, const char* type, const char* name)
{
	print_links(links);
	switch (p)
	{
		case p_root: break;
		case p_not_last_child: fputs("├── ", stdout); break;
		case p_last_child: fputs("└── ", stdout); break;
	}
	printf("\e[31m%s\e[0m (\e[36m%s\e[0m)\n", name, type);
}
void print_zebu_$start(struct link* links, enum prefix p, const char* name, struct zebu_$start* ptree);

void print_zebu_additive_expression(struct link* links, enum prefix p, const char* name, struct zebu_additive_expression* ptree);

void print_zebu_and_expression(struct link* links, enum prefix p, const char* name, struct zebu_and_expression* ptree);

void print_zebu_assertion(struct link* links, enum prefix p, const char* name, struct zebu_assertion* ptree);

void print_zebu_complex_command(struct link* links, enum prefix p, const char* name, struct zebu_complex_command* ptree);

void print_zebu_conditional_expression(struct link* links, enum prefix p, const char* name, struct zebu_conditional_expression* ptree);

void print_zebu_equality_expression(struct link* links, enum prefix p, const char* name, struct zebu_equality_expression* ptree);

void print_zebu_exclusive_or_expression(struct link* links, enum prefix p, const char* name, struct zebu_exclusive_or_expression* ptree);

void print_zebu_expression(struct link* links, enum prefix p, const char* name, struct zebu_expression* ptree);

void print_zebu_file(struct link* links, enum prefix p, const char* name, struct zebu_file* ptree);

void print_zebu_inclusive_or_expression(struct link* links, enum prefix p, const char* name, struct zebu_inclusive_or_expression* ptree);

void print_zebu_logical_and_expression(struct link* links, enum prefix p, const char* name, struct zebu_logical_and_expression* ptree);

void print_zebu_logical_or_expression(struct link* links, enum prefix p, const char* name, struct zebu_logical_or_expression* ptree);

void print_zebu_multiplicative_expression(struct link* links, enum prefix p, const char* name, struct zebu_multiplicative_expression* ptree);

void print_zebu_prefix_expression(struct link* links, enum prefix p, const char* name, struct zebu_prefix_expression* ptree);

void print_zebu_primary_expression(struct link* links, enum prefix p, const char* name, struct zebu_primary_expression* ptree);

void print_zebu_relational_expression(struct link* links, enum prefix p, const char* name, struct zebu_relational_expression* ptree);

void print_zebu_root(struct link* links, enum prefix p, const char* name, struct zebu_root* ptree);

void print_zebu_shift_expression(struct link* links, enum prefix p, const char* name, struct zebu_shift_expression* ptree);

void print_zebu_simple_command(struct link* links, enum prefix p, const char* name, struct zebu_simple_command* ptree);

void print_zebu_test(struct link* links, enum prefix p, const char* name, struct zebu_test* ptree);

void print_zebu_$start(struct link* links, enum prefix p, const char* name, struct zebu_$start* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36m$start\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->root)
		print_zebu_root(new ?: links, p_last_child, "root", ptree->root);
	else
		print_empty_leaf(new ?: links, p_last_child, "root", "root");
	free(new);
}
void print_zebu_additive_expression(struct link* links, enum prefix p, const char* name, struct zebu_additive_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36madditive_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_multiplicative_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "multiplicative_expression", "inner");
	if (ptree->left)
		print_zebu_additive_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "additive_expression", "left");
	if (ptree->right)
		print_zebu_multiplicative_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "multiplicative_expression", "right");
	free(new);
}
void print_zebu_and_expression(struct link* links, enum prefix p, const char* name, struct zebu_and_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mand_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_equality_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "equality_expression", "inner");
	if (ptree->left)
		print_zebu_and_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "and_expression", "left");
	if (ptree->right)
		print_zebu_equality_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "equality_expression", "right");
	free(new);
}
void print_zebu_assertion(struct link* links, enum prefix p, const char* name, struct zebu_assertion* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36massertion\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->conditional)
		print_zebu_expression(new ?: links, p_last_child, "conditional", ptree->conditional);
	else
		print_empty_leaf(new ?: links, p_last_child, "expression", "conditional");
	free(new);
}
void print_zebu_complex_command(struct link* links, enum prefix p, const char* name, struct zebu_complex_command* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mcomplex_command\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->redirect_in)
		print_zebu_primary_expression(new ?: links, p_not_last_child, "redirect_in", ptree->redirect_in);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "primary_expression", "redirect_in");
	if (ptree->redirect_out)
		print_zebu_primary_expression(new ?: links, p_not_last_child, "redirect_out", ptree->redirect_out);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "primary_expression", "redirect_out");
	if (ptree->subcommands.n)
	{
		for (unsigned i = 0, n = ptree->subcommands.n; i < n; i++)
		{
			char label[11 + 30];
			snprintf(label, sizeof(label), "subcommands[%u]", i);
			print_zebu_simple_command(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->subcommands.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "simple_command[]", "subcommands");
	}
	free(new);
}
void print_zebu_conditional_expression(struct link* links, enum prefix p, const char* name, struct zebu_conditional_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mconditional_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->conditional)
		print_zebu_logical_or_expression(new ?: links, p_not_last_child, "conditional", ptree->conditional);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "logical_or_expression", "conditional");
	if (ptree->falsecase)
		print_zebu_conditional_expression(new ?: links, p_not_last_child, "falsecase", ptree->falsecase);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "conditional_expression", "falsecase");
	if (ptree->inner)
		print_zebu_logical_or_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "logical_or_expression", "inner");
	if (ptree->truecase)
		print_zebu_expression(new ?: links, p_last_child, "truecase", ptree->truecase);
	else
		print_empty_leaf(new ?: links, p_last_child, "expression", "truecase");
	free(new);
}
void print_zebu_equality_expression(struct link* links, enum prefix p, const char* name, struct zebu_equality_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mequality_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_relational_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "relational_expression", "inner");
	if (ptree->left)
		print_zebu_equality_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "equality_expression", "left");
	if (ptree->right)
		print_zebu_relational_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "relational_expression", "right");
	free(new);
}
void print_zebu_exclusive_or_expression(struct link* links, enum prefix p, const char* name, struct zebu_exclusive_or_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mexclusive_or_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_and_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "and_expression", "inner");
	if (ptree->left)
		print_zebu_exclusive_or_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "exclusive_or_expression", "left");
	if (ptree->right)
		print_zebu_and_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "and_expression", "right");
	free(new);
}
void print_zebu_expression(struct link* links, enum prefix p, const char* name, struct zebu_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mexpression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_conditional_expression(new ?: links, p_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_last_child, "conditional_expression", "inner");
	free(new);
}
void print_zebu_file(struct link* links, enum prefix p, const char* name, struct zebu_file* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mfile\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->expression)
		print_zebu_expression(new ?: links, p_not_last_child, "expression", ptree->expression);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "expression", "expression");
	if (ptree->path)
		print_token_leaf(new ?: links, p_last_child, "path", ptree->path);
	else
		print_empty_leaf(new ?: links, p_last_child, "token", "path");
	free(new);
}
void print_zebu_inclusive_or_expression(struct link* links, enum prefix p, const char* name, struct zebu_inclusive_or_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36minclusive_or_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_exclusive_or_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "exclusive_or_expression", "inner");
	if (ptree->left)
		print_zebu_inclusive_or_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "inclusive_or_expression", "left");
	if (ptree->right)
		print_zebu_exclusive_or_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "exclusive_or_expression", "right");
	free(new);
}
void print_zebu_logical_and_expression(struct link* links, enum prefix p, const char* name, struct zebu_logical_and_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mlogical_and_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_inclusive_or_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "inclusive_or_expression", "inner");
	if (ptree->left)
		print_zebu_logical_and_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "logical_and_expression", "left");
	if (ptree->right)
		print_zebu_inclusive_or_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "inclusive_or_expression", "right");
	free(new);
}
void print_zebu_logical_or_expression(struct link* links, enum prefix p, const char* name, struct zebu_logical_or_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mlogical_or_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_logical_and_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "logical_and_expression", "inner");
	if (ptree->left)
		print_zebu_logical_or_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "logical_or_expression", "left");
	if (ptree->right)
		print_zebu_logical_and_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "logical_and_expression", "right");
	free(new);
}
void print_zebu_multiplicative_expression(struct link* links, enum prefix p, const char* name, struct zebu_multiplicative_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mmultiplicative_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_prefix_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "prefix_expression", "inner");
	if (ptree->left)
		print_zebu_multiplicative_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "multiplicative_expression", "left");
	if (ptree->right)
		print_zebu_prefix_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "prefix_expression", "right");
	free(new);
}
void print_zebu_prefix_expression(struct link* links, enum prefix p, const char* name, struct zebu_prefix_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mprefix_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->file)
		print_zebu_expression(new ?: links, p_not_last_child, "file", ptree->file);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "expression", "file");
	if (ptree->inner)
		print_zebu_primary_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "primary_expression", "inner");
	if (ptree->shell)
		print_zebu_complex_command(new ?: links, p_not_last_child, "shell", ptree->shell);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "complex_command", "shell");
	if (ptree->sub)
		print_zebu_prefix_expression(new ?: links, p_last_child, "sub", ptree->sub);
	else
		print_empty_leaf(new ?: links, p_last_child, "prefix_expression", "sub");
	free(new);
}
void print_zebu_primary_expression(struct link* links, enum prefix p, const char* name, struct zebu_primary_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mprimary_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->integer)
		print_token_leaf(new ?: links, p_not_last_child, "integer", ptree->integer);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "integer");
	if (ptree->string)
		print_token_leaf(new ?: links, p_not_last_child, "string", ptree->string);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "string");
	if (ptree->sub)
		print_zebu_expression(new ?: links, p_last_child, "sub", ptree->sub);
	else
		print_empty_leaf(new ?: links, p_last_child, "expression", "sub");
	free(new);
}
void print_zebu_relational_expression(struct link* links, enum prefix p, const char* name, struct zebu_relational_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mrelational_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_shift_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "shift_expression", "inner");
	if (ptree->left)
		print_zebu_relational_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "relational_expression", "left");
	if (ptree->right)
		print_zebu_shift_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "shift_expression", "right");
	free(new);
}
void print_zebu_root(struct link* links, enum prefix p, const char* name, struct zebu_root* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mroot\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->tests.n)
	{
		for (unsigned i = 0, n = ptree->tests.n; i < n; i++)
		{
			char label[5 + 30];
			snprintf(label, sizeof(label), "tests[%u]", i);
			print_zebu_test(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->tests.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "test[]", "tests");
	}
	free(new);
}
void print_zebu_shift_expression(struct link* links, enum prefix p, const char* name, struct zebu_shift_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mshift_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_additive_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "additive_expression", "inner");
	if (ptree->left)
		print_zebu_shift_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "shift_expression", "left");
	if (ptree->right)
		print_zebu_additive_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "additive_expression", "right");
	free(new);
}
void print_zebu_simple_command(struct link* links, enum prefix p, const char* name, struct zebu_simple_command* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36msimple_command\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->args.n)
	{
		for (unsigned i = 0, n = ptree->args.n; i < n; i++)
		{
			char label[4 + 30];
			snprintf(label, sizeof(label), "args[%u]", i);
			print_zebu_primary_expression(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->args.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "primary_expression[]", "args");
	}
	free(new);
}
void print_zebu_test(struct link* links, enum prefix p, const char* name, struct zebu_test* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mtest\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->assertions.n)
	{
		for (unsigned i = 0, n = ptree->assertions.n; i < n; i++)
		{
			char label[10 + 30];
			snprintf(label, sizeof(label), "assertions[%u]", i);
			print_zebu_assertion(new ?: links, i + 1 < n ? p_not_last_child : p_not_last_child, label, ptree->assertions.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_not_last_child, "assertion[]", "assertions");
	}
	if (ptree->files.n)
	{
		for (unsigned i = 0, n = ptree->files.n; i < n; i++)
		{
			char label[5 + 30];
			snprintf(label, sizeof(label), "files[%u]", i);
			print_zebu_file(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->files.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "file[]", "files");
	}
	free(new);
}

#endif

struct zebu_token* inc_zebu_token(struct zebu_token* token)
{
	if (token) token->refcount++;
	return token;
}
struct zebu_$start* inc_zebu_$start(struct zebu_$start* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_additive_expression* inc_zebu_additive_expression(struct zebu_additive_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_and_expression* inc_zebu_and_expression(struct zebu_and_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_assertion* inc_zebu_assertion(struct zebu_assertion* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_complex_command* inc_zebu_complex_command(struct zebu_complex_command* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_conditional_expression* inc_zebu_conditional_expression(struct zebu_conditional_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_equality_expression* inc_zebu_equality_expression(struct zebu_equality_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_exclusive_or_expression* inc_zebu_exclusive_or_expression(struct zebu_exclusive_or_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_expression* inc_zebu_expression(struct zebu_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_file* inc_zebu_file(struct zebu_file* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_inclusive_or_expression* inc_zebu_inclusive_or_expression(struct zebu_inclusive_or_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_logical_and_expression* inc_zebu_logical_and_expression(struct zebu_logical_and_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_logical_or_expression* inc_zebu_logical_or_expression(struct zebu_logical_or_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_multiplicative_expression* inc_zebu_multiplicative_expression(struct zebu_multiplicative_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_prefix_expression* inc_zebu_prefix_expression(struct zebu_prefix_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_primary_expression* inc_zebu_primary_expression(struct zebu_primary_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_relational_expression* inc_zebu_relational_expression(struct zebu_relational_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_root* inc_zebu_root(struct zebu_root* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_shift_expression* inc_zebu_shift_expression(struct zebu_shift_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_simple_command* inc_zebu_simple_command(struct zebu_simple_command* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_test* inc_zebu_test(struct zebu_test* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}



extern void free_zebu_token(struct zebu_token* token);
extern void free_zebu_$start(struct zebu_$start* ptree);

extern void free_zebu_additive_expression(struct zebu_additive_expression* ptree);

extern void free_zebu_and_expression(struct zebu_and_expression* ptree);

extern void free_zebu_assertion(struct zebu_assertion* ptree);

extern void free_zebu_complex_command(struct zebu_complex_command* ptree);

extern void free_zebu_conditional_expression(struct zebu_conditional_expression* ptree);

extern void free_zebu_equality_expression(struct zebu_equality_expression* ptree);

extern void free_zebu_exclusive_or_expression(struct zebu_exclusive_or_expression* ptree);

extern void free_zebu_expression(struct zebu_expression* ptree);

extern void free_zebu_file(struct zebu_file* ptree);

extern void free_zebu_inclusive_or_expression(struct zebu_inclusive_or_expression* ptree);

extern void free_zebu_logical_and_expression(struct zebu_logical_and_expression* ptree);

extern void free_zebu_logical_or_expression(struct zebu_logical_or_expression* ptree);

extern void free_zebu_multiplicative_expression(struct zebu_multiplicative_expression* ptree);

extern void free_zebu_prefix_expression(struct zebu_prefix_expression* ptree);

extern void free_zebu_primary_expression(struct zebu_primary_expression* ptree);

extern void free_zebu_relational_expression(struct zebu_relational_expression* ptree);

extern void free_zebu_root(struct zebu_root* ptree);

extern void free_zebu_shift_expression(struct zebu_shift_expression* ptree);

extern void free_zebu_simple_command(struct zebu_simple_command* ptree);

extern void free_zebu_test(struct zebu_test* ptree);

void free_zebu_token(struct zebu_token* token)
{
	if (token && !--token->refcount)
	{
		free(token->data);
		free(token);
	}
}
void free_zebu_$start(struct zebu_$start* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_root(ptree->root);
		free(ptree);
	}
}

void free_zebu_additive_expression(struct zebu_additive_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_multiplicative_expression(ptree->inner);
		free_zebu_additive_expression(ptree->left);
		free_zebu_multiplicative_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_and_expression(struct zebu_and_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_equality_expression(ptree->inner);
		free_zebu_and_expression(ptree->left);
		free_zebu_equality_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_assertion(struct zebu_assertion* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_expression(ptree->conditional);
		free(ptree);
	}
}

void free_zebu_complex_command(struct zebu_complex_command* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_primary_expression(ptree->redirect_in);
		free_zebu_primary_expression(ptree->redirect_out);
		for (unsigned i = 0, n = ptree->subcommands.n; i < n; i++)
			free_zebu_simple_command(ptree->subcommands.data[i]);
		free(ptree->subcommands.data);
		free(ptree);
	}
}

void free_zebu_conditional_expression(struct zebu_conditional_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_logical_or_expression(ptree->conditional);
		free_zebu_conditional_expression(ptree->falsecase);
		free_zebu_logical_or_expression(ptree->inner);
		free_zebu_expression(ptree->truecase);
		free(ptree);
	}
}

void free_zebu_equality_expression(struct zebu_equality_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_relational_expression(ptree->inner);
		free_zebu_equality_expression(ptree->left);
		free_zebu_relational_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_exclusive_or_expression(struct zebu_exclusive_or_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_and_expression(ptree->inner);
		free_zebu_exclusive_or_expression(ptree->left);
		free_zebu_and_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_expression(struct zebu_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_conditional_expression(ptree->inner);
		free(ptree);
	}
}

void free_zebu_file(struct zebu_file* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_expression(ptree->expression);
		free_zebu_token(ptree->path);
		free(ptree);
	}
}

void free_zebu_inclusive_or_expression(struct zebu_inclusive_or_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_exclusive_or_expression(ptree->inner);
		free_zebu_inclusive_or_expression(ptree->left);
		free_zebu_exclusive_or_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_logical_and_expression(struct zebu_logical_and_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_inclusive_or_expression(ptree->inner);
		free_zebu_logical_and_expression(ptree->left);
		free_zebu_inclusive_or_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_logical_or_expression(struct zebu_logical_or_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_logical_and_expression(ptree->inner);
		free_zebu_logical_or_expression(ptree->left);
		free_zebu_logical_and_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_multiplicative_expression(struct zebu_multiplicative_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_prefix_expression(ptree->inner);
		free_zebu_multiplicative_expression(ptree->left);
		free_zebu_prefix_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_prefix_expression(struct zebu_prefix_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_expression(ptree->file);
		free_zebu_primary_expression(ptree->inner);
		free_zebu_complex_command(ptree->shell);
		free_zebu_prefix_expression(ptree->sub);
		free(ptree);
	}
}

void free_zebu_primary_expression(struct zebu_primary_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->integer);
		free_zebu_token(ptree->string);
		free_zebu_expression(ptree->sub);
		free(ptree);
	}
}

void free_zebu_relational_expression(struct zebu_relational_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_shift_expression(ptree->inner);
		free_zebu_relational_expression(ptree->left);
		free_zebu_shift_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_root(struct zebu_root* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		for (unsigned i = 0, n = ptree->tests.n; i < n; i++)
			free_zebu_test(ptree->tests.data[i]);
		free(ptree->tests.data);
		free(ptree);
	}
}

void free_zebu_shift_expression(struct zebu_shift_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_additive_expression(ptree->inner);
		free_zebu_shift_expression(ptree->left);
		free_zebu_additive_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_simple_command(struct zebu_simple_command* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		for (unsigned i = 0, n = ptree->args.n; i < n; i++)
			free_zebu_primary_expression(ptree->args.data[i]);
		free(ptree->args.data);
		free(ptree);
	}
}

void free_zebu_test(struct zebu_test* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		for (unsigned i = 0, n = ptree->assertions.n; i < n; i++)
			free_zebu_assertion(ptree->assertions.data[i]);
		free(ptree->assertions.data);
		for (unsigned i = 0, n = ptree->files.n; i < n; i++)
			free_zebu_file(ptree->files.data[i]);
		free(ptree->files.data);
		free(ptree);
	}
}



#define argv0 (program_invocation_name)

#define N(array) (sizeof(array) / sizeof(*array))

#ifdef ZEBU_DEBUG
static void escape(char *out, unsigned char in)
{
	switch (in)
	{
		case ' ':
		case '~':
		case '!':
		case '@':
		case '#':
		case '$':
		case '%':
		case '^':
		case '&':
		case '*':
		case '-':
		case '+':
		case '=':
		case '|':
		case '/':
		case '<': case '>':
		case '(': case ')':
		case '{': case '}':
		case '[': case ']':
		case ':': case ';':
		case ',': case '.':
		case '_':
		case '0' ... '9':
		case 'a' ... 'z':
		case 'A' ... 'Z':
			*out++ = in;
			*out = 0;
			break;
		
		case '\\': *out++ = '\\', *out++ = '\\', *out = 0; break;
		
		case '\'': *out++ = '\\', *out++ = '\'', *out = 0; break;
		
		case '\"': *out++ = '\\', *out++ = '\"', *out = 0; break;
		
		case '\t': *out++ = '\\', *out++ = 't', *out = 0; break;
		
		case '\n': *out++ = '\\', *out++ = 'n', *out = 0; break;
		
		default:
			sprintf(out, "\\x%02hhX", in);
			break;
	}
}
#endif

struct zebu_$start* zebu_parse(FILE* stream)
{
	void* root;
	struct { unsigned* data, n, cap; } yacc = {};
	struct { void** data; unsigned n, cap; } data = {};
	struct { unsigned char* data; unsigned n, cap, line; } lexer = {
		.line = 1,
	};
	
	void push_state(unsigned y)
	{
		if (yacc.n + 1 >= yacc.cap)
		{
			yacc.cap = yacc.cap << 1 ?: 1;
			yacc.data = realloc(yacc.data, sizeof(*yacc.data) * yacc.cap);
		}
		yacc.data[yacc.n++] = y;
	}
	
	void push_data(void* d)
	{
		if (data.n + 1 >= data.cap)
		{
			data.cap = data.cap << 1 ?: 1;
			data.data = realloc(data.data, sizeof(*data.data) * data.cap);
		}
		data.data[data.n++] = d;
	}
	
	#ifdef ZEBU_DEBUG
	void ddprintf(const char* fmt, ...)
	{
		for (unsigned i = 0, n = yacc.n; i < n; i++)
			printf("%u ", yacc.data[i]);
		
		printf("| ");
		
		va_list va;
		va_start(va, fmt);
		vprintf(fmt, va);
		va_end(va);
	}
	#endif
	
	void push_char(unsigned char c)
	{
		while (lexer.n + 1 >= lexer.cap)
		{
			lexer.cap = lexer.cap << 1 ?: 1;
			#ifdef ZEBU_DEBUG
			ddprintf("lexer.cap == %u\n", lexer.cap);
			#endif
			lexer.data = realloc(lexer.data, lexer.cap);
		}
		
		lexer.data[lexer.n++] = c;
	}
	
	unsigned y, t, s, r;
	void* td;
	
	void read_token(unsigned l)
	{
		unsigned original_l = l, i = 0, a, b, c, f = 0;
		
		unsigned line = lexer.line;
		
		t = 0;
		
		#ifdef ZEBU_DEBUG
		ddprintf("lexer: \"%.*s\": l = %u\n", lexer.n, lexer.data, l);
		#endif
		
		while (1)
		{
			if (i < lexer.n)
			{
				c = lexer.data[i];
				
				#ifdef ZEBU_DEBUG
				char escaped[10];
				
				escape(escaped, c);
				
				ddprintf("lexer: c = '%s' (0x%X) (from cache)\n", escaped, c);
				#endif
				
				a = l < N(zebu_lexer) && c < N(*zebu_lexer) ? zebu_lexer[l][c] : 0;
			}
			else if ((c = getc(stream)) != EOF)
			{
				push_char(c);
				
				#ifdef ZEBU_DEBUG
				char escaped[10];
				
				escape(escaped, c);
				
				ddprintf("lexer: c = '%s' (0x%X)\n", escaped, c);
				#endif
				
				a = l < N(zebu_lexer) && c < N(*zebu_lexer) ? zebu_lexer[l][c] : 0;
			}
			else
			{
				c = EOF;
				
				#ifdef ZEBU_DEBUG
				ddprintf("lexer: c = <EOF>\n");
				#endif
				
				a = l < N(zebu_lexer_EOFs) ? zebu_lexer_EOFs[l] : 0;
			}
			
			b = l < N(zebu_lexer_accepts) ? zebu_lexer_accepts[l] : 0;
			
			#ifdef ZEBU_DEBUG
			ddprintf("lexer: \"%.*s\" (%u): a = %u, b = %u\n", lexer.n, lexer.data, i, a, b);
			#endif
			
			if (a)
			{
				if (b)
				{
					l = a, t = b, f = i++, lexer.line = line;
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: l = %u\n", l);
					#endif
				}
				else
				{
					l = a, i++;
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: l = %u\n", l);
					#endif
				}
				
				if (c == '\n')
				{
					line++;
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: line: %u\n", line);
					#endif
				}
			}
			else if (b)
			{
				#ifdef ZEBU_DEBUG
				ddprintf("lexer: token: \"%.*s\", line: %u\n", i, lexer.data, line);
				#endif
				
				if (!lexer.n)
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: EOF.\n");
					#endif
					t = b, td = NULL;
					break;
				}
				else if (b == 1)
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: whitespace: \"%.*s\"\n", i, lexer.data);
					#endif
					
					l = original_l, t = 0, lexer.line = line;
					memmove(lexer.data, lexer.data + i, lexer.n - i), lexer.n -= i, i = 0;
				}
				else
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: i = %u\n", i);
					#endif
					
					struct zebu_token* token = malloc(sizeof(*token));
					token->refcount = 1;
					token->line = line;
					token->data = memcpy(malloc(i + 1), lexer.data, i);
					token->data[i] = 0;
					token->len = i;
					t = b, td = token;
					
					lexer.line = line;
					memmove(lexer.data, lexer.data + i, lexer.n - i), lexer.n -= i;
					break;
				}
			}
			else if (t)
			{
				if (t == 1)
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: falling back to whitespace: \"%.*s\"\n", f, lexer.data);
					#endif
					
					l = original_l, t = 0, line = lexer.line;
					memmove(lexer.data, lexer.data + f, lexer.n - f), lexer.n -= f, f = 0, i = 0;
				}
				else
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: falling back to token: \"%.*s\"\n", f, lexer.data);
					#endif
					
					struct zebu_token* token = malloc(sizeof(*token));
					token->refcount = 1;
					token->line = lexer.line;
					token->data = memcpy(malloc(f + 1), lexer.data, f);
					token->data[f] = 0;
					token->len = f;
					td = token;
					
					memmove(lexer.data, lexer.data + f, lexer.n - f), lexer.n -= f, f = 0;
					break;
				}
			}
			else
			{
				if (i != 0)
				{
					if (c == (unsigned) EOF)
						fprintf(stderr, "%s: unexpected '<EOF>' when reading '%.*s' on line %u!\n", argv0, i, lexer.data, line);
					else
						fprintf(stderr, "%s: unexpected '%c' when reading '%.*s' on line %u!\n", argv0, c, i, lexer.data, line);
				}
				else
				{
					if (c == (unsigned) EOF)
						fprintf(stderr, "%s: unexpected '<EOF>' on line %u!\n", argv0, line);
					else
						fprintf(stderr, "%s: unexpected '%c' on line %u!\n", argv0, c, line);
				}
				exit(1);
			}
		}
	}
	
	push_state(1), y = 1, read_token(1);
	
	#ifdef ZEBU_DEBUG
	ddprintf("y = %u, t = %u\n", y, t);
	#endif
	
	while (yacc.n)
	{
		if (y < N(zebu_shifts) && t < N(*zebu_shifts) && (s = zebu_shifts[y][t]))
		{
			#ifdef ZEBU_DEBUG
			ddprintf("s == %u\n", s);
			#endif
			
			y = s, push_state(y), push_data(td);
			
			read_token(zebu_lexer_starts[y]);
			
			#ifdef ZEBU_DEBUG
			ddprintf("t = %u\n", t);
			#endif
		}
		else if (y < N( zebu_reduces) && t < N(*zebu_reduces) && (r = zebu_reduces[y][t]))
		{
			#ifdef ZEBU_DEBUG
			ddprintf("r == %u\n", r);
			#endif
			
			unsigned g;
			void* d;
			
			switch (r)
{
	case 17:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_root* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_root(value->root), value->root = inc_zebu_root(subgrammar);
free_zebu_root(subgrammar);
}
		d = value, g = 32;
		break;
	}
	case 32:
	{
		struct zebu_additive_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_multiplicative_expression(value->right), value->right = inc_zebu_multiplicative_expression(subgrammar);
free_zebu_multiplicative_expression(subgrammar);
}
		d = value, g = 22;
		break;
	}
	case 71:
	{
		struct zebu_complex_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_complex_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->redirect_in) { free_zebu_primary_expression(value->redirect_in); value->redirect_in = inc_zebu_primary_expression(trie->redirect_in); }
if (trie->redirect_out) { free_zebu_primary_expression(value->redirect_out); value->redirect_out = inc_zebu_primary_expression(trie->redirect_out); }
if (trie->subcommands.n)
{
while (value->subcommands.n + trie->subcommands.n > value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + trie->subcommands.n, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
for (unsigned i = 0, n = trie->subcommands.n; i < n; i++)
value->subcommands.data[i] = inc_zebu_simple_command(trie->subcommands.data[i]);
value->subcommands.n += trie->subcommands.n;
}
free_zebu_complex_command(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 31;
		break;
	}
	case 70:
	{
		struct zebu_complex_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_complex_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->redirect_in) { free_zebu_primary_expression(value->redirect_in); value->redirect_in = inc_zebu_primary_expression(trie->redirect_in); }
if (trie->redirect_out) { free_zebu_primary_expression(value->redirect_out); value->redirect_out = inc_zebu_primary_expression(trie->redirect_out); }
if (trie->subcommands.n)
{
while (value->subcommands.n + trie->subcommands.n > value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + trie->subcommands.n, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
for (unsigned i = 0, n = trie->subcommands.n; i < n; i++)
value->subcommands.data[i] = inc_zebu_simple_command(trie->subcommands.data[i]);
value->subcommands.n += trie->subcommands.n;
}
free_zebu_complex_command(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 31;
		break;
	}
	case 60:
	{
		struct zebu_simple_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_primary_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->args.n == value->args.cap)
{
value->args.cap = value->args.cap << 1 ?: 1;
value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
}
memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
value->args.data[0] = inc_zebu_primary_expression(subgrammar), value->args.n++;
free_zebu_primary_expression(subgrammar);
}
		d = value, g = 28;
		break;
	}
	case 61:
	{
		struct zebu_simple_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_simple_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->args.n)
{
while (value->args.n + trie->args.n > value->args.cap)
{
value->args.cap = value->args.cap << 1 ?: 1;
value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
}
memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
for (unsigned i = 0, n = trie->args.n; i < n; i++)
value->args.data[i] = inc_zebu_primary_expression(trie->args.data[i]);
value->args.n += trie->args.n;
}
free_zebu_simple_command(trie);
}
{
struct zebu_primary_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->args.n == value->args.cap)
{
value->args.cap = value->args.cap << 1 ?: 1;
value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
}
memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
value->args.data[0] = inc_zebu_primary_expression(subgrammar), value->args.n++;
free_zebu_primary_expression(subgrammar);
}
		d = value, g = 28;
		break;
	}
	case 64:
	{
		struct zebu_complex_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_simple_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->subcommands.n == value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + 1, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
value->subcommands.data[0] = inc_zebu_simple_command(subgrammar), value->subcommands.n++;
free_zebu_simple_command(subgrammar);
}
		d = value, g = 29;
		break;
	}
	case 69:
	{
		struct zebu_complex_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_complex_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->redirect_in) { free_zebu_primary_expression(value->redirect_in); value->redirect_in = inc_zebu_primary_expression(trie->redirect_in); }
if (trie->redirect_out) { free_zebu_primary_expression(value->redirect_out); value->redirect_out = inc_zebu_primary_expression(trie->redirect_out); }
if (trie->subcommands.n)
{
while (value->subcommands.n + trie->subcommands.n > value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + trie->subcommands.n, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
for (unsigned i = 0, n = trie->subcommands.n; i < n; i++)
value->subcommands.data[i] = inc_zebu_simple_command(trie->subcommands.data[i]);
value->subcommands.n += trie->subcommands.n;
}
free_zebu_complex_command(trie);
}
{
struct zebu_simple_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->subcommands.n == value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + 1, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
value->subcommands.data[0] = inc_zebu_simple_command(subgrammar), value->subcommands.n++;
free_zebu_simple_command(subgrammar);
}
		d = value, g = 29;
		break;
	}
	case 66:
	{
		struct zebu_complex_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_primary_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_primary_expression(value->redirect_out), value->redirect_out = inc_zebu_primary_expression(subgrammar);
free_zebu_primary_expression(subgrammar);
}
		d = value, g = 30;
		break;
	}
	case 36:
	{
		struct zebu_equality_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_relational_expression(value->right), value->right = inc_zebu_relational_expression(subgrammar);
free_zebu_relational_expression(subgrammar);
}
		d = value, g = 23;
		break;
	}
	case 43:
	{
		struct zebu_multiplicative_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_prefix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_prefix_expression(value->right), value->right = inc_zebu_prefix_expression(subgrammar);
free_zebu_prefix_expression(subgrammar);
}
		d = value, g = 24;
		break;
	}
	case 21:
	{
		struct zebu_prefix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_prefix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_prefix_expression(value->sub), value->sub = inc_zebu_prefix_expression(subgrammar);
free_zebu_prefix_expression(subgrammar);
}
		d = value, g = 19;
		break;
	}
	case 56:
	{
		struct zebu_prefix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 27;
		break;
	}
	case 47:
	{
		struct zebu_relational_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_shift_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_shift_expression(value->right), value->right = inc_zebu_shift_expression(subgrammar);
free_zebu_shift_expression(subgrammar);
}
		d = value, g = 25;
		break;
	}
	case 52:
	{
		struct zebu_shift_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_additive_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_additive_expression(value->right), value->right = inc_zebu_additive_expression(subgrammar);
free_zebu_additive_expression(subgrammar);
}
		d = value, g = 26;
		break;
	}
	case 33:
	{
		struct zebu_additive_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_additive_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_multiplicative_expression(value->inner); value->inner = inc_zebu_multiplicative_expression(trie->inner); }
if (trie->left) { free_zebu_additive_expression(value->left); value->left = inc_zebu_additive_expression(trie->left); }
if (trie->right) { free_zebu_multiplicative_expression(value->right); value->right = inc_zebu_multiplicative_expression(trie->right); }
free_zebu_additive_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_additive_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_additive_expression(value->left), value->left = inc_zebu_additive_expression(subgrammar);
free_zebu_additive_expression(subgrammar);
}
		d = value, g = 1;
		break;
	}
	case 13:
	{
		struct zebu_additive_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_multiplicative_expression(value->inner), value->inner = inc_zebu_multiplicative_expression(subgrammar);
free_zebu_multiplicative_expression(subgrammar);
}
		d = value, g = 1;
		break;
	}
	case 31:
	{
		struct zebu_additive_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_additive_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_multiplicative_expression(value->inner); value->inner = inc_zebu_multiplicative_expression(trie->inner); }
if (trie->left) { free_zebu_additive_expression(value->left); value->left = inc_zebu_additive_expression(trie->left); }
if (trie->right) { free_zebu_multiplicative_expression(value->right); value->right = inc_zebu_multiplicative_expression(trie->right); }
free_zebu_additive_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_additive_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_additive_expression(value->left), value->left = inc_zebu_additive_expression(subgrammar);
free_zebu_additive_expression(subgrammar);
}
		d = value, g = 1;
		break;
	}
	case 34:
	{
		struct zebu_and_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_equality_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_equality_expression(value->right), value->right = inc_zebu_equality_expression(subgrammar);
free_zebu_equality_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_and_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_and_expression(value->left), value->left = inc_zebu_and_expression(subgrammar);
free_zebu_and_expression(subgrammar);
}
		d = value, g = 2;
		break;
	}
	case 7:
	{
		struct zebu_and_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_equality_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_equality_expression(value->inner), value->inner = inc_zebu_equality_expression(subgrammar);
free_zebu_equality_expression(subgrammar);
}
		d = value, g = 2;
		break;
	}
	case 26:
	{
		struct zebu_assertion* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression(value->conditional), value->conditional = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
		d = value, g = 3;
		break;
	}
	case 30:
	{
		struct zebu_complex_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_simple_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->subcommands.n == value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + 1, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
value->subcommands.data[0] = inc_zebu_simple_command(subgrammar), value->subcommands.n++;
free_zebu_simple_command(subgrammar);
}
		d = value, g = 20;
		break;
	}
	case 62:
	{
		struct zebu_complex_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_primary_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_primary_expression(value->redirect_in), value->redirect_in = inc_zebu_primary_expression(subgrammar);
free_zebu_primary_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_simple_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->subcommands.n == value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + 1, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
value->subcommands.data[0] = inc_zebu_simple_command(subgrammar), value->subcommands.n++;
free_zebu_simple_command(subgrammar);
}
		d = value, g = 20;
		break;
	}
	case 68:
	{
		struct zebu_complex_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_complex_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->redirect_in) { free_zebu_primary_expression(value->redirect_in); value->redirect_in = inc_zebu_primary_expression(trie->redirect_in); }
if (trie->redirect_out) { free_zebu_primary_expression(value->redirect_out); value->redirect_out = inc_zebu_primary_expression(trie->redirect_out); }
if (trie->subcommands.n)
{
while (value->subcommands.n + trie->subcommands.n > value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + trie->subcommands.n, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
for (unsigned i = 0, n = trie->subcommands.n; i < n; i++)
value->subcommands.data[i] = inc_zebu_simple_command(trie->subcommands.data[i]);
value->subcommands.n += trie->subcommands.n;
}
free_zebu_complex_command(trie);
}
{
struct zebu_primary_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_primary_expression(value->redirect_in), value->redirect_in = inc_zebu_primary_expression(subgrammar);
free_zebu_primary_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_simple_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->subcommands.n == value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + 1, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
value->subcommands.data[0] = inc_zebu_simple_command(subgrammar), value->subcommands.n++;
free_zebu_simple_command(subgrammar);
}
		d = value, g = 20;
		break;
	}
	case 63:
	{
		struct zebu_complex_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_complex_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->redirect_in) { free_zebu_primary_expression(value->redirect_in); value->redirect_in = inc_zebu_primary_expression(trie->redirect_in); }
if (trie->redirect_out) { free_zebu_primary_expression(value->redirect_out); value->redirect_out = inc_zebu_primary_expression(trie->redirect_out); }
if (trie->subcommands.n)
{
while (value->subcommands.n + trie->subcommands.n > value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + trie->subcommands.n, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
for (unsigned i = 0, n = trie->subcommands.n; i < n; i++)
value->subcommands.data[i] = inc_zebu_simple_command(trie->subcommands.data[i]);
value->subcommands.n += trie->subcommands.n;
}
free_zebu_complex_command(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_simple_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->subcommands.n == value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + 1, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
value->subcommands.data[0] = inc_zebu_simple_command(subgrammar), value->subcommands.n++;
free_zebu_simple_command(subgrammar);
}
		d = value, g = 20;
		break;
	}
	case 65:
	{
		struct zebu_complex_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_complex_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->redirect_in) { free_zebu_primary_expression(value->redirect_in); value->redirect_in = inc_zebu_primary_expression(trie->redirect_in); }
if (trie->redirect_out) { free_zebu_primary_expression(value->redirect_out); value->redirect_out = inc_zebu_primary_expression(trie->redirect_out); }
if (trie->subcommands.n)
{
while (value->subcommands.n + trie->subcommands.n > value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + trie->subcommands.n, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
for (unsigned i = 0, n = trie->subcommands.n; i < n; i++)
value->subcommands.data[i] = inc_zebu_simple_command(trie->subcommands.data[i]);
value->subcommands.n += trie->subcommands.n;
}
free_zebu_complex_command(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_simple_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->subcommands.n == value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + 1, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
value->subcommands.data[0] = inc_zebu_simple_command(subgrammar), value->subcommands.n++;
free_zebu_simple_command(subgrammar);
}
		d = value, g = 20;
		break;
	}
	case 67:
	{
		struct zebu_conditional_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_conditional_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_conditional_expression(value->falsecase), value->falsecase = inc_zebu_conditional_expression(subgrammar);
free_zebu_conditional_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression(value->truecase), value->truecase = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_logical_or_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_logical_or_expression(value->conditional), value->conditional = inc_zebu_logical_or_expression(subgrammar);
free_zebu_logical_or_expression(value->inner), value->inner = inc_zebu_logical_or_expression(subgrammar);
free_zebu_logical_or_expression(subgrammar);
}
		d = value, g = 4;
		break;
	}
	case 12:
	{
		struct zebu_conditional_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_logical_or_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_logical_or_expression(value->conditional), value->conditional = inc_zebu_logical_or_expression(subgrammar);
free_zebu_logical_or_expression(value->inner), value->inner = inc_zebu_logical_or_expression(subgrammar);
free_zebu_logical_or_expression(subgrammar);
}
		d = value, g = 4;
		break;
	}
	case 35:
	{
		struct zebu_equality_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_equality_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_relational_expression(value->inner); value->inner = inc_zebu_relational_expression(trie->inner); }
if (trie->left) { free_zebu_equality_expression(value->left); value->left = inc_zebu_equality_expression(trie->left); }
if (trie->right) { free_zebu_relational_expression(value->right); value->right = inc_zebu_relational_expression(trie->right); }
free_zebu_equality_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_equality_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_equality_expression(value->left), value->left = inc_zebu_equality_expression(subgrammar);
free_zebu_equality_expression(subgrammar);
}
		d = value, g = 5;
		break;
	}
	case 37:
	{
		struct zebu_equality_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_equality_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_relational_expression(value->inner); value->inner = inc_zebu_relational_expression(trie->inner); }
if (trie->left) { free_zebu_equality_expression(value->left); value->left = inc_zebu_equality_expression(trie->left); }
if (trie->right) { free_zebu_relational_expression(value->right); value->right = inc_zebu_relational_expression(trie->right); }
free_zebu_equality_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_equality_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_equality_expression(value->left), value->left = inc_zebu_equality_expression(subgrammar);
free_zebu_equality_expression(subgrammar);
}
		d = value, g = 5;
		break;
	}
	case 16:
	{
		struct zebu_equality_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_relational_expression(value->inner), value->inner = inc_zebu_relational_expression(subgrammar);
free_zebu_relational_expression(subgrammar);
}
		d = value, g = 5;
		break;
	}
	case 4:
	{
		struct zebu_exclusive_or_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_and_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_and_expression(value->inner), value->inner = inc_zebu_and_expression(subgrammar);
free_zebu_and_expression(subgrammar);
}
		d = value, g = 6;
		break;
	}
	case 38:
	{
		struct zebu_exclusive_or_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_and_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_and_expression(value->right), value->right = inc_zebu_and_expression(subgrammar);
free_zebu_and_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_exclusive_or_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_exclusive_or_expression(value->left), value->left = inc_zebu_exclusive_or_expression(subgrammar);
free_zebu_exclusive_or_expression(subgrammar);
}
		d = value, g = 6;
		break;
	}
	case 6:
	{
		struct zebu_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_conditional_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_conditional_expression(value->inner), value->inner = inc_zebu_conditional_expression(subgrammar);
free_zebu_conditional_expression(subgrammar);
}
		d = value, g = 7;
		break;
	}
	case 55:
	{
		struct zebu_file* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression(value->expression), value->expression = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->path), value->path = inc_zebu_token(token);
free_zebu_token(token);
}
		d = value, g = 8;
		break;
	}
	case 8:
	{
		struct zebu_inclusive_or_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_exclusive_or_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_exclusive_or_expression(value->inner), value->inner = inc_zebu_exclusive_or_expression(subgrammar);
free_zebu_exclusive_or_expression(subgrammar);
}
		d = value, g = 9;
		break;
	}
	case 39:
	{
		struct zebu_inclusive_or_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_exclusive_or_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_exclusive_or_expression(value->right), value->right = inc_zebu_exclusive_or_expression(subgrammar);
free_zebu_exclusive_or_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_inclusive_or_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_inclusive_or_expression(value->left), value->left = inc_zebu_inclusive_or_expression(subgrammar);
free_zebu_inclusive_or_expression(subgrammar);
}
		d = value, g = 9;
		break;
	}
	case 10:
	{
		struct zebu_logical_and_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_inclusive_or_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_inclusive_or_expression(value->inner), value->inner = inc_zebu_inclusive_or_expression(subgrammar);
free_zebu_inclusive_or_expression(subgrammar);
}
		d = value, g = 10;
		break;
	}
	case 40:
	{
		struct zebu_logical_and_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_inclusive_or_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_inclusive_or_expression(value->right), value->right = inc_zebu_inclusive_or_expression(subgrammar);
free_zebu_inclusive_or_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_logical_and_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_logical_and_expression(value->left), value->left = inc_zebu_logical_and_expression(subgrammar);
free_zebu_logical_and_expression(subgrammar);
}
		d = value, g = 10;
		break;
	}
	case 11:
	{
		struct zebu_logical_or_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_logical_and_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_logical_and_expression(value->inner), value->inner = inc_zebu_logical_and_expression(subgrammar);
free_zebu_logical_and_expression(subgrammar);
}
		d = value, g = 11;
		break;
	}
	case 41:
	{
		struct zebu_logical_or_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_logical_and_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_logical_and_expression(value->right), value->right = inc_zebu_logical_and_expression(subgrammar);
free_zebu_logical_and_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_logical_or_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_logical_or_expression(value->left), value->left = inc_zebu_logical_or_expression(subgrammar);
free_zebu_logical_or_expression(subgrammar);
}
		d = value, g = 11;
		break;
	}
	case 42:
	{
		struct zebu_multiplicative_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_multiplicative_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_prefix_expression(value->inner); value->inner = inc_zebu_prefix_expression(trie->inner); }
if (trie->left) { free_zebu_multiplicative_expression(value->left); value->left = inc_zebu_multiplicative_expression(trie->left); }
if (trie->right) { free_zebu_prefix_expression(value->right); value->right = inc_zebu_prefix_expression(trie->right); }
free_zebu_multiplicative_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_multiplicative_expression(value->left), value->left = inc_zebu_multiplicative_expression(subgrammar);
free_zebu_multiplicative_expression(subgrammar);
}
		d = value, g = 12;
		break;
	}
	case 44:
	{
		struct zebu_multiplicative_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_multiplicative_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_prefix_expression(value->inner); value->inner = inc_zebu_prefix_expression(trie->inner); }
if (trie->left) { free_zebu_multiplicative_expression(value->left); value->left = inc_zebu_multiplicative_expression(trie->left); }
if (trie->right) { free_zebu_prefix_expression(value->right); value->right = inc_zebu_prefix_expression(trie->right); }
free_zebu_multiplicative_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_multiplicative_expression(value->left), value->left = inc_zebu_multiplicative_expression(subgrammar);
free_zebu_multiplicative_expression(subgrammar);
}
		d = value, g = 12;
		break;
	}
	case 45:
	{
		struct zebu_multiplicative_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_multiplicative_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_prefix_expression(value->inner); value->inner = inc_zebu_prefix_expression(trie->inner); }
if (trie->left) { free_zebu_multiplicative_expression(value->left); value->left = inc_zebu_multiplicative_expression(trie->left); }
if (trie->right) { free_zebu_prefix_expression(value->right); value->right = inc_zebu_prefix_expression(trie->right); }
free_zebu_multiplicative_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_multiplicative_expression(value->left), value->left = inc_zebu_multiplicative_expression(subgrammar);
free_zebu_multiplicative_expression(subgrammar);
}
		d = value, g = 12;
		break;
	}
	case 14:
	{
		struct zebu_multiplicative_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_prefix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_prefix_expression(value->inner), value->inner = inc_zebu_prefix_expression(subgrammar);
free_zebu_prefix_expression(subgrammar);
}
		d = value, g = 12;
		break;
	}
	case 57:
	{
		struct zebu_prefix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_prefix_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->file) { free_zebu_expression(value->file); value->file = inc_zebu_expression(trie->file); }
if (trie->inner) { free_zebu_primary_expression(value->inner); value->inner = inc_zebu_primary_expression(trie->inner); }
if (trie->shell) { free_zebu_complex_command(value->shell); value->shell = inc_zebu_complex_command(trie->shell); }
if (trie->sub) { free_zebu_prefix_expression(value->sub); value->sub = inc_zebu_prefix_expression(trie->sub); }
free_zebu_prefix_expression(trie);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression(value->file), value->file = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 13;
		break;
	}
	case 58:
	{
		struct zebu_prefix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_prefix_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->file) { free_zebu_expression(value->file); value->file = inc_zebu_expression(trie->file); }
if (trie->inner) { free_zebu_primary_expression(value->inner); value->inner = inc_zebu_primary_expression(trie->inner); }
if (trie->shell) { free_zebu_complex_command(value->shell); value->shell = inc_zebu_complex_command(trie->shell); }
if (trie->sub) { free_zebu_prefix_expression(value->sub); value->sub = inc_zebu_prefix_expression(trie->sub); }
free_zebu_prefix_expression(trie);
}
{
struct zebu_complex_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_complex_command(value->shell), value->shell = inc_zebu_complex_command(subgrammar);
free_zebu_complex_command(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 13;
		break;
	}
	case 20:
	{
		struct zebu_prefix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_prefix_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->file) { free_zebu_expression(value->file); value->file = inc_zebu_expression(trie->file); }
if (trie->inner) { free_zebu_primary_expression(value->inner); value->inner = inc_zebu_primary_expression(trie->inner); }
if (trie->shell) { free_zebu_complex_command(value->shell); value->shell = inc_zebu_complex_command(trie->shell); }
if (trie->sub) { free_zebu_prefix_expression(value->sub); value->sub = inc_zebu_prefix_expression(trie->sub); }
free_zebu_prefix_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 13;
		break;
	}
	case 22:
	{
		struct zebu_prefix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_prefix_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->file) { free_zebu_expression(value->file); value->file = inc_zebu_expression(trie->file); }
if (trie->inner) { free_zebu_primary_expression(value->inner); value->inner = inc_zebu_primary_expression(trie->inner); }
if (trie->shell) { free_zebu_complex_command(value->shell); value->shell = inc_zebu_complex_command(trie->shell); }
if (trie->sub) { free_zebu_prefix_expression(value->sub); value->sub = inc_zebu_prefix_expression(trie->sub); }
free_zebu_prefix_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 13;
		break;
	}
	case 23:
	{
		struct zebu_prefix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_prefix_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->file) { free_zebu_expression(value->file); value->file = inc_zebu_expression(trie->file); }
if (trie->inner) { free_zebu_primary_expression(value->inner); value->inner = inc_zebu_primary_expression(trie->inner); }
if (trie->shell) { free_zebu_complex_command(value->shell); value->shell = inc_zebu_complex_command(trie->shell); }
if (trie->sub) { free_zebu_prefix_expression(value->sub); value->sub = inc_zebu_prefix_expression(trie->sub); }
free_zebu_prefix_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 13;
		break;
	}
	case 24:
	{
		struct zebu_prefix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_prefix_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->file) { free_zebu_expression(value->file); value->file = inc_zebu_expression(trie->file); }
if (trie->inner) { free_zebu_primary_expression(value->inner); value->inner = inc_zebu_primary_expression(trie->inner); }
if (trie->shell) { free_zebu_complex_command(value->shell); value->shell = inc_zebu_complex_command(trie->shell); }
if (trie->sub) { free_zebu_prefix_expression(value->sub); value->sub = inc_zebu_prefix_expression(trie->sub); }
free_zebu_prefix_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 13;
		break;
	}
	case 15:
	{
		struct zebu_prefix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_primary_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_primary_expression(value->inner), value->inner = inc_zebu_primary_expression(subgrammar);
free_zebu_primary_expression(subgrammar);
}
		d = value, g = 13;
		break;
	}
	case 1:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->string), value->string = inc_zebu_token(token);
free_zebu_token(token);
}
		d = value, g = 14;
		break;
	}
	case 28:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression(value->sub), value->sub = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 14;
		break;
	}
	case 2:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->integer), value->integer = inc_zebu_token(token);
free_zebu_token(token);
}
		d = value, g = 14;
		break;
	}
	case 46:
	{
		struct zebu_relational_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_relational_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_shift_expression(value->inner); value->inner = inc_zebu_shift_expression(trie->inner); }
if (trie->left) { free_zebu_relational_expression(value->left); value->left = inc_zebu_relational_expression(trie->left); }
if (trie->right) { free_zebu_shift_expression(value->right); value->right = inc_zebu_shift_expression(trie->right); }
free_zebu_relational_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_relational_expression(value->left), value->left = inc_zebu_relational_expression(subgrammar);
free_zebu_relational_expression(subgrammar);
}
		d = value, g = 15;
		break;
	}
	case 48:
	{
		struct zebu_relational_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_relational_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_shift_expression(value->inner); value->inner = inc_zebu_shift_expression(trie->inner); }
if (trie->left) { free_zebu_relational_expression(value->left); value->left = inc_zebu_relational_expression(trie->left); }
if (trie->right) { free_zebu_shift_expression(value->right); value->right = inc_zebu_shift_expression(trie->right); }
free_zebu_relational_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_relational_expression(value->left), value->left = inc_zebu_relational_expression(subgrammar);
free_zebu_relational_expression(subgrammar);
}
		d = value, g = 15;
		break;
	}
	case 49:
	{
		struct zebu_relational_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_relational_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_shift_expression(value->inner); value->inner = inc_zebu_shift_expression(trie->inner); }
if (trie->left) { free_zebu_relational_expression(value->left); value->left = inc_zebu_relational_expression(trie->left); }
if (trie->right) { free_zebu_shift_expression(value->right); value->right = inc_zebu_shift_expression(trie->right); }
free_zebu_relational_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_relational_expression(value->left), value->left = inc_zebu_relational_expression(subgrammar);
free_zebu_relational_expression(subgrammar);
}
		d = value, g = 15;
		break;
	}
	case 50:
	{
		struct zebu_relational_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_relational_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_shift_expression(value->inner); value->inner = inc_zebu_shift_expression(trie->inner); }
if (trie->left) { free_zebu_relational_expression(value->left); value->left = inc_zebu_relational_expression(trie->left); }
if (trie->right) { free_zebu_shift_expression(value->right); value->right = inc_zebu_shift_expression(trie->right); }
free_zebu_relational_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_relational_expression(value->left), value->left = inc_zebu_relational_expression(subgrammar);
free_zebu_relational_expression(subgrammar);
}
		d = value, g = 15;
		break;
	}
	case 18:
	{
		struct zebu_relational_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_shift_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_shift_expression(value->inner), value->inner = inc_zebu_shift_expression(subgrammar);
free_zebu_shift_expression(subgrammar);
}
		d = value, g = 15;
		break;
	}
	case 19:
	{
		struct zebu_root* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_test* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->tests.n == value->tests.cap)
{
value->tests.cap = value->tests.cap << 1 ?: 1;
value->tests.data = realloc(value->tests.data, sizeof(*value->tests.data) * value->tests.cap);
}
memmove(value->tests.data + 1, value->tests.data, sizeof(*value->tests.data) * value->tests.n);
value->tests.data[0] = inc_zebu_test(subgrammar), value->tests.n++;
free_zebu_test(subgrammar);
}
		d = value, g = 16;
		break;
	}
	case 54:
	{
		struct zebu_root* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_root* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->tests.n)
{
while (value->tests.n + trie->tests.n > value->tests.cap)
{
value->tests.cap = value->tests.cap << 1 ?: 1;
value->tests.data = realloc(value->tests.data, sizeof(*value->tests.data) * value->tests.cap);
}
memmove(value->tests.data + trie->tests.n, value->tests.data, sizeof(*value->tests.data) * value->tests.n);
for (unsigned i = 0, n = trie->tests.n; i < n; i++)
value->tests.data[i] = inc_zebu_test(trie->tests.data[i]);
value->tests.n += trie->tests.n;
}
free_zebu_root(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_test* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->tests.n == value->tests.cap)
{
value->tests.cap = value->tests.cap << 1 ?: 1;
value->tests.data = realloc(value->tests.data, sizeof(*value->tests.data) * value->tests.cap);
}
memmove(value->tests.data + 1, value->tests.data, sizeof(*value->tests.data) * value->tests.n);
value->tests.data[0] = inc_zebu_test(subgrammar), value->tests.n++;
free_zebu_test(subgrammar);
}
		d = value, g = 16;
		break;
	}
	case 3:
	{
		struct zebu_shift_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_additive_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_additive_expression(value->inner), value->inner = inc_zebu_additive_expression(subgrammar);
free_zebu_additive_expression(subgrammar);
}
		d = value, g = 17;
		break;
	}
	case 51:
	{
		struct zebu_shift_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_shift_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_additive_expression(value->inner); value->inner = inc_zebu_additive_expression(trie->inner); }
if (trie->left) { free_zebu_shift_expression(value->left); value->left = inc_zebu_shift_expression(trie->left); }
if (trie->right) { free_zebu_additive_expression(value->right); value->right = inc_zebu_additive_expression(trie->right); }
free_zebu_shift_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_shift_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_shift_expression(value->left), value->left = inc_zebu_shift_expression(subgrammar);
free_zebu_shift_expression(subgrammar);
}
		d = value, g = 17;
		break;
	}
	case 53:
	{
		struct zebu_shift_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_shift_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_additive_expression(value->inner); value->inner = inc_zebu_additive_expression(trie->inner); }
if (trie->left) { free_zebu_shift_expression(value->left); value->left = inc_zebu_shift_expression(trie->left); }
if (trie->right) { free_zebu_additive_expression(value->right); value->right = inc_zebu_additive_expression(trie->right); }
free_zebu_shift_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_shift_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_shift_expression(value->left), value->left = inc_zebu_shift_expression(subgrammar);
free_zebu_shift_expression(subgrammar);
}
		d = value, g = 17;
		break;
	}
	case 29:
	{
		struct zebu_simple_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_primary_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->args.n == value->args.cap)
{
value->args.cap = value->args.cap << 1 ?: 1;
value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
}
memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
value->args.data[0] = inc_zebu_primary_expression(subgrammar), value->args.n++;
free_zebu_primary_expression(subgrammar);
}
		d = value, g = 21;
		break;
	}
	case 59:
	{
		struct zebu_simple_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_simple_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->args.n)
{
while (value->args.n + trie->args.n > value->args.cap)
{
value->args.cap = value->args.cap << 1 ?: 1;
value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
}
memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
for (unsigned i = 0, n = trie->args.n; i < n; i++)
value->args.data[i] = inc_zebu_primary_expression(trie->args.data[i]);
value->args.n += trie->args.n;
}
free_zebu_simple_command(trie);
}
{
struct zebu_primary_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->args.n == value->args.cap)
{
value->args.cap = value->args.cap << 1 ?: 1;
value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
}
memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
value->args.data[0] = inc_zebu_primary_expression(subgrammar), value->args.n++;
free_zebu_primary_expression(subgrammar);
}
		d = value, g = 21;
		break;
	}
	case 5:
	{
		struct zebu_test* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->assertions.n == value->assertions.cap)
{
value->assertions.cap = value->assertions.cap << 1 ?: 1;
value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
}
memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
free_zebu_assertion(subgrammar);
}
		d = value, g = 18;
		break;
	}
	case 25:
	{
		struct zebu_test* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_test* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->assertions.n)
{
while (value->assertions.n + trie->assertions.n > value->assertions.cap)
{
value->assertions.cap = value->assertions.cap << 1 ?: 1;
value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
}
memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
value->assertions.n += trie->assertions.n;
}
if (trie->files.n)
{
while (value->files.n + trie->files.n > value->files.cap)
{
value->files.cap = value->files.cap << 1 ?: 1;
value->files.data = realloc(value->files.data, sizeof(*value->files.data) * value->files.cap);
}
memmove(value->files.data + trie->files.n, value->files.data, sizeof(*value->files.data) * value->files.n);
for (unsigned i = 0, n = trie->files.n; i < n; i++)
value->files.data[i] = inc_zebu_file(trie->files.data[i]);
value->files.n += trie->files.n;
}
free_zebu_test(trie);
}
{
struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->assertions.n == value->assertions.cap)
{
value->assertions.cap = value->assertions.cap << 1 ?: 1;
value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
}
memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
free_zebu_assertion(subgrammar);
}
		d = value, g = 18;
		break;
	}
	case 9:
	{
		struct zebu_test* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_file* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->files.n == value->files.cap)
{
value->files.cap = value->files.cap << 1 ?: 1;
value->files.data = realloc(value->files.data, sizeof(*value->files.data) * value->files.cap);
}
memmove(value->files.data + 1, value->files.data, sizeof(*value->files.data) * value->files.n);
value->files.data[0] = inc_zebu_file(subgrammar), value->files.n++;
free_zebu_file(subgrammar);
}
		d = value, g = 18;
		break;
	}
	case 27:
	{
		struct zebu_test* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_test* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->assertions.n)
{
while (value->assertions.n + trie->assertions.n > value->assertions.cap)
{
value->assertions.cap = value->assertions.cap << 1 ?: 1;
value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
}
memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
value->assertions.n += trie->assertions.n;
}
if (trie->files.n)
{
while (value->files.n + trie->files.n > value->files.cap)
{
value->files.cap = value->files.cap << 1 ?: 1;
value->files.data = realloc(value->files.data, sizeof(*value->files.data) * value->files.cap);
}
memmove(value->files.data + trie->files.n, value->files.data, sizeof(*value->files.data) * value->files.n);
for (unsigned i = 0, n = trie->files.n; i < n; i++)
value->files.data[i] = inc_zebu_file(trie->files.data[i]);
value->files.n += trie->files.n;
}
free_zebu_test(trie);
}
{
struct zebu_file* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->files.n == value->files.cap)
{
value->files.cap = value->files.cap << 1 ?: 1;
value->files.data = realloc(value->files.data, sizeof(*value->files.data) * value->files.cap);
}
memmove(value->files.data + 1, value->files.data, sizeof(*value->files.data) * value->files.n);
value->files.data[0] = inc_zebu_file(subgrammar), value->files.n++;
free_zebu_file(subgrammar);
}
		d = value, g = 18;
		break;
	}
}
			
			if (g == 32)
			{
				free_zebu_token(td);
				yacc.n = 0, root = d;
			}
			else
			{
				y = yacc.data[yacc.n - 1];
				
				#ifdef ZEBU_DEBUG
				ddprintf("y = %u\n", y);
				#endif
				
				assert(y < N(zebu_gotos) && g < N(*zebu_gotos));
				
				s = zebu_gotos[y][g];
				
				#ifdef ZEBU_DEBUG
				ddprintf("s = %u\n", s);
				#endif
				
				y = s, push_state(y), push_data(d);
			}
		}
		else
		{
			struct zebu_token* token = td;
			
			fprintf(stderr, "zebu: unexpected token '%.*s'!\n", token->len, token->data);
			
			exit(1);
		}
	}
	
	#ifdef ZEBU_DEBUG
	print_zebu_$start(NULL, p_root, "start", root);
	#endif
	
	free(yacc.data);
	free(data.data);
	free(lexer.data);
	
	return root;
}

















