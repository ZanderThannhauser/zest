#include "zebu.h"

#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif

#include <limits.h>
#include <stdarg.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <assert.h>
#include <stdio.h>
#include <errno.h>

const unsigned zebu_shifts[309][36] = {
	[1][2] = 2,
	[1][3] = 3,
	[1][4] = 4,
	[1][5] = 5,
	[1][6] = 6,
	[1][7] = 7,
	[1][8] = 8,
	[1][9] = 9,
	[1][10] = 10,
	[2][3] = 29,
	[2][11] = 30,
	[3][2] = 31,
	[3][3] = 32,
	[3][4] = 33,
	[3][5] = 34,
	[3][6] = 35,
	[3][7] = 36,
	[3][8] = 37,
	[3][9] = 38,
	[3][10] = 39,
	[5][3] = 54,
	[6][3] = 55,
	[7][2] = 56,
	[7][3] = 3,
	[7][4] = 4,
	[7][5] = 5,
	[7][6] = 6,
	[7][7] = 7,
	[7][8] = 8,
	[7][9] = 9,
	[7][10] = 10,
	[8][2] = 56,
	[8][3] = 3,
	[8][4] = 4,
	[8][5] = 5,
	[8][6] = 6,
	[8][7] = 7,
	[8][8] = 8,
	[8][9] = 9,
	[8][10] = 10,
	[9][2] = 56,
	[9][3] = 3,
	[9][4] = 4,
	[9][5] = 5,
	[9][6] = 6,
	[9][7] = 7,
	[9][8] = 8,
	[9][9] = 9,
	[9][10] = 10,
	[10][2] = 56,
	[10][3] = 3,
	[10][4] = 4,
	[10][5] = 5,
	[10][6] = 6,
	[10][7] = 7,
	[10][8] = 8,
	[10][9] = 9,
	[10][10] = 10,
	[11][8] = 62,
	[11][9] = 63,
	[12][25] = 64,
	[13][2] = 2,
	[13][3] = 3,
	[13][4] = 4,
	[13][5] = 5,
	[13][6] = 6,
	[13][7] = 7,
	[13][8] = 8,
	[13][9] = 9,
	[13][10] = 10,
	[15][23] = 66,
	[15][24] = 67,
	[16][26] = 68,
	[17][12] = 69,
	[18][2] = 2,
	[18][3] = 3,
	[18][4] = 4,
	[18][5] = 5,
	[18][6] = 6,
	[18][7] = 7,
	[18][8] = 8,
	[18][9] = 9,
	[18][10] = 10,
	[19][14] = 71,
	[20][27] = 72,
	[21][28] = 73,
	[21][29] = 74,
	[22][16] = 75,
	[22][17] = 76,
	[22][18] = 77,
	[25][13] = 78,
	[25][15] = 79,
	[25][21] = 80,
	[25][22] = 81,
	[27][19] = 82,
	[27][20] = 83,
	[28][30] = 84,
	[29][32] = 85,
	[29][33] = 86,
	[30][2] = 56,
	[30][3] = 3,
	[30][4] = 4,
	[30][5] = 5,
	[30][6] = 6,
	[30][7] = 7,
	[30][8] = 8,
	[30][9] = 9,
	[30][10] = 10,
	[32][2] = 31,
	[32][3] = 32,
	[32][4] = 33,
	[32][5] = 34,
	[32][6] = 35,
	[32][7] = 36,
	[32][8] = 37,
	[32][9] = 38,
	[32][10] = 39,
	[34][3] = 90,
	[35][3] = 91,
	[36][2] = 31,
	[36][3] = 32,
	[36][4] = 33,
	[36][5] = 34,
	[36][6] = 35,
	[36][7] = 36,
	[36][8] = 37,
	[36][9] = 38,
	[36][10] = 39,
	[37][2] = 31,
	[37][3] = 32,
	[37][4] = 33,
	[37][5] = 34,
	[37][6] = 35,
	[37][7] = 36,
	[37][8] = 37,
	[37][9] = 38,
	[37][10] = 39,
	[38][2] = 31,
	[38][3] = 32,
	[38][4] = 33,
	[38][5] = 34,
	[38][6] = 35,
	[38][7] = 36,
	[38][8] = 37,
	[38][9] = 38,
	[38][10] = 39,
	[39][2] = 31,
	[39][3] = 32,
	[39][4] = 33,
	[39][5] = 34,
	[39][6] = 35,
	[39][7] = 36,
	[39][8] = 37,
	[39][9] = 38,
	[39][10] = 39,
	[40][8] = 97,
	[40][9] = 98,
	[41][25] = 99,
	[43][23] = 100,
	[43][24] = 101,
	[44][26] = 102,
	[45][34] = 103,
	[46][14] = 104,
	[47][27] = 105,
	[48][28] = 106,
	[48][29] = 107,
	[49][16] = 108,
	[49][17] = 109,
	[49][18] = 110,
	[52][13] = 111,
	[52][15] = 112,
	[52][21] = 113,
	[52][22] = 114,
	[53][19] = 115,
	[53][20] = 116,
	[54][2] = 31,
	[54][3] = 32,
	[54][4] = 33,
	[54][5] = 34,
	[54][6] = 35,
	[54][7] = 36,
	[54][8] = 37,
	[54][9] = 38,
	[54][10] = 39,
	[55][2] = 118,
	[55][3] = 119,
	[55][4] = 120,
	[62][2] = 56,
	[62][3] = 3,
	[62][4] = 4,
	[62][5] = 5,
	[62][6] = 6,
	[62][7] = 7,
	[62][8] = 8,
	[62][9] = 9,
	[62][10] = 10,
	[63][2] = 56,
	[63][3] = 3,
	[63][4] = 4,
	[63][5] = 5,
	[63][6] = 6,
	[63][7] = 7,
	[63][8] = 8,
	[63][9] = 9,
	[63][10] = 10,
	[64][2] = 56,
	[64][3] = 3,
	[64][4] = 4,
	[64][5] = 5,
	[64][6] = 6,
	[64][7] = 7,
	[64][8] = 8,
	[64][9] = 9,
	[64][10] = 10,
	[66][2] = 56,
	[66][3] = 3,
	[66][4] = 4,
	[66][5] = 5,
	[66][6] = 6,
	[66][7] = 7,
	[66][8] = 8,
	[66][9] = 9,
	[66][10] = 10,
	[67][2] = 56,
	[67][3] = 3,
	[67][4] = 4,
	[67][5] = 5,
	[67][6] = 6,
	[67][7] = 7,
	[67][8] = 8,
	[67][9] = 9,
	[67][10] = 10,
	[68][2] = 56,
	[68][3] = 3,
	[68][4] = 4,
	[68][5] = 5,
	[68][6] = 6,
	[68][7] = 7,
	[68][8] = 8,
	[68][9] = 9,
	[68][10] = 10,
	[71][2] = 56,
	[71][3] = 3,
	[71][4] = 4,
	[71][5] = 5,
	[71][6] = 6,
	[71][7] = 7,
	[71][8] = 8,
	[71][9] = 9,
	[71][10] = 10,
	[72][2] = 56,
	[72][3] = 3,
	[72][4] = 4,
	[72][5] = 5,
	[72][6] = 6,
	[72][7] = 7,
	[72][8] = 8,
	[72][9] = 9,
	[72][10] = 10,
	[73][2] = 56,
	[73][3] = 3,
	[73][4] = 4,
	[73][5] = 5,
	[73][6] = 6,
	[73][7] = 7,
	[73][8] = 8,
	[73][9] = 9,
	[73][10] = 10,
	[74][2] = 135,
	[74][3] = 136,
	[74][4] = 137,
	[74][5] = 138,
	[74][6] = 139,
	[74][7] = 140,
	[74][8] = 141,
	[74][9] = 142,
	[74][10] = 143,
	[75][2] = 56,
	[75][3] = 3,
	[75][4] = 4,
	[75][5] = 5,
	[75][6] = 6,
	[75][7] = 7,
	[75][8] = 8,
	[75][9] = 9,
	[75][10] = 10,
	[76][2] = 56,
	[76][3] = 3,
	[76][4] = 4,
	[76][5] = 5,
	[76][6] = 6,
	[76][7] = 7,
	[76][8] = 8,
	[76][9] = 9,
	[76][10] = 10,
	[77][2] = 56,
	[77][3] = 3,
	[77][4] = 4,
	[77][5] = 5,
	[77][6] = 6,
	[77][7] = 7,
	[77][8] = 8,
	[77][9] = 9,
	[77][10] = 10,
	[78][2] = 56,
	[78][3] = 3,
	[78][4] = 4,
	[78][5] = 5,
	[78][6] = 6,
	[78][7] = 7,
	[78][8] = 8,
	[78][9] = 9,
	[78][10] = 10,
	[79][2] = 56,
	[79][3] = 3,
	[79][4] = 4,
	[79][5] = 5,
	[79][6] = 6,
	[79][7] = 7,
	[79][8] = 8,
	[79][9] = 9,
	[79][10] = 10,
	[80][2] = 56,
	[80][3] = 3,
	[80][4] = 4,
	[80][5] = 5,
	[80][6] = 6,
	[80][7] = 7,
	[80][8] = 8,
	[80][9] = 9,
	[80][10] = 10,
	[81][2] = 56,
	[81][3] = 3,
	[81][4] = 4,
	[81][5] = 5,
	[81][6] = 6,
	[81][7] = 7,
	[81][8] = 8,
	[81][9] = 9,
	[81][10] = 10,
	[82][2] = 56,
	[82][3] = 3,
	[82][4] = 4,
	[82][5] = 5,
	[82][6] = 6,
	[82][7] = 7,
	[82][8] = 8,
	[82][9] = 9,
	[82][10] = 10,
	[83][2] = 56,
	[83][3] = 3,
	[83][4] = 4,
	[83][5] = 5,
	[83][6] = 6,
	[83][7] = 7,
	[83][8] = 8,
	[83][9] = 9,
	[83][10] = 10,
	[84][2] = 2,
	[84][3] = 3,
	[84][4] = 4,
	[84][5] = 5,
	[84][6] = 6,
	[84][7] = 7,
	[84][8] = 8,
	[84][9] = 9,
	[84][10] = 10,
	[85][34] = 172,
	[85][35] = 171,
	[86][34] = 174,
	[88][12] = 175,
	[89][34] = 176,
	[90][2] = 31,
	[90][3] = 32,
	[90][4] = 33,
	[90][5] = 34,
	[90][6] = 35,
	[90][7] = 36,
	[90][8] = 37,
	[90][9] = 38,
	[90][10] = 39,
	[91][2] = 118,
	[91][3] = 119,
	[91][4] = 120,
	[97][2] = 31,
	[97][3] = 32,
	[97][4] = 33,
	[97][5] = 34,
	[97][6] = 35,
	[97][7] = 36,
	[97][8] = 37,
	[97][9] = 38,
	[97][10] = 39,
	[98][2] = 31,
	[98][3] = 32,
	[98][4] = 33,
	[98][5] = 34,
	[98][6] = 35,
	[98][7] = 36,
	[98][8] = 37,
	[98][9] = 38,
	[98][10] = 39,
	[99][2] = 31,
	[99][3] = 32,
	[99][4] = 33,
	[99][5] = 34,
	[99][6] = 35,
	[99][7] = 36,
	[99][8] = 37,
	[99][9] = 38,
	[99][10] = 39,
	[100][2] = 31,
	[100][3] = 32,
	[100][4] = 33,
	[100][5] = 34,
	[100][6] = 35,
	[100][7] = 36,
	[100][8] = 37,
	[100][9] = 38,
	[100][10] = 39,
	[101][2] = 31,
	[101][3] = 32,
	[101][4] = 33,
	[101][5] = 34,
	[101][6] = 35,
	[101][7] = 36,
	[101][8] = 37,
	[101][9] = 38,
	[101][10] = 39,
	[102][2] = 31,
	[102][3] = 32,
	[102][4] = 33,
	[102][5] = 34,
	[102][6] = 35,
	[102][7] = 36,
	[102][8] = 37,
	[102][9] = 38,
	[102][10] = 39,
	[104][2] = 31,
	[104][3] = 32,
	[104][4] = 33,
	[104][5] = 34,
	[104][6] = 35,
	[104][7] = 36,
	[104][8] = 37,
	[104][9] = 38,
	[104][10] = 39,
	[105][2] = 31,
	[105][3] = 32,
	[105][4] = 33,
	[105][5] = 34,
	[105][6] = 35,
	[105][7] = 36,
	[105][8] = 37,
	[105][9] = 38,
	[105][10] = 39,
	[106][2] = 31,
	[106][3] = 32,
	[106][4] = 33,
	[106][5] = 34,
	[106][6] = 35,
	[106][7] = 36,
	[106][8] = 37,
	[106][9] = 38,
	[106][10] = 39,
	[107][2] = 135,
	[107][3] = 136,
	[107][4] = 137,
	[107][5] = 138,
	[107][6] = 139,
	[107][7] = 140,
	[107][8] = 141,
	[107][9] = 142,
	[107][10] = 143,
	[108][2] = 31,
	[108][3] = 32,
	[108][4] = 33,
	[108][5] = 34,
	[108][6] = 35,
	[108][7] = 36,
	[108][8] = 37,
	[108][9] = 38,
	[108][10] = 39,
	[109][2] = 31,
	[109][3] = 32,
	[109][4] = 33,
	[109][5] = 34,
	[109][6] = 35,
	[109][7] = 36,
	[109][8] = 37,
	[109][9] = 38,
	[109][10] = 39,
	[110][2] = 31,
	[110][3] = 32,
	[110][4] = 33,
	[110][5] = 34,
	[110][6] = 35,
	[110][7] = 36,
	[110][8] = 37,
	[110][9] = 38,
	[110][10] = 39,
	[111][2] = 31,
	[111][3] = 32,
	[111][4] = 33,
	[111][5] = 34,
	[111][6] = 35,
	[111][7] = 36,
	[111][8] = 37,
	[111][9] = 38,
	[111][10] = 39,
	[112][2] = 31,
	[112][3] = 32,
	[112][4] = 33,
	[112][5] = 34,
	[112][6] = 35,
	[112][7] = 36,
	[112][8] = 37,
	[112][9] = 38,
	[112][10] = 39,
	[113][2] = 31,
	[113][3] = 32,
	[113][4] = 33,
	[113][5] = 34,
	[113][6] = 35,
	[113][7] = 36,
	[113][8] = 37,
	[113][9] = 38,
	[113][10] = 39,
	[114][2] = 31,
	[114][3] = 32,
	[114][4] = 33,
	[114][5] = 34,
	[114][6] = 35,
	[114][7] = 36,
	[114][8] = 37,
	[114][9] = 38,
	[114][10] = 39,
	[115][2] = 31,
	[115][3] = 32,
	[115][4] = 33,
	[115][5] = 34,
	[115][6] = 35,
	[115][7] = 36,
	[115][8] = 37,
	[115][9] = 38,
	[115][10] = 39,
	[116][2] = 31,
	[116][3] = 32,
	[116][4] = 33,
	[116][5] = 34,
	[116][6] = 35,
	[116][7] = 36,
	[116][8] = 37,
	[116][9] = 38,
	[116][10] = 39,
	[117][34] = 203,
	[119][2] = 31,
	[119][3] = 32,
	[119][4] = 33,
	[119][5] = 34,
	[119][6] = 35,
	[119][7] = 36,
	[119][8] = 37,
	[119][9] = 38,
	[119][10] = 39,
	[121][34] = 203,
	[122][2] = 118,
	[122][3] = 119,
	[122][4] = 120,
	[123][13] = 209,
	[123][14] = 210,
	[123][15] = 211,
	[125][16] = 75,
	[125][17] = 76,
	[125][18] = 77,
	[127][23] = 66,
	[127][24] = 67,
	[129][13] = 78,
	[129][15] = 79,
	[129][21] = 80,
	[129][22] = 81,
	[131][25] = 64,
	[132][26] = 68,
	[133][14] = 71,
	[134][27] = 72,
	[136][2] = 31,
	[136][3] = 32,
	[136][4] = 33,
	[136][5] = 34,
	[136][6] = 35,
	[136][7] = 36,
	[136][8] = 37,
	[136][9] = 38,
	[136][10] = 39,
	[138][3] = 213,
	[139][3] = 214,
	[140][2] = 135,
	[140][3] = 136,
	[140][4] = 137,
	[140][5] = 138,
	[140][6] = 139,
	[140][7] = 140,
	[140][8] = 141,
	[140][9] = 142,
	[140][10] = 143,
	[141][2] = 135,
	[141][3] = 136,
	[141][4] = 137,
	[141][5] = 138,
	[141][6] = 139,
	[141][7] = 140,
	[141][8] = 141,
	[141][9] = 142,
	[141][10] = 143,
	[142][2] = 135,
	[142][3] = 136,
	[142][4] = 137,
	[142][5] = 138,
	[142][6] = 139,
	[142][7] = 140,
	[142][8] = 141,
	[142][9] = 142,
	[142][10] = 143,
	[143][2] = 135,
	[143][3] = 136,
	[143][4] = 137,
	[143][5] = 138,
	[143][6] = 139,
	[143][7] = 140,
	[143][8] = 141,
	[143][9] = 142,
	[143][10] = 143,
	[144][8] = 220,
	[144][9] = 221,
	[145][25] = 222,
	[147][23] = 223,
	[147][24] = 224,
	[148][26] = 225,
	[149][11] = 226,
	[150][14] = 227,
	[151][27] = 228,
	[152][28] = 229,
	[152][29] = 230,
	[153][16] = 231,
	[153][17] = 232,
	[153][18] = 233,
	[156][13] = 234,
	[156][15] = 235,
	[156][21] = 236,
	[156][22] = 237,
	[157][19] = 238,
	[157][20] = 239,
	[163][19] = 82,
	[163][20] = 83,
	[168][8] = 62,
	[168][9] = 63,
	[171][32] = 240,
	[172][11] = 241,
	[174][11] = 241,
	[177][34] = 244,
	[178][34] = 244,
	[180][16] = 108,
	[180][17] = 109,
	[180][18] = 110,
	[182][23] = 100,
	[182][24] = 101,
	[184][13] = 111,
	[184][15] = 112,
	[184][21] = 113,
	[184][22] = 114,
	[186][25] = 99,
	[187][26] = 102,
	[188][14] = 104,
	[189][27] = 105,
	[190][11] = 247,
	[196][19] = 115,
	[196][20] = 116,
	[201][8] = 97,
	[201][9] = 98,
	[205][34] = 248,
	[208][2] = 118,
	[208][3] = 119,
	[208][4] = 120,
	[209][2] = 250,
	[209][3] = 251,
	[209][4] = 252,
	[210][2] = 254,
	[210][3] = 255,
	[210][4] = 256,
	[211][2] = 260,
	[211][3] = 261,
	[211][4] = 262,
	[212][34] = 265,
	[213][2] = 31,
	[213][3] = 32,
	[213][4] = 33,
	[213][5] = 34,
	[213][6] = 35,
	[213][7] = 36,
	[213][8] = 37,
	[213][9] = 38,
	[213][10] = 39,
	[214][2] = 118,
	[214][3] = 119,
	[214][4] = 120,
	[220][2] = 135,
	[220][3] = 136,
	[220][4] = 137,
	[220][5] = 138,
	[220][6] = 139,
	[220][7] = 140,
	[220][8] = 141,
	[220][9] = 142,
	[220][10] = 143,
	[221][2] = 135,
	[221][3] = 136,
	[221][4] = 137,
	[221][5] = 138,
	[221][6] = 139,
	[221][7] = 140,
	[221][8] = 141,
	[221][9] = 142,
	[221][10] = 143,
	[222][2] = 135,
	[222][3] = 136,
	[222][4] = 137,
	[222][5] = 138,
	[222][6] = 139,
	[222][7] = 140,
	[222][8] = 141,
	[222][9] = 142,
	[222][10] = 143,
	[223][2] = 135,
	[223][3] = 136,
	[223][4] = 137,
	[223][5] = 138,
	[223][6] = 139,
	[223][7] = 140,
	[223][8] = 141,
	[223][9] = 142,
	[223][10] = 143,
	[224][2] = 135,
	[224][3] = 136,
	[224][4] = 137,
	[224][5] = 138,
	[224][6] = 139,
	[224][7] = 140,
	[224][8] = 141,
	[224][9] = 142,
	[224][10] = 143,
	[225][2] = 135,
	[225][3] = 136,
	[225][4] = 137,
	[225][5] = 138,
	[225][6] = 139,
	[225][7] = 140,
	[225][8] = 141,
	[225][9] = 142,
	[225][10] = 143,
	[226][2] = 56,
	[226][3] = 3,
	[226][4] = 4,
	[226][5] = 5,
	[226][6] = 6,
	[226][7] = 7,
	[226][8] = 8,
	[226][9] = 9,
	[226][10] = 10,
	[227][2] = 135,
	[227][3] = 136,
	[227][4] = 137,
	[227][5] = 138,
	[227][6] = 139,
	[227][7] = 140,
	[227][8] = 141,
	[227][9] = 142,
	[227][10] = 143,
	[228][2] = 135,
	[228][3] = 136,
	[228][4] = 137,
	[228][5] = 138,
	[228][6] = 139,
	[228][7] = 140,
	[228][8] = 141,
	[228][9] = 142,
	[228][10] = 143,
	[229][2] = 135,
	[229][3] = 136,
	[229][4] = 137,
	[229][5] = 138,
	[229][6] = 139,
	[229][7] = 140,
	[229][8] = 141,
	[229][9] = 142,
	[229][10] = 143,
	[230][2] = 135,
	[230][3] = 136,
	[230][4] = 137,
	[230][5] = 138,
	[230][6] = 139,
	[230][7] = 140,
	[230][8] = 141,
	[230][9] = 142,
	[230][10] = 143,
	[231][2] = 135,
	[231][3] = 136,
	[231][4] = 137,
	[231][5] = 138,
	[231][6] = 139,
	[231][7] = 140,
	[231][8] = 141,
	[231][9] = 142,
	[231][10] = 143,
	[232][2] = 135,
	[232][3] = 136,
	[232][4] = 137,
	[232][5] = 138,
	[232][6] = 139,
	[232][7] = 140,
	[232][8] = 141,
	[232][9] = 142,
	[232][10] = 143,
	[233][2] = 135,
	[233][3] = 136,
	[233][4] = 137,
	[233][5] = 138,
	[233][6] = 139,
	[233][7] = 140,
	[233][8] = 141,
	[233][9] = 142,
	[233][10] = 143,
	[234][2] = 135,
	[234][3] = 136,
	[234][4] = 137,
	[234][5] = 138,
	[234][6] = 139,
	[234][7] = 140,
	[234][8] = 141,
	[234][9] = 142,
	[234][10] = 143,
	[235][2] = 135,
	[235][3] = 136,
	[235][4] = 137,
	[235][5] = 138,
	[235][6] = 139,
	[235][7] = 140,
	[235][8] = 141,
	[235][9] = 142,
	[235][10] = 143,
	[236][2] = 135,
	[236][3] = 136,
	[236][4] = 137,
	[236][5] = 138,
	[236][6] = 139,
	[236][7] = 140,
	[236][8] = 141,
	[236][9] = 142,
	[236][10] = 143,
	[237][2] = 135,
	[237][3] = 136,
	[237][4] = 137,
	[237][5] = 138,
	[237][6] = 139,
	[237][7] = 140,
	[237][8] = 141,
	[237][9] = 142,
	[237][10] = 143,
	[238][2] = 135,
	[238][3] = 136,
	[238][4] = 137,
	[238][5] = 138,
	[238][6] = 139,
	[238][7] = 140,
	[238][8] = 141,
	[238][9] = 142,
	[238][10] = 143,
	[239][2] = 135,
	[239][3] = 136,
	[239][4] = 137,
	[239][5] = 138,
	[239][6] = 139,
	[239][7] = 140,
	[239][8] = 141,
	[239][9] = 142,
	[239][10] = 143,
	[240][34] = 172,
	[240][35] = 171,
	[241][2] = 56,
	[241][3] = 3,
	[241][4] = 4,
	[241][5] = 5,
	[241][6] = 6,
	[241][7] = 7,
	[241][8] = 8,
	[241][9] = 9,
	[241][10] = 10,
	[247][2] = 31,
	[247][3] = 32,
	[247][4] = 33,
	[247][5] = 34,
	[247][6] = 35,
	[247][7] = 36,
	[247][8] = 37,
	[247][9] = 38,
	[247][10] = 39,
	[251][2] = 31,
	[251][3] = 32,
	[251][4] = 33,
	[251][5] = 34,
	[251][6] = 35,
	[251][7] = 36,
	[251][8] = 37,
	[251][9] = 38,
	[251][10] = 39,
	[253][14] = 297,
	[253][15] = 298,
	[255][2] = 31,
	[255][3] = 32,
	[255][4] = 33,
	[255][5] = 34,
	[255][6] = 35,
	[255][7] = 36,
	[255][8] = 37,
	[255][9] = 38,
	[255][10] = 39,
	[258][2] = 254,
	[258][3] = 255,
	[258][4] = 256,
	[259][14] = 297,
	[259][15] = 298,
	[261][2] = 31,
	[261][3] = 32,
	[261][4] = 33,
	[261][5] = 34,
	[261][6] = 35,
	[261][7] = 36,
	[261][8] = 37,
	[261][9] = 38,
	[261][10] = 39,
	[266][34] = 305,
	[267][34] = 305,
	[269][16] = 231,
	[269][17] = 232,
	[269][18] = 233,
	[271][23] = 223,
	[271][24] = 224,
	[273][13] = 234,
	[273][15] = 235,
	[273][21] = 236,
	[273][22] = 237,
	[275][25] = 222,
	[277][26] = 225,
	[278][14] = 227,
	[279][27] = 228,
	[280][11] = 308,
	[286][19] = 238,
	[286][20] = 239,
	[291][8] = 220,
	[291][9] = 221,
	[296][34] = 309,
	[297][2] = 254,
	[297][3] = 255,
	[297][4] = 256,
	[298][2] = 260,
	[298][3] = 261,
	[298][4] = 262,
	[300][34] = 312,
	[302][2] = 254,
	[302][3] = 255,
	[302][4] = 256,
	[304][34] = 314,
	[308][2] = 135,
	[308][3] = 136,
	[308][4] = 137,
	[308][5] = 138,
	[308][6] = 139,
	[308][7] = 140,
	[308][8] = 141,
	[308][9] = 142,
	[308][10] = 143,
};


const unsigned zebu_reduces[316][35] = {
	[2][8] = 1,
	[2][9] = 1,
	[2][12] = 1,
	[2][13] = 1,
	[2][14] = 1,
	[2][15] = 1,
	[2][16] = 1,
	[2][17] = 1,
	[2][18] = 1,
	[2][19] = 1,
	[2][20] = 1,
	[2][21] = 1,
	[2][22] = 1,
	[2][23] = 1,
	[2][24] = 1,
	[2][25] = 1,
	[2][26] = 1,
	[2][27] = 1,
	[2][28] = 1,
	[2][29] = 1,
	[4][8] = 2,
	[4][9] = 2,
	[4][12] = 2,
	[4][13] = 2,
	[4][14] = 2,
	[4][15] = 2,
	[4][16] = 2,
	[4][17] = 2,
	[4][18] = 2,
	[4][19] = 2,
	[4][20] = 2,
	[4][21] = 2,
	[4][22] = 2,
	[4][23] = 2,
	[4][24] = 2,
	[4][25] = 2,
	[4][26] = 2,
	[4][27] = 2,
	[4][28] = 2,
	[4][29] = 2,
	[11][12] = 3,
	[11][13] = 3,
	[11][14] = 3,
	[11][15] = 3,
	[11][19] = 3,
	[11][20] = 3,
	[11][21] = 3,
	[11][22] = 3,
	[11][23] = 3,
	[11][24] = 3,
	[11][25] = 3,
	[11][26] = 3,
	[11][27] = 3,
	[11][28] = 3,
	[11][29] = 3,
	[12][12] = 4,
	[12][14] = 4,
	[12][26] = 4,
	[12][27] = 4,
	[12][28] = 4,
	[12][29] = 4,
	[13][30] = 5,
	[13][31] = 5,
	[14][12] = 6,
	[15][12] = 7,
	[15][14] = 7,
	[15][25] = 7,
	[15][26] = 7,
	[15][27] = 7,
	[15][28] = 7,
	[15][29] = 7,
	[16][12] = 8,
	[16][14] = 8,
	[16][27] = 8,
	[16][28] = 8,
	[16][29] = 8,
	[18][30] = 9,
	[18][31] = 9,
	[19][12] = 10,
	[19][27] = 10,
	[19][28] = 10,
	[19][29] = 10,
	[20][12] = 11,
	[20][28] = 11,
	[20][29] = 11,
	[21][12] = 12,
	[22][8] = 13,
	[22][9] = 13,
	[22][12] = 13,
	[22][13] = 13,
	[22][14] = 13,
	[22][15] = 13,
	[22][19] = 13,
	[22][20] = 13,
	[22][21] = 13,
	[22][22] = 13,
	[22][23] = 13,
	[22][24] = 13,
	[22][25] = 13,
	[22][26] = 13,
	[22][27] = 13,
	[22][28] = 13,
	[22][29] = 13,
	[23][8] = 14,
	[23][9] = 14,
	[23][12] = 14,
	[23][13] = 14,
	[23][14] = 14,
	[23][15] = 14,
	[23][16] = 14,
	[23][17] = 14,
	[23][18] = 14,
	[23][19] = 14,
	[23][20] = 14,
	[23][21] = 14,
	[23][22] = 14,
	[23][23] = 14,
	[23][24] = 14,
	[23][25] = 14,
	[23][26] = 14,
	[23][27] = 14,
	[23][28] = 14,
	[23][29] = 14,
	[24][8] = 15,
	[24][9] = 15,
	[24][12] = 15,
	[24][13] = 15,
	[24][14] = 15,
	[24][15] = 15,
	[24][16] = 15,
	[24][17] = 15,
	[24][18] = 15,
	[24][19] = 15,
	[24][20] = 15,
	[24][21] = 15,
	[24][22] = 15,
	[24][23] = 15,
	[24][24] = 15,
	[24][25] = 15,
	[24][26] = 15,
	[24][27] = 15,
	[24][28] = 15,
	[24][29] = 15,
	[25][12] = 16,
	[25][14] = 16,
	[25][23] = 16,
	[25][24] = 16,
	[25][25] = 16,
	[25][26] = 16,
	[25][27] = 16,
	[25][28] = 16,
	[25][29] = 16,
	[26][31] = 17,
	[27][12] = 18,
	[27][13] = 18,
	[27][14] = 18,
	[27][15] = 18,
	[27][21] = 18,
	[27][22] = 18,
	[27][23] = 18,
	[27][24] = 18,
	[27][25] = 18,
	[27][26] = 18,
	[27][27] = 18,
	[27][28] = 18,
	[27][29] = 18,
	[28][31] = 19,
	[31][8] = 1,
	[31][9] = 1,
	[31][13] = 1,
	[31][14] = 1,
	[31][15] = 1,
	[31][16] = 1,
	[31][17] = 1,
	[31][18] = 1,
	[31][19] = 1,
	[31][20] = 1,
	[31][21] = 1,
	[31][22] = 1,
	[31][23] = 1,
	[31][24] = 1,
	[31][25] = 1,
	[31][26] = 1,
	[31][27] = 1,
	[31][28] = 1,
	[31][29] = 1,
	[31][34] = 1,
	[33][8] = 2,
	[33][9] = 2,
	[33][13] = 2,
	[33][14] = 2,
	[33][15] = 2,
	[33][16] = 2,
	[33][17] = 2,
	[33][18] = 2,
	[33][19] = 2,
	[33][20] = 2,
	[33][21] = 2,
	[33][22] = 2,
	[33][23] = 2,
	[33][24] = 2,
	[33][25] = 2,
	[33][26] = 2,
	[33][27] = 2,
	[33][28] = 2,
	[33][29] = 2,
	[33][34] = 2,
	[40][13] = 3,
	[40][14] = 3,
	[40][15] = 3,
	[40][19] = 3,
	[40][20] = 3,
	[40][21] = 3,
	[40][22] = 3,
	[40][23] = 3,
	[40][24] = 3,
	[40][25] = 3,
	[40][26] = 3,
	[40][27] = 3,
	[40][28] = 3,
	[40][29] = 3,
	[40][34] = 3,
	[41][14] = 4,
	[41][26] = 4,
	[41][27] = 4,
	[41][28] = 4,
	[41][29] = 4,
	[41][34] = 4,
	[42][34] = 6,
	[43][14] = 7,
	[43][25] = 7,
	[43][26] = 7,
	[43][27] = 7,
	[43][28] = 7,
	[43][29] = 7,
	[43][34] = 7,
	[44][14] = 8,
	[44][27] = 8,
	[44][28] = 8,
	[44][29] = 8,
	[44][34] = 8,
	[46][27] = 10,
	[46][28] = 10,
	[46][29] = 10,
	[46][34] = 10,
	[47][28] = 11,
	[47][29] = 11,
	[47][34] = 11,
	[48][34] = 12,
	[49][8] = 13,
	[49][9] = 13,
	[49][13] = 13,
	[49][14] = 13,
	[49][15] = 13,
	[49][19] = 13,
	[49][20] = 13,
	[49][21] = 13,
	[49][22] = 13,
	[49][23] = 13,
	[49][24] = 13,
	[49][25] = 13,
	[49][26] = 13,
	[49][27] = 13,
	[49][28] = 13,
	[49][29] = 13,
	[49][34] = 13,
	[50][8] = 14,
	[50][9] = 14,
	[50][13] = 14,
	[50][14] = 14,
	[50][15] = 14,
	[50][16] = 14,
	[50][17] = 14,
	[50][18] = 14,
	[50][19] = 14,
	[50][20] = 14,
	[50][21] = 14,
	[50][22] = 14,
	[50][23] = 14,
	[50][24] = 14,
	[50][25] = 14,
	[50][26] = 14,
	[50][27] = 14,
	[50][28] = 14,
	[50][29] = 14,
	[50][34] = 14,
	[51][8] = 15,
	[51][9] = 15,
	[51][13] = 15,
	[51][14] = 15,
	[51][15] = 15,
	[51][16] = 15,
	[51][17] = 15,
	[51][18] = 15,
	[51][19] = 15,
	[51][20] = 15,
	[51][21] = 15,
	[51][22] = 15,
	[51][23] = 15,
	[51][24] = 15,
	[51][25] = 15,
	[51][26] = 15,
	[51][27] = 15,
	[51][28] = 15,
	[51][29] = 15,
	[51][34] = 15,
	[52][14] = 16,
	[52][23] = 16,
	[52][24] = 16,
	[52][25] = 16,
	[52][26] = 16,
	[52][27] = 16,
	[52][28] = 16,
	[52][29] = 16,
	[52][34] = 16,
	[53][13] = 18,
	[53][14] = 18,
	[53][15] = 18,
	[53][21] = 18,
	[53][22] = 18,
	[53][23] = 18,
	[53][24] = 18,
	[53][25] = 18,
	[53][26] = 18,
	[53][27] = 18,
	[53][28] = 18,
	[53][29] = 18,
	[53][34] = 18,
	[56][8] = 1,
	[56][9] = 1,
	[56][12] = 1,
	[56][13] = 1,
	[56][14] = 1,
	[56][15] = 1,
	[56][16] = 1,
	[56][17] = 1,
	[56][18] = 1,
	[56][19] = 1,
	[56][20] = 1,
	[56][21] = 1,
	[56][22] = 1,
	[56][23] = 1,
	[56][24] = 1,
	[56][25] = 1,
	[56][26] = 1,
	[56][27] = 1,
	[56][28] = 1,
	[56][29] = 1,
	[57][8] = 20,
	[57][9] = 20,
	[57][12] = 20,
	[57][13] = 20,
	[57][14] = 20,
	[57][15] = 20,
	[57][16] = 20,
	[57][17] = 20,
	[57][18] = 20,
	[57][19] = 20,
	[57][20] = 20,
	[57][21] = 20,
	[57][22] = 20,
	[57][23] = 20,
	[57][24] = 20,
	[57][25] = 20,
	[57][26] = 20,
	[57][27] = 20,
	[57][28] = 20,
	[57][29] = 20,
	[58][8] = 21,
	[58][9] = 21,
	[58][12] = 21,
	[58][13] = 21,
	[58][14] = 21,
	[58][15] = 21,
	[58][16] = 21,
	[58][17] = 21,
	[58][18] = 21,
	[58][19] = 21,
	[58][20] = 21,
	[58][21] = 21,
	[58][22] = 21,
	[58][23] = 21,
	[58][24] = 21,
	[58][25] = 21,
	[58][26] = 21,
	[58][27] = 21,
	[58][28] = 21,
	[58][29] = 21,
	[59][8] = 22,
	[59][9] = 22,
	[59][12] = 22,
	[59][13] = 22,
	[59][14] = 22,
	[59][15] = 22,
	[59][16] = 22,
	[59][17] = 22,
	[59][18] = 22,
	[59][19] = 22,
	[59][20] = 22,
	[59][21] = 22,
	[59][22] = 22,
	[59][23] = 22,
	[59][24] = 22,
	[59][25] = 22,
	[59][26] = 22,
	[59][27] = 22,
	[59][28] = 22,
	[59][29] = 22,
	[60][8] = 23,
	[60][9] = 23,
	[60][12] = 23,
	[60][13] = 23,
	[60][14] = 23,
	[60][15] = 23,
	[60][16] = 23,
	[60][17] = 23,
	[60][18] = 23,
	[60][19] = 23,
	[60][20] = 23,
	[60][21] = 23,
	[60][22] = 23,
	[60][23] = 23,
	[60][24] = 23,
	[60][25] = 23,
	[60][26] = 23,
	[60][27] = 23,
	[60][28] = 23,
	[60][29] = 23,
	[61][8] = 24,
	[61][9] = 24,
	[61][12] = 24,
	[61][13] = 24,
	[61][14] = 24,
	[61][15] = 24,
	[61][16] = 24,
	[61][17] = 24,
	[61][18] = 24,
	[61][19] = 24,
	[61][20] = 24,
	[61][21] = 24,
	[61][22] = 24,
	[61][23] = 24,
	[61][24] = 24,
	[61][25] = 24,
	[61][26] = 24,
	[61][27] = 24,
	[61][28] = 24,
	[61][29] = 24,
	[65][30] = 25,
	[65][31] = 25,
	[69][2] = 26,
	[69][3] = 26,
	[69][4] = 26,
	[69][5] = 26,
	[69][6] = 26,
	[69][7] = 26,
	[69][8] = 26,
	[69][9] = 26,
	[69][10] = 26,
	[69][30] = 26,
	[69][31] = 26,
	[70][30] = 27,
	[70][31] = 27,
	[87][2] = 28,
	[87][3] = 28,
	[87][4] = 28,
	[87][5] = 28,
	[87][6] = 28,
	[87][7] = 28,
	[87][8] = 28,
	[87][9] = 28,
	[87][10] = 28,
	[87][30] = 28,
	[87][31] = 28,
	[92][8] = 20,
	[92][9] = 20,
	[92][13] = 20,
	[92][14] = 20,
	[92][15] = 20,
	[92][16] = 20,
	[92][17] = 20,
	[92][18] = 20,
	[92][19] = 20,
	[92][20] = 20,
	[92][21] = 20,
	[92][22] = 20,
	[92][23] = 20,
	[92][24] = 20,
	[92][25] = 20,
	[92][26] = 20,
	[92][27] = 20,
	[92][28] = 20,
	[92][29] = 20,
	[92][34] = 20,
	[93][8] = 21,
	[93][9] = 21,
	[93][13] = 21,
	[93][14] = 21,
	[93][15] = 21,
	[93][16] = 21,
	[93][17] = 21,
	[93][18] = 21,
	[93][19] = 21,
	[93][20] = 21,
	[93][21] = 21,
	[93][22] = 21,
	[93][23] = 21,
	[93][24] = 21,
	[93][25] = 21,
	[93][26] = 21,
	[93][27] = 21,
	[93][28] = 21,
	[93][29] = 21,
	[93][34] = 21,
	[94][8] = 22,
	[94][9] = 22,
	[94][13] = 22,
	[94][14] = 22,
	[94][15] = 22,
	[94][16] = 22,
	[94][17] = 22,
	[94][18] = 22,
	[94][19] = 22,
	[94][20] = 22,
	[94][21] = 22,
	[94][22] = 22,
	[94][23] = 22,
	[94][24] = 22,
	[94][25] = 22,
	[94][26] = 22,
	[94][27] = 22,
	[94][28] = 22,
	[94][29] = 22,
	[94][34] = 22,
	[95][8] = 23,
	[95][9] = 23,
	[95][13] = 23,
	[95][14] = 23,
	[95][15] = 23,
	[95][16] = 23,
	[95][17] = 23,
	[95][18] = 23,
	[95][19] = 23,
	[95][20] = 23,
	[95][21] = 23,
	[95][22] = 23,
	[95][23] = 23,
	[95][24] = 23,
	[95][25] = 23,
	[95][26] = 23,
	[95][27] = 23,
	[95][28] = 23,
	[95][29] = 23,
	[95][34] = 23,
	[96][8] = 24,
	[96][9] = 24,
	[96][13] = 24,
	[96][14] = 24,
	[96][15] = 24,
	[96][16] = 24,
	[96][17] = 24,
	[96][18] = 24,
	[96][19] = 24,
	[96][20] = 24,
	[96][21] = 24,
	[96][22] = 24,
	[96][23] = 24,
	[96][24] = 24,
	[96][25] = 24,
	[96][26] = 24,
	[96][27] = 24,
	[96][28] = 24,
	[96][29] = 24,
	[96][34] = 24,
	[103][8] = 29,
	[103][9] = 29,
	[103][12] = 29,
	[103][13] = 29,
	[103][14] = 29,
	[103][15] = 29,
	[103][16] = 29,
	[103][17] = 29,
	[103][18] = 29,
	[103][19] = 29,
	[103][20] = 29,
	[103][21] = 29,
	[103][22] = 29,
	[103][23] = 29,
	[103][24] = 29,
	[103][25] = 29,
	[103][26] = 29,
	[103][27] = 29,
	[103][28] = 29,
	[103][29] = 29,
	[118][2] = 1,
	[118][3] = 1,
	[118][4] = 1,
	[118][13] = 1,
	[118][14] = 1,
	[118][15] = 1,
	[118][34] = 1,
	[120][2] = 2,
	[120][3] = 2,
	[120][4] = 2,
	[120][13] = 2,
	[120][14] = 2,
	[120][15] = 2,
	[120][34] = 2,
	[122][13] = 30,
	[122][14] = 30,
	[122][15] = 30,
	[122][34] = 30,
	[123][34] = 31,
	[124][8] = 32,
	[124][9] = 32,
	[124][12] = 32,
	[124][13] = 32,
	[124][14] = 32,
	[124][15] = 32,
	[124][19] = 32,
	[124][20] = 32,
	[124][21] = 32,
	[124][22] = 32,
	[124][23] = 32,
	[124][24] = 32,
	[124][25] = 32,
	[124][26] = 32,
	[124][27] = 32,
	[124][28] = 32,
	[124][29] = 32,
	[125][8] = 33,
	[125][9] = 33,
	[125][12] = 33,
	[125][13] = 33,
	[125][14] = 33,
	[125][15] = 33,
	[125][19] = 33,
	[125][20] = 33,
	[125][21] = 33,
	[125][22] = 33,
	[125][23] = 33,
	[125][24] = 33,
	[125][25] = 33,
	[125][26] = 33,
	[125][27] = 33,
	[125][28] = 33,
	[125][29] = 33,
	[126][8] = 34,
	[126][9] = 34,
	[126][12] = 34,
	[126][13] = 34,
	[126][14] = 34,
	[126][15] = 34,
	[126][19] = 34,
	[126][20] = 34,
	[126][21] = 34,
	[126][22] = 34,
	[126][23] = 34,
	[126][24] = 34,
	[126][25] = 34,
	[126][26] = 34,
	[126][27] = 34,
	[126][28] = 34,
	[126][29] = 34,
	[127][12] = 35,
	[127][14] = 35,
	[127][25] = 35,
	[127][26] = 35,
	[127][27] = 35,
	[127][28] = 35,
	[127][29] = 35,
	[128][12] = 36,
	[128][14] = 36,
	[128][23] = 36,
	[128][24] = 36,
	[128][25] = 36,
	[128][26] = 36,
	[128][27] = 36,
	[128][28] = 36,
	[128][29] = 36,
	[129][12] = 37,
	[129][14] = 37,
	[129][23] = 37,
	[129][24] = 37,
	[129][25] = 37,
	[129][26] = 37,
	[129][27] = 37,
	[129][28] = 37,
	[129][29] = 37,
	[130][12] = 38,
	[130][14] = 38,
	[130][23] = 38,
	[130][24] = 38,
	[130][25] = 38,
	[130][26] = 38,
	[130][27] = 38,
	[130][28] = 38,
	[130][29] = 38,
	[131][12] = 39,
	[131][14] = 39,
	[131][26] = 39,
	[131][27] = 39,
	[131][28] = 39,
	[131][29] = 39,
	[132][12] = 40,
	[132][14] = 40,
	[132][27] = 40,
	[132][28] = 40,
	[132][29] = 40,
	[133][12] = 41,
	[133][27] = 41,
	[133][28] = 41,
	[133][29] = 41,
	[134][12] = 42,
	[134][28] = 42,
	[134][29] = 42,
	[135][8] = 1,
	[135][9] = 1,
	[135][11] = 1,
	[135][13] = 1,
	[135][14] = 1,
	[135][15] = 1,
	[135][16] = 1,
	[135][17] = 1,
	[135][18] = 1,
	[135][19] = 1,
	[135][20] = 1,
	[135][21] = 1,
	[135][22] = 1,
	[135][23] = 1,
	[135][24] = 1,
	[135][25] = 1,
	[135][26] = 1,
	[135][27] = 1,
	[135][28] = 1,
	[135][29] = 1,
	[137][8] = 2,
	[137][9] = 2,
	[137][11] = 2,
	[137][13] = 2,
	[137][14] = 2,
	[137][15] = 2,
	[137][16] = 2,
	[137][17] = 2,
	[137][18] = 2,
	[137][19] = 2,
	[137][20] = 2,
	[137][21] = 2,
	[137][22] = 2,
	[137][23] = 2,
	[137][24] = 2,
	[137][25] = 2,
	[137][26] = 2,
	[137][27] = 2,
	[137][28] = 2,
	[137][29] = 2,
	[144][11] = 3,
	[144][13] = 3,
	[144][14] = 3,
	[144][15] = 3,
	[144][19] = 3,
	[144][20] = 3,
	[144][21] = 3,
	[144][22] = 3,
	[144][23] = 3,
	[144][24] = 3,
	[144][25] = 3,
	[144][26] = 3,
	[144][27] = 3,
	[144][28] = 3,
	[144][29] = 3,
	[145][11] = 4,
	[145][14] = 4,
	[145][26] = 4,
	[145][27] = 4,
	[145][28] = 4,
	[145][29] = 4,
	[146][11] = 6,
	[147][11] = 7,
	[147][14] = 7,
	[147][25] = 7,
	[147][26] = 7,
	[147][27] = 7,
	[147][28] = 7,
	[147][29] = 7,
	[148][11] = 8,
	[148][14] = 8,
	[148][27] = 8,
	[148][28] = 8,
	[148][29] = 8,
	[150][11] = 10,
	[150][27] = 10,
	[150][28] = 10,
	[150][29] = 10,
	[151][11] = 11,
	[151][28] = 11,
	[151][29] = 11,
	[152][11] = 12,
	[153][8] = 13,
	[153][9] = 13,
	[153][11] = 13,
	[153][13] = 13,
	[153][14] = 13,
	[153][15] = 13,
	[153][19] = 13,
	[153][20] = 13,
	[153][21] = 13,
	[153][22] = 13,
	[153][23] = 13,
	[153][24] = 13,
	[153][25] = 13,
	[153][26] = 13,
	[153][27] = 13,
	[153][28] = 13,
	[153][29] = 13,
	[154][8] = 14,
	[154][9] = 14,
	[154][11] = 14,
	[154][13] = 14,
	[154][14] = 14,
	[154][15] = 14,
	[154][16] = 14,
	[154][17] = 14,
	[154][18] = 14,
	[154][19] = 14,
	[154][20] = 14,
	[154][21] = 14,
	[154][22] = 14,
	[154][23] = 14,
	[154][24] = 14,
	[154][25] = 14,
	[154][26] = 14,
	[154][27] = 14,
	[154][28] = 14,
	[154][29] = 14,
	[155][8] = 15,
	[155][9] = 15,
	[155][11] = 15,
	[155][13] = 15,
	[155][14] = 15,
	[155][15] = 15,
	[155][16] = 15,
	[155][17] = 15,
	[155][18] = 15,
	[155][19] = 15,
	[155][20] = 15,
	[155][21] = 15,
	[155][22] = 15,
	[155][23] = 15,
	[155][24] = 15,
	[155][25] = 15,
	[155][26] = 15,
	[155][27] = 15,
	[155][28] = 15,
	[155][29] = 15,
	[156][11] = 16,
	[156][14] = 16,
	[156][23] = 16,
	[156][24] = 16,
	[156][25] = 16,
	[156][26] = 16,
	[156][27] = 16,
	[156][28] = 16,
	[156][29] = 16,
	[157][11] = 18,
	[157][13] = 18,
	[157][14] = 18,
	[157][15] = 18,
	[157][21] = 18,
	[157][22] = 18,
	[157][23] = 18,
	[157][24] = 18,
	[157][25] = 18,
	[157][26] = 18,
	[157][27] = 18,
	[157][28] = 18,
	[157][29] = 18,
	[158][8] = 43,
	[158][9] = 43,
	[158][12] = 43,
	[158][13] = 43,
	[158][14] = 43,
	[158][15] = 43,
	[158][16] = 43,
	[158][17] = 43,
	[158][18] = 43,
	[158][19] = 43,
	[158][20] = 43,
	[158][21] = 43,
	[158][22] = 43,
	[158][23] = 43,
	[158][24] = 43,
	[158][25] = 43,
	[158][26] = 43,
	[158][27] = 43,
	[158][28] = 43,
	[158][29] = 43,
	[159][8] = 44,
	[159][9] = 44,
	[159][12] = 44,
	[159][13] = 44,
	[159][14] = 44,
	[159][15] = 44,
	[159][16] = 44,
	[159][17] = 44,
	[159][18] = 44,
	[159][19] = 44,
	[159][20] = 44,
	[159][21] = 44,
	[159][22] = 44,
	[159][23] = 44,
	[159][24] = 44,
	[159][25] = 44,
	[159][26] = 44,
	[159][27] = 44,
	[159][28] = 44,
	[159][29] = 44,
	[160][8] = 45,
	[160][9] = 45,
	[160][12] = 45,
	[160][13] = 45,
	[160][14] = 45,
	[160][15] = 45,
	[160][16] = 45,
	[160][17] = 45,
	[160][18] = 45,
	[160][19] = 45,
	[160][20] = 45,
	[160][21] = 45,
	[160][22] = 45,
	[160][23] = 45,
	[160][24] = 45,
	[160][25] = 45,
	[160][26] = 45,
	[160][27] = 45,
	[160][28] = 45,
	[160][29] = 45,
	[161][8] = 46,
	[161][9] = 46,
	[161][12] = 46,
	[161][13] = 46,
	[161][14] = 46,
	[161][15] = 46,
	[161][16] = 46,
	[161][17] = 46,
	[161][18] = 46,
	[161][19] = 46,
	[161][20] = 46,
	[161][21] = 46,
	[161][22] = 46,
	[161][23] = 46,
	[161][24] = 46,
	[161][25] = 46,
	[161][26] = 46,
	[161][27] = 46,
	[161][28] = 46,
	[161][29] = 46,
	[162][12] = 47,
	[162][13] = 47,
	[162][14] = 47,
	[162][15] = 47,
	[162][21] = 47,
	[162][22] = 47,
	[162][23] = 47,
	[162][24] = 47,
	[162][25] = 47,
	[162][26] = 47,
	[162][27] = 47,
	[162][28] = 47,
	[162][29] = 47,
	[163][12] = 48,
	[163][13] = 48,
	[163][14] = 48,
	[163][15] = 48,
	[163][21] = 48,
	[163][22] = 48,
	[163][23] = 48,
	[163][24] = 48,
	[163][25] = 48,
	[163][26] = 48,
	[163][27] = 48,
	[163][28] = 48,
	[163][29] = 48,
	[164][12] = 49,
	[164][13] = 49,
	[164][14] = 49,
	[164][15] = 49,
	[164][21] = 49,
	[164][22] = 49,
	[164][23] = 49,
	[164][24] = 49,
	[164][25] = 49,
	[164][26] = 49,
	[164][27] = 49,
	[164][28] = 49,
	[164][29] = 49,
	[165][12] = 50,
	[165][13] = 50,
	[165][14] = 50,
	[165][15] = 50,
	[165][21] = 50,
	[165][22] = 50,
	[165][23] = 50,
	[165][24] = 50,
	[165][25] = 50,
	[165][26] = 50,
	[165][27] = 50,
	[165][28] = 50,
	[165][29] = 50,
	[166][12] = 51,
	[166][13] = 51,
	[166][14] = 51,
	[166][15] = 51,
	[166][21] = 51,
	[166][22] = 51,
	[166][23] = 51,
	[166][24] = 51,
	[166][25] = 51,
	[166][26] = 51,
	[166][27] = 51,
	[166][28] = 51,
	[166][29] = 51,
	[167][12] = 52,
	[167][13] = 52,
	[167][14] = 52,
	[167][15] = 52,
	[167][19] = 52,
	[167][20] = 52,
	[167][21] = 52,
	[167][22] = 52,
	[167][23] = 52,
	[167][24] = 52,
	[167][25] = 52,
	[167][26] = 52,
	[167][27] = 52,
	[167][28] = 52,
	[167][29] = 52,
	[168][12] = 53,
	[168][13] = 53,
	[168][14] = 53,
	[168][15] = 53,
	[168][19] = 53,
	[168][20] = 53,
	[168][21] = 53,
	[168][22] = 53,
	[168][23] = 53,
	[168][24] = 53,
	[168][25] = 53,
	[168][26] = 53,
	[168][27] = 53,
	[168][28] = 53,
	[168][29] = 53,
	[169][12] = 54,
	[169][13] = 54,
	[169][14] = 54,
	[169][15] = 54,
	[169][19] = 54,
	[169][20] = 54,
	[169][21] = 54,
	[169][22] = 54,
	[169][23] = 54,
	[169][24] = 54,
	[169][25] = 54,
	[169][26] = 54,
	[169][27] = 54,
	[169][28] = 54,
	[169][29] = 54,
	[170][31] = 55,
	[173][2] = 56,
	[173][3] = 56,
	[173][4] = 56,
	[173][5] = 56,
	[173][6] = 56,
	[173][7] = 56,
	[173][8] = 56,
	[173][9] = 56,
	[173][10] = 56,
	[173][30] = 56,
	[173][31] = 56,
	[175][2] = 57,
	[175][3] = 57,
	[175][4] = 57,
	[175][5] = 57,
	[175][6] = 57,
	[175][7] = 57,
	[175][8] = 57,
	[175][9] = 57,
	[175][10] = 57,
	[175][30] = 57,
	[175][31] = 57,
	[176][8] = 29,
	[176][9] = 29,
	[176][13] = 29,
	[176][14] = 29,
	[176][15] = 29,
	[176][16] = 29,
	[176][17] = 29,
	[176][18] = 29,
	[176][19] = 29,
	[176][20] = 29,
	[176][21] = 29,
	[176][22] = 29,
	[176][23] = 29,
	[176][24] = 29,
	[176][25] = 29,
	[176][26] = 29,
	[176][27] = 29,
	[176][28] = 29,
	[176][29] = 29,
	[176][34] = 29,
	[179][8] = 32,
	[179][9] = 32,
	[179][13] = 32,
	[179][14] = 32,
	[179][15] = 32,
	[179][19] = 32,
	[179][20] = 32,
	[179][21] = 32,
	[179][22] = 32,
	[179][23] = 32,
	[179][24] = 32,
	[179][25] = 32,
	[179][26] = 32,
	[179][27] = 32,
	[179][28] = 32,
	[179][29] = 32,
	[179][34] = 32,
	[180][8] = 33,
	[180][9] = 33,
	[180][13] = 33,
	[180][14] = 33,
	[180][15] = 33,
	[180][19] = 33,
	[180][20] = 33,
	[180][21] = 33,
	[180][22] = 33,
	[180][23] = 33,
	[180][24] = 33,
	[180][25] = 33,
	[180][26] = 33,
	[180][27] = 33,
	[180][28] = 33,
	[180][29] = 33,
	[180][34] = 33,
	[181][8] = 34,
	[181][9] = 34,
	[181][13] = 34,
	[181][14] = 34,
	[181][15] = 34,
	[181][19] = 34,
	[181][20] = 34,
	[181][21] = 34,
	[181][22] = 34,
	[181][23] = 34,
	[181][24] = 34,
	[181][25] = 34,
	[181][26] = 34,
	[181][27] = 34,
	[181][28] = 34,
	[181][29] = 34,
	[181][34] = 34,
	[182][14] = 35,
	[182][25] = 35,
	[182][26] = 35,
	[182][27] = 35,
	[182][28] = 35,
	[182][29] = 35,
	[182][34] = 35,
	[183][14] = 36,
	[183][23] = 36,
	[183][24] = 36,
	[183][25] = 36,
	[183][26] = 36,
	[183][27] = 36,
	[183][28] = 36,
	[183][29] = 36,
	[183][34] = 36,
	[184][14] = 37,
	[184][23] = 37,
	[184][24] = 37,
	[184][25] = 37,
	[184][26] = 37,
	[184][27] = 37,
	[184][28] = 37,
	[184][29] = 37,
	[184][34] = 37,
	[185][14] = 38,
	[185][23] = 38,
	[185][24] = 38,
	[185][25] = 38,
	[185][26] = 38,
	[185][27] = 38,
	[185][28] = 38,
	[185][29] = 38,
	[185][34] = 38,
	[186][14] = 39,
	[186][26] = 39,
	[186][27] = 39,
	[186][28] = 39,
	[186][29] = 39,
	[186][34] = 39,
	[187][14] = 40,
	[187][27] = 40,
	[187][28] = 40,
	[187][29] = 40,
	[187][34] = 40,
	[188][27] = 41,
	[188][28] = 41,
	[188][29] = 41,
	[188][34] = 41,
	[189][28] = 42,
	[189][29] = 42,
	[189][34] = 42,
	[191][8] = 43,
	[191][9] = 43,
	[191][13] = 43,
	[191][14] = 43,
	[191][15] = 43,
	[191][16] = 43,
	[191][17] = 43,
	[191][18] = 43,
	[191][19] = 43,
	[191][20] = 43,
	[191][21] = 43,
	[191][22] = 43,
	[191][23] = 43,
	[191][24] = 43,
	[191][25] = 43,
	[191][26] = 43,
	[191][27] = 43,
	[191][28] = 43,
	[191][29] = 43,
	[191][34] = 43,
	[192][8] = 44,
	[192][9] = 44,
	[192][13] = 44,
	[192][14] = 44,
	[192][15] = 44,
	[192][16] = 44,
	[192][17] = 44,
	[192][18] = 44,
	[192][19] = 44,
	[192][20] = 44,
	[192][21] = 44,
	[192][22] = 44,
	[192][23] = 44,
	[192][24] = 44,
	[192][25] = 44,
	[192][26] = 44,
	[192][27] = 44,
	[192][28] = 44,
	[192][29] = 44,
	[192][34] = 44,
	[193][8] = 45,
	[193][9] = 45,
	[193][13] = 45,
	[193][14] = 45,
	[193][15] = 45,
	[193][16] = 45,
	[193][17] = 45,
	[193][18] = 45,
	[193][19] = 45,
	[193][20] = 45,
	[193][21] = 45,
	[193][22] = 45,
	[193][23] = 45,
	[193][24] = 45,
	[193][25] = 45,
	[193][26] = 45,
	[193][27] = 45,
	[193][28] = 45,
	[193][29] = 45,
	[193][34] = 45,
	[194][8] = 46,
	[194][9] = 46,
	[194][13] = 46,
	[194][14] = 46,
	[194][15] = 46,
	[194][16] = 46,
	[194][17] = 46,
	[194][18] = 46,
	[194][19] = 46,
	[194][20] = 46,
	[194][21] = 46,
	[194][22] = 46,
	[194][23] = 46,
	[194][24] = 46,
	[194][25] = 46,
	[194][26] = 46,
	[194][27] = 46,
	[194][28] = 46,
	[194][29] = 46,
	[194][34] = 46,
	[195][13] = 47,
	[195][14] = 47,
	[195][15] = 47,
	[195][21] = 47,
	[195][22] = 47,
	[195][23] = 47,
	[195][24] = 47,
	[195][25] = 47,
	[195][26] = 47,
	[195][27] = 47,
	[195][28] = 47,
	[195][29] = 47,
	[195][34] = 47,
	[196][13] = 48,
	[196][14] = 48,
	[196][15] = 48,
	[196][21] = 48,
	[196][22] = 48,
	[196][23] = 48,
	[196][24] = 48,
	[196][25] = 48,
	[196][26] = 48,
	[196][27] = 48,
	[196][28] = 48,
	[196][29] = 48,
	[196][34] = 48,
	[197][13] = 49,
	[197][14] = 49,
	[197][15] = 49,
	[197][21] = 49,
	[197][22] = 49,
	[197][23] = 49,
	[197][24] = 49,
	[197][25] = 49,
	[197][26] = 49,
	[197][27] = 49,
	[197][28] = 49,
	[197][29] = 49,
	[197][34] = 49,
	[198][13] = 50,
	[198][14] = 50,
	[198][15] = 50,
	[198][21] = 50,
	[198][22] = 50,
	[198][23] = 50,
	[198][24] = 50,
	[198][25] = 50,
	[198][26] = 50,
	[198][27] = 50,
	[198][28] = 50,
	[198][29] = 50,
	[198][34] = 50,
	[199][13] = 51,
	[199][14] = 51,
	[199][15] = 51,
	[199][21] = 51,
	[199][22] = 51,
	[199][23] = 51,
	[199][24] = 51,
	[199][25] = 51,
	[199][26] = 51,
	[199][27] = 51,
	[199][28] = 51,
	[199][29] = 51,
	[199][34] = 51,
	[200][13] = 52,
	[200][14] = 52,
	[200][15] = 52,
	[200][19] = 52,
	[200][20] = 52,
	[200][21] = 52,
	[200][22] = 52,
	[200][23] = 52,
	[200][24] = 52,
	[200][25] = 52,
	[200][26] = 52,
	[200][27] = 52,
	[200][28] = 52,
	[200][29] = 52,
	[200][34] = 52,
	[201][13] = 53,
	[201][14] = 53,
	[201][15] = 53,
	[201][19] = 53,
	[201][20] = 53,
	[201][21] = 53,
	[201][22] = 53,
	[201][23] = 53,
	[201][24] = 53,
	[201][25] = 53,
	[201][26] = 53,
	[201][27] = 53,
	[201][28] = 53,
	[201][29] = 53,
	[201][34] = 53,
	[202][13] = 54,
	[202][14] = 54,
	[202][15] = 54,
	[202][19] = 54,
	[202][20] = 54,
	[202][21] = 54,
	[202][22] = 54,
	[202][23] = 54,
	[202][24] = 54,
	[202][25] = 54,
	[202][26] = 54,
	[202][27] = 54,
	[202][28] = 54,
	[202][29] = 54,
	[202][34] = 54,
	[203][8] = 58,
	[203][9] = 58,
	[203][12] = 58,
	[203][13] = 58,
	[203][14] = 58,
	[203][15] = 58,
	[203][16] = 58,
	[203][17] = 58,
	[203][18] = 58,
	[203][19] = 58,
	[203][20] = 58,
	[203][21] = 58,
	[203][22] = 58,
	[203][23] = 58,
	[203][24] = 58,
	[203][25] = 58,
	[203][26] = 58,
	[203][27] = 58,
	[203][28] = 58,
	[203][29] = 58,
	[204][8] = 59,
	[204][9] = 59,
	[204][12] = 59,
	[204][13] = 59,
	[204][14] = 59,
	[204][15] = 59,
	[204][16] = 59,
	[204][17] = 59,
	[204][18] = 59,
	[204][19] = 59,
	[204][20] = 59,
	[204][21] = 59,
	[204][22] = 59,
	[204][23] = 59,
	[204][24] = 59,
	[204][25] = 59,
	[204][26] = 59,
	[204][27] = 59,
	[204][28] = 59,
	[204][29] = 59,
	[206][8] = 60,
	[206][9] = 60,
	[206][12] = 60,
	[206][13] = 60,
	[206][14] = 60,
	[206][15] = 60,
	[206][16] = 60,
	[206][17] = 60,
	[206][18] = 60,
	[206][19] = 60,
	[206][20] = 60,
	[206][21] = 60,
	[206][22] = 60,
	[206][23] = 60,
	[206][24] = 60,
	[206][25] = 60,
	[206][26] = 60,
	[206][27] = 60,
	[206][28] = 60,
	[206][29] = 60,
	[207][13] = 61,
	[207][14] = 61,
	[207][15] = 61,
	[207][34] = 61,
	[208][13] = 62,
	[208][14] = 62,
	[208][15] = 62,
	[208][34] = 62,
	[215][8] = 20,
	[215][9] = 20,
	[215][11] = 20,
	[215][13] = 20,
	[215][14] = 20,
	[215][15] = 20,
	[215][16] = 20,
	[215][17] = 20,
	[215][18] = 20,
	[215][19] = 20,
	[215][20] = 20,
	[215][21] = 20,
	[215][22] = 20,
	[215][23] = 20,
	[215][24] = 20,
	[215][25] = 20,
	[215][26] = 20,
	[215][27] = 20,
	[215][28] = 20,
	[215][29] = 20,
	[216][8] = 21,
	[216][9] = 21,
	[216][11] = 21,
	[216][13] = 21,
	[216][14] = 21,
	[216][15] = 21,
	[216][16] = 21,
	[216][17] = 21,
	[216][18] = 21,
	[216][19] = 21,
	[216][20] = 21,
	[216][21] = 21,
	[216][22] = 21,
	[216][23] = 21,
	[216][24] = 21,
	[216][25] = 21,
	[216][26] = 21,
	[216][27] = 21,
	[216][28] = 21,
	[216][29] = 21,
	[217][8] = 22,
	[217][9] = 22,
	[217][11] = 22,
	[217][13] = 22,
	[217][14] = 22,
	[217][15] = 22,
	[217][16] = 22,
	[217][17] = 22,
	[217][18] = 22,
	[217][19] = 22,
	[217][20] = 22,
	[217][21] = 22,
	[217][22] = 22,
	[217][23] = 22,
	[217][24] = 22,
	[217][25] = 22,
	[217][26] = 22,
	[217][27] = 22,
	[217][28] = 22,
	[217][29] = 22,
	[218][8] = 23,
	[218][9] = 23,
	[218][11] = 23,
	[218][13] = 23,
	[218][14] = 23,
	[218][15] = 23,
	[218][16] = 23,
	[218][17] = 23,
	[218][18] = 23,
	[218][19] = 23,
	[218][20] = 23,
	[218][21] = 23,
	[218][22] = 23,
	[218][23] = 23,
	[218][24] = 23,
	[218][25] = 23,
	[218][26] = 23,
	[218][27] = 23,
	[218][28] = 23,
	[218][29] = 23,
	[219][8] = 24,
	[219][9] = 24,
	[219][11] = 24,
	[219][13] = 24,
	[219][14] = 24,
	[219][15] = 24,
	[219][16] = 24,
	[219][17] = 24,
	[219][18] = 24,
	[219][19] = 24,
	[219][20] = 24,
	[219][21] = 24,
	[219][22] = 24,
	[219][23] = 24,
	[219][24] = 24,
	[219][25] = 24,
	[219][26] = 24,
	[219][27] = 24,
	[219][28] = 24,
	[219][29] = 24,
	[242][2] = 63,
	[242][3] = 63,
	[242][4] = 63,
	[242][5] = 63,
	[242][6] = 63,
	[242][7] = 63,
	[242][8] = 63,
	[242][9] = 63,
	[242][10] = 63,
	[242][30] = 63,
	[242][31] = 63,
	[243][2] = 64,
	[243][3] = 64,
	[243][4] = 64,
	[243][5] = 64,
	[243][6] = 64,
	[243][7] = 64,
	[243][8] = 64,
	[243][9] = 64,
	[243][10] = 64,
	[243][30] = 64,
	[243][31] = 64,
	[244][8] = 58,
	[244][9] = 58,
	[244][13] = 58,
	[244][14] = 58,
	[244][15] = 58,
	[244][16] = 58,
	[244][17] = 58,
	[244][18] = 58,
	[244][19] = 58,
	[244][20] = 58,
	[244][21] = 58,
	[244][22] = 58,
	[244][23] = 58,
	[244][24] = 58,
	[244][25] = 58,
	[244][26] = 58,
	[244][27] = 58,
	[244][28] = 58,
	[244][29] = 58,
	[244][34] = 58,
	[245][8] = 59,
	[245][9] = 59,
	[245][13] = 59,
	[245][14] = 59,
	[245][15] = 59,
	[245][16] = 59,
	[245][17] = 59,
	[245][18] = 59,
	[245][19] = 59,
	[245][20] = 59,
	[245][21] = 59,
	[245][22] = 59,
	[245][23] = 59,
	[245][24] = 59,
	[245][25] = 59,
	[245][26] = 59,
	[245][27] = 59,
	[245][28] = 59,
	[245][29] = 59,
	[245][34] = 59,
	[246][8] = 60,
	[246][9] = 60,
	[246][13] = 60,
	[246][14] = 60,
	[246][15] = 60,
	[246][16] = 60,
	[246][17] = 60,
	[246][18] = 60,
	[246][19] = 60,
	[246][20] = 60,
	[246][21] = 60,
	[246][22] = 60,
	[246][23] = 60,
	[246][24] = 60,
	[246][25] = 60,
	[246][26] = 60,
	[246][27] = 60,
	[246][28] = 60,
	[246][29] = 60,
	[246][34] = 60,
	[248][2] = 29,
	[248][3] = 29,
	[248][4] = 29,
	[248][13] = 29,
	[248][14] = 29,
	[248][15] = 29,
	[248][34] = 29,
	[249][13] = 65,
	[249][14] = 65,
	[249][15] = 65,
	[249][34] = 65,
	[250][14] = 1,
	[250][15] = 1,
	[250][34] = 1,
	[252][14] = 2,
	[252][15] = 2,
	[252][34] = 2,
	[253][34] = 66,
	[254][2] = 1,
	[254][3] = 1,
	[254][4] = 1,
	[254][14] = 1,
	[254][15] = 1,
	[254][34] = 1,
	[256][2] = 2,
	[256][3] = 2,
	[256][4] = 2,
	[256][14] = 2,
	[256][15] = 2,
	[256][34] = 2,
	[257][34] = 67,
	[258][14] = 30,
	[258][15] = 30,
	[258][34] = 30,
	[259][34] = 68,
	[260][34] = 1,
	[262][34] = 2,
	[263][34] = 69,
	[264][34] = 70,
	[265][8] = 29,
	[265][9] = 29,
	[265][11] = 29,
	[265][13] = 29,
	[265][14] = 29,
	[265][15] = 29,
	[265][16] = 29,
	[265][17] = 29,
	[265][18] = 29,
	[265][19] = 29,
	[265][20] = 29,
	[265][21] = 29,
	[265][22] = 29,
	[265][23] = 29,
	[265][24] = 29,
	[265][25] = 29,
	[265][26] = 29,
	[265][27] = 29,
	[265][28] = 29,
	[265][29] = 29,
	[268][8] = 32,
	[268][9] = 32,
	[268][11] = 32,
	[268][13] = 32,
	[268][14] = 32,
	[268][15] = 32,
	[268][19] = 32,
	[268][20] = 32,
	[268][21] = 32,
	[268][22] = 32,
	[268][23] = 32,
	[268][24] = 32,
	[268][25] = 32,
	[268][26] = 32,
	[268][27] = 32,
	[268][28] = 32,
	[268][29] = 32,
	[269][8] = 33,
	[269][9] = 33,
	[269][11] = 33,
	[269][13] = 33,
	[269][14] = 33,
	[269][15] = 33,
	[269][19] = 33,
	[269][20] = 33,
	[269][21] = 33,
	[269][22] = 33,
	[269][23] = 33,
	[269][24] = 33,
	[269][25] = 33,
	[269][26] = 33,
	[269][27] = 33,
	[269][28] = 33,
	[269][29] = 33,
	[270][8] = 34,
	[270][9] = 34,
	[270][11] = 34,
	[270][13] = 34,
	[270][14] = 34,
	[270][15] = 34,
	[270][19] = 34,
	[270][20] = 34,
	[270][21] = 34,
	[270][22] = 34,
	[270][23] = 34,
	[270][24] = 34,
	[270][25] = 34,
	[270][26] = 34,
	[270][27] = 34,
	[270][28] = 34,
	[270][29] = 34,
	[271][11] = 35,
	[271][14] = 35,
	[271][25] = 35,
	[271][26] = 35,
	[271][27] = 35,
	[271][28] = 35,
	[271][29] = 35,
	[272][11] = 36,
	[272][14] = 36,
	[272][23] = 36,
	[272][24] = 36,
	[272][25] = 36,
	[272][26] = 36,
	[272][27] = 36,
	[272][28] = 36,
	[272][29] = 36,
	[273][11] = 37,
	[273][14] = 37,
	[273][23] = 37,
	[273][24] = 37,
	[273][25] = 37,
	[273][26] = 37,
	[273][27] = 37,
	[273][28] = 37,
	[273][29] = 37,
	[274][11] = 38,
	[274][14] = 38,
	[274][23] = 38,
	[274][24] = 38,
	[274][25] = 38,
	[274][26] = 38,
	[274][27] = 38,
	[274][28] = 38,
	[274][29] = 38,
	[275][11] = 39,
	[275][14] = 39,
	[275][26] = 39,
	[275][27] = 39,
	[275][28] = 39,
	[275][29] = 39,
	[276][12] = 71,
	[277][11] = 40,
	[277][14] = 40,
	[277][27] = 40,
	[277][28] = 40,
	[277][29] = 40,
	[278][11] = 41,
	[278][27] = 41,
	[278][28] = 41,
	[278][29] = 41,
	[279][11] = 42,
	[279][28] = 42,
	[279][29] = 42,
	[281][8] = 43,
	[281][9] = 43,
	[281][11] = 43,
	[281][13] = 43,
	[281][14] = 43,
	[281][15] = 43,
	[281][16] = 43,
	[281][17] = 43,
	[281][18] = 43,
	[281][19] = 43,
	[281][20] = 43,
	[281][21] = 43,
	[281][22] = 43,
	[281][23] = 43,
	[281][24] = 43,
	[281][25] = 43,
	[281][26] = 43,
	[281][27] = 43,
	[281][28] = 43,
	[281][29] = 43,
	[282][8] = 44,
	[282][9] = 44,
	[282][11] = 44,
	[282][13] = 44,
	[282][14] = 44,
	[282][15] = 44,
	[282][16] = 44,
	[282][17] = 44,
	[282][18] = 44,
	[282][19] = 44,
	[282][20] = 44,
	[282][21] = 44,
	[282][22] = 44,
	[282][23] = 44,
	[282][24] = 44,
	[282][25] = 44,
	[282][26] = 44,
	[282][27] = 44,
	[282][28] = 44,
	[282][29] = 44,
	[283][8] = 45,
	[283][9] = 45,
	[283][11] = 45,
	[283][13] = 45,
	[283][14] = 45,
	[283][15] = 45,
	[283][16] = 45,
	[283][17] = 45,
	[283][18] = 45,
	[283][19] = 45,
	[283][20] = 45,
	[283][21] = 45,
	[283][22] = 45,
	[283][23] = 45,
	[283][24] = 45,
	[283][25] = 45,
	[283][26] = 45,
	[283][27] = 45,
	[283][28] = 45,
	[283][29] = 45,
	[284][8] = 46,
	[284][9] = 46,
	[284][11] = 46,
	[284][13] = 46,
	[284][14] = 46,
	[284][15] = 46,
	[284][16] = 46,
	[284][17] = 46,
	[284][18] = 46,
	[284][19] = 46,
	[284][20] = 46,
	[284][21] = 46,
	[284][22] = 46,
	[284][23] = 46,
	[284][24] = 46,
	[284][25] = 46,
	[284][26] = 46,
	[284][27] = 46,
	[284][28] = 46,
	[284][29] = 46,
	[285][11] = 47,
	[285][13] = 47,
	[285][14] = 47,
	[285][15] = 47,
	[285][21] = 47,
	[285][22] = 47,
	[285][23] = 47,
	[285][24] = 47,
	[285][25] = 47,
	[285][26] = 47,
	[285][27] = 47,
	[285][28] = 47,
	[285][29] = 47,
	[286][11] = 48,
	[286][13] = 48,
	[286][14] = 48,
	[286][15] = 48,
	[286][21] = 48,
	[286][22] = 48,
	[286][23] = 48,
	[286][24] = 48,
	[286][25] = 48,
	[286][26] = 48,
	[286][27] = 48,
	[286][28] = 48,
	[286][29] = 48,
	[287][11] = 49,
	[287][13] = 49,
	[287][14] = 49,
	[287][15] = 49,
	[287][21] = 49,
	[287][22] = 49,
	[287][23] = 49,
	[287][24] = 49,
	[287][25] = 49,
	[287][26] = 49,
	[287][27] = 49,
	[287][28] = 49,
	[287][29] = 49,
	[288][11] = 50,
	[288][13] = 50,
	[288][14] = 50,
	[288][15] = 50,
	[288][21] = 50,
	[288][22] = 50,
	[288][23] = 50,
	[288][24] = 50,
	[288][25] = 50,
	[288][26] = 50,
	[288][27] = 50,
	[288][28] = 50,
	[288][29] = 50,
	[289][11] = 51,
	[289][13] = 51,
	[289][14] = 51,
	[289][15] = 51,
	[289][21] = 51,
	[289][22] = 51,
	[289][23] = 51,
	[289][24] = 51,
	[289][25] = 51,
	[289][26] = 51,
	[289][27] = 51,
	[289][28] = 51,
	[289][29] = 51,
	[290][11] = 52,
	[290][13] = 52,
	[290][14] = 52,
	[290][15] = 52,
	[290][19] = 52,
	[290][20] = 52,
	[290][21] = 52,
	[290][22] = 52,
	[290][23] = 52,
	[290][24] = 52,
	[290][25] = 52,
	[290][26] = 52,
	[290][27] = 52,
	[290][28] = 52,
	[290][29] = 52,
	[291][11] = 53,
	[291][13] = 53,
	[291][14] = 53,
	[291][15] = 53,
	[291][19] = 53,
	[291][20] = 53,
	[291][21] = 53,
	[291][22] = 53,
	[291][23] = 53,
	[291][24] = 53,
	[291][25] = 53,
	[291][26] = 53,
	[291][27] = 53,
	[291][28] = 53,
	[291][29] = 53,
	[292][11] = 54,
	[292][13] = 54,
	[292][14] = 54,
	[292][15] = 54,
	[292][19] = 54,
	[292][20] = 54,
	[292][21] = 54,
	[292][22] = 54,
	[292][23] = 54,
	[292][24] = 54,
	[292][25] = 54,
	[292][26] = 54,
	[292][27] = 54,
	[292][28] = 54,
	[292][29] = 54,
	[293][2] = 72,
	[293][3] = 72,
	[293][4] = 72,
	[293][5] = 72,
	[293][6] = 72,
	[293][7] = 72,
	[293][8] = 72,
	[293][9] = 72,
	[293][10] = 72,
	[293][30] = 72,
	[293][31] = 72,
	[294][2] = 73,
	[294][3] = 73,
	[294][4] = 73,
	[294][5] = 73,
	[294][6] = 73,
	[294][7] = 73,
	[294][8] = 73,
	[294][9] = 73,
	[294][10] = 73,
	[294][30] = 73,
	[294][31] = 73,
	[295][34] = 71,
	[299][34] = 74,
	[301][14] = 61,
	[301][15] = 61,
	[301][34] = 61,
	[302][14] = 62,
	[302][15] = 62,
	[302][34] = 62,
	[303][34] = 75,
	[305][8] = 58,
	[305][9] = 58,
	[305][11] = 58,
	[305][13] = 58,
	[305][14] = 58,
	[305][15] = 58,
	[305][16] = 58,
	[305][17] = 58,
	[305][18] = 58,
	[305][19] = 58,
	[305][20] = 58,
	[305][21] = 58,
	[305][22] = 58,
	[305][23] = 58,
	[305][24] = 58,
	[305][25] = 58,
	[305][26] = 58,
	[305][27] = 58,
	[305][28] = 58,
	[305][29] = 58,
	[306][8] = 59,
	[306][9] = 59,
	[306][11] = 59,
	[306][13] = 59,
	[306][14] = 59,
	[306][15] = 59,
	[306][16] = 59,
	[306][17] = 59,
	[306][18] = 59,
	[306][19] = 59,
	[306][20] = 59,
	[306][21] = 59,
	[306][22] = 59,
	[306][23] = 59,
	[306][24] = 59,
	[306][25] = 59,
	[306][26] = 59,
	[306][27] = 59,
	[306][28] = 59,
	[306][29] = 59,
	[307][8] = 60,
	[307][9] = 60,
	[307][11] = 60,
	[307][13] = 60,
	[307][14] = 60,
	[307][15] = 60,
	[307][16] = 60,
	[307][17] = 60,
	[307][18] = 60,
	[307][19] = 60,
	[307][20] = 60,
	[307][21] = 60,
	[307][22] = 60,
	[307][23] = 60,
	[307][24] = 60,
	[307][25] = 60,
	[307][26] = 60,
	[307][27] = 60,
	[307][28] = 60,
	[307][29] = 60,
	[309][14] = 29,
	[309][15] = 29,
	[309][34] = 29,
	[310][34] = 76,
	[311][34] = 77,
	[312][2] = 29,
	[312][3] = 29,
	[312][4] = 29,
	[312][14] = 29,
	[312][15] = 29,
	[312][34] = 29,
	[313][14] = 65,
	[313][15] = 65,
	[313][34] = 65,
	[314][34] = 29,
	[315][11] = 71,
};


const unsigned zebu_gotos[309][35] = {
	[1][1] = 11,
	[1][2] = 12,
	[1][3] = 13,
	[1][4] = 14,
	[1][5] = 15,
	[1][6] = 16,
	[1][7] = 17,
	[1][8] = 18,
	[1][9] = 19,
	[1][10] = 20,
	[1][11] = 21,
	[1][12] = 22,
	[1][13] = 23,
	[1][14] = 24,
	[1][15] = 25,
	[1][16] = 26,
	[1][17] = 27,
	[1][18] = 28,
	[3][1] = 40,
	[3][2] = 41,
	[3][4] = 42,
	[3][5] = 43,
	[3][6] = 44,
	[3][7] = 45,
	[3][9] = 46,
	[3][10] = 47,
	[3][11] = 48,
	[3][12] = 49,
	[3][13] = 50,
	[3][14] = 51,
	[3][15] = 52,
	[3][17] = 53,
	[7][13] = 58,
	[7][14] = 24,
	[7][19] = 57,
	[8][13] = 58,
	[8][14] = 24,
	[8][19] = 59,
	[9][13] = 58,
	[9][14] = 24,
	[9][19] = 60,
	[10][13] = 58,
	[10][14] = 24,
	[10][19] = 61,
	[13][1] = 11,
	[13][2] = 12,
	[13][3] = 13,
	[13][4] = 14,
	[13][5] = 15,
	[13][6] = 16,
	[13][7] = 17,
	[13][8] = 18,
	[13][9] = 19,
	[13][10] = 20,
	[13][11] = 21,
	[13][12] = 22,
	[13][13] = 23,
	[13][14] = 24,
	[13][15] = 25,
	[13][17] = 27,
	[13][18] = 65,
	[18][1] = 11,
	[18][2] = 12,
	[18][3] = 13,
	[18][4] = 14,
	[18][5] = 15,
	[18][6] = 16,
	[18][7] = 17,
	[18][8] = 18,
	[18][9] = 19,
	[18][10] = 20,
	[18][11] = 21,
	[18][12] = 22,
	[18][13] = 23,
	[18][14] = 24,
	[18][15] = 25,
	[18][17] = 27,
	[18][18] = 70,
	[30][1] = 11,
	[30][2] = 12,
	[30][4] = 14,
	[30][5] = 15,
	[30][6] = 16,
	[30][7] = 88,
	[30][9] = 19,
	[30][10] = 20,
	[30][11] = 21,
	[30][12] = 22,
	[30][13] = 23,
	[30][14] = 24,
	[30][15] = 25,
	[30][17] = 27,
	[30][20] = 87,
	[32][1] = 40,
	[32][2] = 41,
	[32][4] = 42,
	[32][5] = 43,
	[32][6] = 44,
	[32][7] = 89,
	[32][9] = 46,
	[32][10] = 47,
	[32][11] = 48,
	[32][12] = 49,
	[32][13] = 50,
	[32][14] = 51,
	[32][15] = 52,
	[32][17] = 53,
	[36][13] = 93,
	[36][14] = 51,
	[36][19] = 92,
	[37][13] = 93,
	[37][14] = 51,
	[37][19] = 94,
	[38][13] = 93,
	[38][14] = 51,
	[38][19] = 95,
	[39][13] = 93,
	[39][14] = 51,
	[39][19] = 96,
	[54][1] = 40,
	[54][2] = 41,
	[54][4] = 42,
	[54][5] = 43,
	[54][6] = 44,
	[54][7] = 117,
	[54][9] = 46,
	[54][10] = 47,
	[54][11] = 48,
	[54][12] = 49,
	[54][13] = 50,
	[54][14] = 51,
	[54][15] = 52,
	[54][17] = 53,
	[55][14] = 122,
	[55][21] = 121,
	[55][22] = 123,
	[62][12] = 125,
	[62][13] = 23,
	[62][14] = 24,
	[62][23] = 124,
	[63][12] = 125,
	[63][13] = 23,
	[63][14] = 24,
	[63][23] = 126,
	[64][1] = 11,
	[64][5] = 127,
	[64][12] = 22,
	[64][13] = 23,
	[64][14] = 24,
	[64][15] = 25,
	[64][17] = 27,
	[66][1] = 11,
	[66][12] = 22,
	[66][13] = 23,
	[66][14] = 24,
	[66][15] = 129,
	[66][17] = 27,
	[66][24] = 128,
	[67][1] = 11,
	[67][12] = 22,
	[67][13] = 23,
	[67][14] = 24,
	[67][15] = 129,
	[67][17] = 27,
	[67][24] = 130,
	[68][1] = 11,
	[68][2] = 131,
	[68][5] = 15,
	[68][12] = 22,
	[68][13] = 23,
	[68][14] = 24,
	[68][15] = 25,
	[68][17] = 27,
	[71][1] = 11,
	[71][2] = 12,
	[71][5] = 15,
	[71][6] = 132,
	[71][12] = 22,
	[71][13] = 23,
	[71][14] = 24,
	[71][15] = 25,
	[71][17] = 27,
	[72][1] = 11,
	[72][2] = 12,
	[72][5] = 15,
	[72][6] = 16,
	[72][9] = 133,
	[72][12] = 22,
	[72][13] = 23,
	[72][14] = 24,
	[72][15] = 25,
	[72][17] = 27,
	[73][1] = 11,
	[73][2] = 12,
	[73][5] = 15,
	[73][6] = 16,
	[73][9] = 19,
	[73][10] = 134,
	[73][12] = 22,
	[73][13] = 23,
	[73][14] = 24,
	[73][15] = 25,
	[73][17] = 27,
	[74][1] = 144,
	[74][2] = 145,
	[74][4] = 146,
	[74][5] = 147,
	[74][6] = 148,
	[74][7] = 149,
	[74][9] = 150,
	[74][10] = 151,
	[74][11] = 152,
	[74][12] = 153,
	[74][13] = 154,
	[74][14] = 155,
	[74][15] = 156,
	[74][17] = 157,
	[75][13] = 159,
	[75][14] = 24,
	[75][25] = 158,
	[76][13] = 159,
	[76][14] = 24,
	[76][25] = 160,
	[77][13] = 159,
	[77][14] = 24,
	[77][25] = 161,
	[78][1] = 11,
	[78][12] = 22,
	[78][13] = 23,
	[78][14] = 24,
	[78][17] = 163,
	[78][26] = 162,
	[79][1] = 11,
	[79][12] = 22,
	[79][13] = 23,
	[79][14] = 24,
	[79][17] = 163,
	[79][26] = 164,
	[80][1] = 11,
	[80][12] = 22,
	[80][13] = 23,
	[80][14] = 24,
	[80][17] = 163,
	[80][26] = 165,
	[81][1] = 11,
	[81][12] = 22,
	[81][13] = 23,
	[81][14] = 24,
	[81][17] = 163,
	[81][26] = 166,
	[82][1] = 168,
	[82][12] = 22,
	[82][13] = 23,
	[82][14] = 24,
	[82][27] = 167,
	[83][1] = 168,
	[83][12] = 22,
	[83][13] = 23,
	[83][14] = 24,
	[83][27] = 169,
	[84][1] = 11,
	[84][2] = 12,
	[84][3] = 13,
	[84][4] = 14,
	[84][5] = 15,
	[84][6] = 16,
	[84][7] = 17,
	[84][8] = 18,
	[84][9] = 19,
	[84][10] = 20,
	[84][11] = 21,
	[84][12] = 22,
	[84][13] = 23,
	[84][14] = 24,
	[84][15] = 25,
	[84][16] = 170,
	[84][17] = 27,
	[84][18] = 28,
	[85][28] = 173,
	[90][1] = 40,
	[90][2] = 41,
	[90][4] = 42,
	[90][5] = 43,
	[90][6] = 44,
	[90][7] = 177,
	[90][9] = 46,
	[90][10] = 47,
	[90][11] = 48,
	[90][12] = 49,
	[90][13] = 50,
	[90][14] = 51,
	[90][15] = 52,
	[90][17] = 53,
	[91][14] = 122,
	[91][21] = 178,
	[91][22] = 123,
	[97][12] = 180,
	[97][13] = 50,
	[97][14] = 51,
	[97][23] = 179,
	[98][12] = 180,
	[98][13] = 50,
	[98][14] = 51,
	[98][23] = 181,
	[99][1] = 40,
	[99][5] = 182,
	[99][12] = 49,
	[99][13] = 50,
	[99][14] = 51,
	[99][15] = 52,
	[99][17] = 53,
	[100][1] = 40,
	[100][12] = 49,
	[100][13] = 50,
	[100][14] = 51,
	[100][15] = 184,
	[100][17] = 53,
	[100][24] = 183,
	[101][1] = 40,
	[101][12] = 49,
	[101][13] = 50,
	[101][14] = 51,
	[101][15] = 184,
	[101][17] = 53,
	[101][24] = 185,
	[102][1] = 40,
	[102][2] = 186,
	[102][5] = 43,
	[102][12] = 49,
	[102][13] = 50,
	[102][14] = 51,
	[102][15] = 52,
	[102][17] = 53,
	[104][1] = 40,
	[104][2] = 41,
	[104][5] = 43,
	[104][6] = 187,
	[104][12] = 49,
	[104][13] = 50,
	[104][14] = 51,
	[104][15] = 52,
	[104][17] = 53,
	[105][1] = 40,
	[105][2] = 41,
	[105][5] = 43,
	[105][6] = 44,
	[105][9] = 188,
	[105][12] = 49,
	[105][13] = 50,
	[105][14] = 51,
	[105][15] = 52,
	[105][17] = 53,
	[106][1] = 40,
	[106][2] = 41,
	[106][5] = 43,
	[106][6] = 44,
	[106][9] = 46,
	[106][10] = 189,
	[106][12] = 49,
	[106][13] = 50,
	[106][14] = 51,
	[106][15] = 52,
	[106][17] = 53,
	[107][1] = 144,
	[107][2] = 145,
	[107][4] = 146,
	[107][5] = 147,
	[107][6] = 148,
	[107][7] = 190,
	[107][9] = 150,
	[107][10] = 151,
	[107][11] = 152,
	[107][12] = 153,
	[107][13] = 154,
	[107][14] = 155,
	[107][15] = 156,
	[107][17] = 157,
	[108][13] = 192,
	[108][14] = 51,
	[108][25] = 191,
	[109][13] = 192,
	[109][14] = 51,
	[109][25] = 193,
	[110][13] = 192,
	[110][14] = 51,
	[110][25] = 194,
	[111][1] = 40,
	[111][12] = 49,
	[111][13] = 50,
	[111][14] = 51,
	[111][17] = 196,
	[111][26] = 195,
	[112][1] = 40,
	[112][12] = 49,
	[112][13] = 50,
	[112][14] = 51,
	[112][17] = 196,
	[112][26] = 197,
	[113][1] = 40,
	[113][12] = 49,
	[113][13] = 50,
	[113][14] = 51,
	[113][17] = 196,
	[113][26] = 198,
	[114][1] = 40,
	[114][12] = 49,
	[114][13] = 50,
	[114][14] = 51,
	[114][17] = 196,
	[114][26] = 199,
	[115][1] = 201,
	[115][12] = 49,
	[115][13] = 50,
	[115][14] = 51,
	[115][27] = 200,
	[116][1] = 201,
	[116][12] = 49,
	[116][13] = 50,
	[116][14] = 51,
	[116][27] = 202,
	[117][29] = 204,
	[119][1] = 40,
	[119][2] = 41,
	[119][4] = 42,
	[119][5] = 43,
	[119][6] = 44,
	[119][7] = 205,
	[119][9] = 46,
	[119][10] = 47,
	[119][11] = 48,
	[119][12] = 49,
	[119][13] = 50,
	[119][14] = 51,
	[119][15] = 52,
	[119][17] = 53,
	[121][29] = 206,
	[122][14] = 208,
	[122][30] = 207,
	[136][1] = 40,
	[136][2] = 41,
	[136][4] = 42,
	[136][5] = 43,
	[136][6] = 44,
	[136][7] = 212,
	[136][9] = 46,
	[136][10] = 47,
	[136][11] = 48,
	[136][12] = 49,
	[136][13] = 50,
	[136][14] = 51,
	[136][15] = 52,
	[136][17] = 53,
	[140][13] = 216,
	[140][14] = 155,
	[140][19] = 215,
	[141][13] = 216,
	[141][14] = 155,
	[141][19] = 217,
	[142][13] = 216,
	[142][14] = 155,
	[142][19] = 218,
	[143][13] = 216,
	[143][14] = 155,
	[143][19] = 219,
	[172][31] = 242,
	[174][31] = 243,
	[177][29] = 245,
	[178][29] = 246,
	[208][14] = 208,
	[208][30] = 249,
	[209][14] = 253,
	[210][14] = 258,
	[210][22] = 259,
	[210][32] = 257,
	[211][14] = 264,
	[211][33] = 263,
	[213][1] = 40,
	[213][2] = 41,
	[213][4] = 42,
	[213][5] = 43,
	[213][6] = 44,
	[213][7] = 266,
	[213][9] = 46,
	[213][10] = 47,
	[213][11] = 48,
	[213][12] = 49,
	[213][13] = 50,
	[213][14] = 51,
	[213][15] = 52,
	[213][17] = 53,
	[214][14] = 122,
	[214][21] = 267,
	[214][22] = 123,
	[220][12] = 269,
	[220][13] = 154,
	[220][14] = 155,
	[220][23] = 268,
	[221][12] = 269,
	[221][13] = 154,
	[221][14] = 155,
	[221][23] = 270,
	[222][1] = 144,
	[222][5] = 271,
	[222][12] = 153,
	[222][13] = 154,
	[222][14] = 155,
	[222][15] = 156,
	[222][17] = 157,
	[223][1] = 144,
	[223][12] = 153,
	[223][13] = 154,
	[223][14] = 155,
	[223][15] = 273,
	[223][17] = 157,
	[223][24] = 272,
	[224][1] = 144,
	[224][12] = 153,
	[224][13] = 154,
	[224][14] = 155,
	[224][15] = 273,
	[224][17] = 157,
	[224][24] = 274,
	[225][1] = 144,
	[225][2] = 275,
	[225][5] = 147,
	[225][12] = 153,
	[225][13] = 154,
	[225][14] = 155,
	[225][15] = 156,
	[225][17] = 157,
	[226][1] = 11,
	[226][2] = 12,
	[226][4] = 276,
	[226][5] = 15,
	[226][6] = 16,
	[226][9] = 19,
	[226][10] = 20,
	[226][11] = 21,
	[226][12] = 22,
	[226][13] = 23,
	[226][14] = 24,
	[226][15] = 25,
	[226][17] = 27,
	[227][1] = 144,
	[227][2] = 145,
	[227][5] = 147,
	[227][6] = 277,
	[227][12] = 153,
	[227][13] = 154,
	[227][14] = 155,
	[227][15] = 156,
	[227][17] = 157,
	[228][1] = 144,
	[228][2] = 145,
	[228][5] = 147,
	[228][6] = 148,
	[228][9] = 278,
	[228][12] = 153,
	[228][13] = 154,
	[228][14] = 155,
	[228][15] = 156,
	[228][17] = 157,
	[229][1] = 144,
	[229][2] = 145,
	[229][5] = 147,
	[229][6] = 148,
	[229][9] = 150,
	[229][10] = 279,
	[229][12] = 153,
	[229][13] = 154,
	[229][14] = 155,
	[229][15] = 156,
	[229][17] = 157,
	[230][1] = 144,
	[230][2] = 145,
	[230][4] = 146,
	[230][5] = 147,
	[230][6] = 148,
	[230][7] = 280,
	[230][9] = 150,
	[230][10] = 151,
	[230][11] = 152,
	[230][12] = 153,
	[230][13] = 154,
	[230][14] = 155,
	[230][15] = 156,
	[230][17] = 157,
	[231][13] = 282,
	[231][14] = 155,
	[231][25] = 281,
	[232][13] = 282,
	[232][14] = 155,
	[232][25] = 283,
	[233][13] = 282,
	[233][14] = 155,
	[233][25] = 284,
	[234][1] = 144,
	[234][12] = 153,
	[234][13] = 154,
	[234][14] = 155,
	[234][17] = 286,
	[234][26] = 285,
	[235][1] = 144,
	[235][12] = 153,
	[235][13] = 154,
	[235][14] = 155,
	[235][17] = 286,
	[235][26] = 287,
	[236][1] = 144,
	[236][12] = 153,
	[236][13] = 154,
	[236][14] = 155,
	[236][17] = 286,
	[236][26] = 288,
	[237][1] = 144,
	[237][12] = 153,
	[237][13] = 154,
	[237][14] = 155,
	[237][17] = 286,
	[237][26] = 289,
	[238][1] = 291,
	[238][12] = 153,
	[238][13] = 154,
	[238][14] = 155,
	[238][27] = 290,
	[239][1] = 291,
	[239][12] = 153,
	[239][13] = 154,
	[239][14] = 155,
	[239][27] = 292,
	[240][28] = 293,
	[241][1] = 11,
	[241][2] = 12,
	[241][4] = 14,
	[241][5] = 15,
	[241][6] = 16,
	[241][7] = 88,
	[241][9] = 19,
	[241][10] = 20,
	[241][11] = 21,
	[241][12] = 22,
	[241][13] = 23,
	[241][14] = 24,
	[241][15] = 25,
	[241][17] = 27,
	[241][20] = 294,
	[247][1] = 40,
	[247][2] = 41,
	[247][4] = 295,
	[247][5] = 43,
	[247][6] = 44,
	[247][9] = 46,
	[247][10] = 47,
	[247][11] = 48,
	[247][12] = 49,
	[247][13] = 50,
	[247][14] = 51,
	[247][15] = 52,
	[247][17] = 53,
	[251][1] = 40,
	[251][2] = 41,
	[251][4] = 42,
	[251][5] = 43,
	[251][6] = 44,
	[251][7] = 296,
	[251][9] = 46,
	[251][10] = 47,
	[251][11] = 48,
	[251][12] = 49,
	[251][13] = 50,
	[251][14] = 51,
	[251][15] = 52,
	[251][17] = 53,
	[253][34] = 299,
	[255][1] = 40,
	[255][2] = 41,
	[255][4] = 42,
	[255][5] = 43,
	[255][6] = 44,
	[255][7] = 300,
	[255][9] = 46,
	[255][10] = 47,
	[255][11] = 48,
	[255][12] = 49,
	[255][13] = 50,
	[255][14] = 51,
	[255][15] = 52,
	[255][17] = 53,
	[258][14] = 302,
	[258][30] = 301,
	[259][34] = 303,
	[261][1] = 40,
	[261][2] = 41,
	[261][4] = 42,
	[261][5] = 43,
	[261][6] = 44,
	[261][7] = 304,
	[261][9] = 46,
	[261][10] = 47,
	[261][11] = 48,
	[261][12] = 49,
	[261][13] = 50,
	[261][14] = 51,
	[261][15] = 52,
	[261][17] = 53,
	[266][29] = 306,
	[267][29] = 307,
	[297][14] = 258,
	[297][22] = 259,
	[297][32] = 310,
	[298][14] = 264,
	[298][33] = 311,
	[302][14] = 302,
	[302][30] = 313,
	[308][1] = 144,
	[308][2] = 145,
	[308][4] = 315,
	[308][5] = 147,
	[308][6] = 148,
	[308][9] = 150,
	[308][10] = 151,
	[308][11] = 152,
	[308][12] = 153,
	[308][13] = 154,
	[308][14] = 155,
	[308][15] = 156,
	[308][17] = 157,
};


const unsigned zebu_lexer[109][256] = {
	[1][9] = 48,
	[1][10] = 48,
	[1][32] = 48,
	[1][33] = 49,
	[1][34] = 50,
	[1][40] = 51,
	[1][43] = 52,
	[1][45] = 53,
	[1][47] = 54,
	[1][48] = 55,
	[1][49] = 55,
	[1][50] = 55,
	[1][51] = 55,
	[1][52] = 55,
	[1][53] = 55,
	[1][54] = 55,
	[1][55] = 55,
	[1][56] = 55,
	[1][57] = 55,
	[1][102] = 56,
	[1][115] = 57,
	[1][126] = 58,
	[2][9] = 48,
	[2][10] = 48,
	[2][32] = 48,
	[2][33] = 59,
	[2][37] = 60,
	[2][38] = 61,
	[2][40] = 51,
	[2][42] = 62,
	[2][43] = 52,
	[2][45] = 53,
	[2][47] = 63,
	[2][58] = 64,
	[2][59] = 65,
	[2][60] = 66,
	[2][61] = 67,
	[2][62] = 68,
	[2][63] = 69,
	[2][94] = 70,
	[2][124] = 71,
	[3][9] = 48,
	[3][10] = 48,
	[3][32] = 48,
	[3][33] = 59,
	[3][37] = 60,
	[3][38] = 61,
	[3][42] = 62,
	[3][43] = 52,
	[3][45] = 53,
	[3][47] = 63,
	[3][59] = 65,
	[3][60] = 66,
	[3][61] = 67,
	[3][62] = 68,
	[3][63] = 69,
	[3][94] = 70,
	[3][124] = 71,
	[4][9] = 48,
	[4][10] = 48,
	[4][32] = 48,
	[4][40] = 51,
	[4][47] = 54,
	[5][9] = 48,
	[5][10] = 48,
	[5][32] = 48,
	[5][33] = 59,
	[5][38] = 61,
	[5][43] = 52,
	[5][45] = 53,
	[5][47] = 54,
	[5][59] = 65,
	[5][60] = 66,
	[5][61] = 67,
	[5][62] = 68,
	[5][63] = 69,
	[5][94] = 70,
	[5][124] = 71,
	[6][9] = 48,
	[6][10] = 48,
	[6][32] = 48,
	[6][38] = 61,
	[6][47] = 54,
	[6][59] = 65,
	[6][63] = 69,
	[6][94] = 70,
	[6][124] = 71,
	[7][9] = 48,
	[7][10] = 48,
	[7][32] = 48,
	[7][33] = 49,
	[7][34] = 50,
	[7][40] = 51,
	[7][43] = 52,
	[7][45] = 72,
	[7][47] = 54,
	[7][48] = 55,
	[7][49] = 55,
	[7][50] = 55,
	[7][51] = 55,
	[7][52] = 55,
	[7][53] = 55,
	[7][54] = 55,
	[7][55] = 55,
	[7][56] = 55,
	[7][57] = 55,
	[7][102] = 56,
	[7][115] = 57,
	[7][126] = 58,
	[8][9] = 48,
	[8][10] = 48,
	[8][32] = 48,
	[8][47] = 54,
	[8][59] = 65,
	[9][9] = 48,
	[9][10] = 48,
	[9][32] = 48,
	[9][33] = 59,
	[9][38] = 61,
	[9][47] = 54,
	[9][59] = 65,
	[9][61] = 67,
	[9][63] = 69,
	[9][94] = 70,
	[9][124] = 71,
	[10][9] = 48,
	[10][10] = 48,
	[10][32] = 48,
	[10][38] = 74,
	[10][47] = 54,
	[10][59] = 65,
	[10][63] = 69,
	[10][94] = 70,
	[10][124] = 71,
	[11][9] = 48,
	[11][10] = 48,
	[11][32] = 48,
	[11][38] = 74,
	[11][47] = 54,
	[11][59] = 65,
	[11][63] = 69,
	[11][124] = 71,
	[12][9] = 48,
	[12][10] = 48,
	[12][32] = 48,
	[12][38] = 74,
	[12][47] = 54,
	[12][59] = 65,
	[12][63] = 69,
	[12][124] = 75,
	[13][9] = 48,
	[13][10] = 48,
	[13][32] = 48,
	[13][47] = 54,
	[13][59] = 65,
	[13][63] = 69,
	[13][124] = 75,
	[14][9] = 48,
	[14][10] = 48,
	[14][32] = 48,
	[14][33] = 59,
	[14][38] = 61,
	[14][47] = 54,
	[14][59] = 65,
	[14][60] = 76,
	[14][61] = 67,
	[14][62] = 77,
	[14][63] = 69,
	[14][94] = 70,
	[14][124] = 71,
	[15][9] = 48,
	[15][10] = 48,
	[15][32] = 48,
	[15][47] = 54,
	[16][9] = 48,
	[16][10] = 48,
	[16][32] = 48,
	[16][33] = 59,
	[16][38] = 61,
	[16][47] = 54,
	[16][59] = 65,
	[16][60] = 66,
	[16][61] = 67,
	[16][62] = 68,
	[16][63] = 69,
	[16][94] = 70,
	[16][124] = 71,
	[17][9] = 48,
	[17][10] = 48,
	[17][32] = 48,
	[17][45] = 78,
	[17][47] = 54,
	[18][9] = 48,
	[18][10] = 48,
	[18][32] = 48,
	[18][43] = 79,
	[18][45] = 79,
	[18][47] = 54,
	[18][48] = 80,
	[18][49] = 80,
	[18][50] = 80,
	[18][51] = 80,
	[18][52] = 80,
	[18][53] = 80,
	[18][54] = 80,
	[18][55] = 80,
	[18][61] = 79,
	[18][97] = 81,
	[18][103] = 81,
	[18][111] = 81,
	[18][117] = 81,
	[19][9] = 48,
	[19][10] = 48,
	[19][32] = 48,
	[19][33] = 59,
	[19][37] = 60,
	[19][38] = 61,
	[19][41] = 82,
	[19][42] = 62,
	[19][43] = 52,
	[19][45] = 53,
	[19][47] = 63,
	[19][60] = 66,
	[19][61] = 67,
	[19][62] = 68,
	[19][63] = 69,
	[19][94] = 70,
	[19][124] = 71,
	[20][9] = 48,
	[20][10] = 48,
	[20][32] = 48,
	[20][33] = 59,
	[20][38] = 61,
	[20][41] = 82,
	[20][43] = 52,
	[20][45] = 53,
	[20][47] = 54,
	[20][60] = 66,
	[20][61] = 67,
	[20][62] = 68,
	[20][63] = 69,
	[20][94] = 70,
	[20][124] = 71,
	[21][9] = 48,
	[21][10] = 48,
	[21][32] = 48,
	[21][38] = 61,
	[21][41] = 82,
	[21][47] = 54,
	[21][63] = 69,
	[21][94] = 70,
	[21][124] = 71,
	[22][9] = 48,
	[22][10] = 48,
	[22][32] = 48,
	[22][41] = 82,
	[22][47] = 54,
	[23][9] = 48,
	[23][10] = 48,
	[23][32] = 48,
	[23][33] = 59,
	[23][38] = 61,
	[23][41] = 82,
	[23][47] = 54,
	[23][61] = 67,
	[23][63] = 69,
	[23][94] = 70,
	[23][124] = 71,
	[24][9] = 48,
	[24][10] = 48,
	[24][32] = 48,
	[24][38] = 74,
	[24][41] = 82,
	[24][47] = 54,
	[24][63] = 69,
	[24][94] = 70,
	[24][124] = 71,
	[25][9] = 48,
	[25][10] = 48,
	[25][32] = 48,
	[25][38] = 74,
	[25][41] = 82,
	[25][47] = 54,
	[25][63] = 69,
	[25][124] = 71,
	[26][9] = 48,
	[26][10] = 48,
	[26][32] = 48,
	[26][38] = 74,
	[26][41] = 82,
	[26][47] = 54,
	[26][63] = 69,
	[26][124] = 75,
	[27][9] = 48,
	[27][10] = 48,
	[27][32] = 48,
	[27][41] = 82,
	[27][47] = 54,
	[27][63] = 69,
	[27][124] = 75,
	[28][9] = 48,
	[28][10] = 48,
	[28][32] = 48,
	[28][33] = 59,
	[28][38] = 61,
	[28][41] = 82,
	[28][47] = 54,
	[28][60] = 76,
	[28][61] = 67,
	[28][62] = 77,
	[28][63] = 69,
	[28][94] = 70,
	[28][124] = 71,
	[29][9] = 48,
	[29][10] = 48,
	[29][32] = 48,
	[29][33] = 59,
	[29][38] = 61,
	[29][41] = 82,
	[29][47] = 54,
	[29][60] = 66,
	[29][61] = 67,
	[29][62] = 68,
	[29][63] = 69,
	[29][94] = 70,
	[29][124] = 71,
	[30][9] = 48,
	[30][10] = 48,
	[30][32] = 48,
	[30][34] = 50,
	[30][40] = 51,
	[30][47] = 54,
	[30][48] = 55,
	[30][49] = 55,
	[30][50] = 55,
	[30][51] = 55,
	[30][52] = 55,
	[30][53] = 55,
	[30][54] = 55,
	[30][55] = 55,
	[30][56] = 55,
	[30][57] = 55,
	[31][9] = 48,
	[31][10] = 48,
	[31][32] = 48,
	[31][41] = 82,
	[31][44] = 83,
	[31][47] = 54,
	[32][9] = 48,
	[32][10] = 48,
	[32][32] = 48,
	[32][34] = 50,
	[32][40] = 51,
	[32][41] = 82,
	[32][47] = 54,
	[32][48] = 55,
	[32][49] = 55,
	[32][50] = 55,
	[32][51] = 55,
	[32][52] = 55,
	[32][53] = 55,
	[32][54] = 55,
	[32][55] = 55,
	[32][56] = 55,
	[32][57] = 55,
	[32][60] = 84,
	[32][62] = 85,
	[32][124] = 86,
	[33][9] = 48,
	[33][10] = 48,
	[33][32] = 48,
	[33][41] = 82,
	[33][47] = 54,
	[33][60] = 84,
	[33][62] = 85,
	[33][124] = 86,
	[34][9] = 48,
	[34][10] = 48,
	[34][32] = 48,
	[34][33] = 59,
	[34][37] = 60,
	[34][38] = 61,
	[34][42] = 62,
	[34][43] = 52,
	[34][45] = 53,
	[34][47] = 63,
	[34][58] = 64,
	[34][60] = 66,
	[34][61] = 67,
	[34][62] = 68,
	[34][63] = 69,
	[34][94] = 70,
	[34][124] = 71,
	[35][9] = 48,
	[35][10] = 48,
	[35][32] = 48,
	[35][33] = 59,
	[35][38] = 61,
	[35][43] = 52,
	[35][45] = 53,
	[35][47] = 54,
	[35][58] = 64,
	[35][60] = 66,
	[35][61] = 67,
	[35][62] = 68,
	[35][63] = 69,
	[35][94] = 70,
	[35][124] = 71,
	[36][9] = 48,
	[36][10] = 48,
	[36][32] = 48,
	[36][38] = 61,
	[36][47] = 54,
	[36][58] = 64,
	[36][63] = 69,
	[36][94] = 70,
	[36][124] = 71,
	[37][9] = 48,
	[37][10] = 48,
	[37][32] = 48,
	[37][47] = 54,
	[37][58] = 64,
	[38][9] = 48,
	[38][10] = 48,
	[38][32] = 48,
	[38][33] = 59,
	[38][38] = 61,
	[38][47] = 54,
	[38][58] = 64,
	[38][61] = 67,
	[38][63] = 69,
	[38][94] = 70,
	[38][124] = 71,
	[39][9] = 48,
	[39][10] = 48,
	[39][32] = 48,
	[39][38] = 74,
	[39][47] = 54,
	[39][58] = 64,
	[39][63] = 69,
	[39][94] = 70,
	[39][124] = 71,
	[40][9] = 48,
	[40][10] = 48,
	[40][32] = 48,
	[40][38] = 74,
	[40][47] = 54,
	[40][58] = 64,
	[40][63] = 69,
	[40][124] = 71,
	[41][9] = 48,
	[41][10] = 48,
	[41][32] = 48,
	[41][38] = 74,
	[41][47] = 54,
	[41][58] = 64,
	[41][63] = 69,
	[41][124] = 75,
	[42][9] = 48,
	[42][10] = 48,
	[42][32] = 48,
	[42][47] = 54,
	[42][58] = 64,
	[42][63] = 69,
	[42][124] = 75,
	[43][9] = 48,
	[43][10] = 48,
	[43][32] = 48,
	[43][33] = 59,
	[43][38] = 61,
	[43][47] = 54,
	[43][58] = 64,
	[43][60] = 76,
	[43][61] = 67,
	[43][62] = 77,
	[43][63] = 69,
	[43][94] = 70,
	[43][124] = 71,
	[44][9] = 48,
	[44][10] = 48,
	[44][32] = 48,
	[44][33] = 59,
	[44][38] = 61,
	[44][47] = 54,
	[44][58] = 64,
	[44][60] = 66,
	[44][61] = 67,
	[44][62] = 68,
	[44][63] = 69,
	[44][94] = 70,
	[44][124] = 71,
	[45][9] = 48,
	[45][10] = 48,
	[45][32] = 48,
	[45][43] = 79,
	[45][45] = 79,
	[45][47] = 54,
	[45][61] = 79,
	[45][97] = 81,
	[45][103] = 81,
	[45][111] = 81,
	[45][117] = 81,
	[46][9] = 48,
	[46][10] = 48,
	[46][32] = 48,
	[46][41] = 82,
	[46][47] = 54,
	[46][62] = 85,
	[46][124] = 86,
	[47][9] = 48,
	[47][10] = 48,
	[47][32] = 48,
	[47][34] = 50,
	[47][40] = 51,
	[47][41] = 82,
	[47][47] = 54,
	[47][48] = 55,
	[47][49] = 55,
	[47][50] = 55,
	[47][51] = 55,
	[47][52] = 55,
	[47][53] = 55,
	[47][54] = 55,
	[47][55] = 55,
	[47][56] = 55,
	[47][57] = 55,
	[47][62] = 85,
	[47][124] = 86,
	[48][9] = 48,
	[48][10] = 48,
	[48][32] = 48,
	[48][47] = 54,
	[50][0] = 50,
	[50][1] = 50,
	[50][2] = 50,
	[50][3] = 50,
	[50][4] = 50,
	[50][5] = 50,
	[50][6] = 50,
	[50][7] = 50,
	[50][8] = 50,
	[50][9] = 50,
	[50][10] = 50,
	[50][11] = 50,
	[50][12] = 50,
	[50][13] = 50,
	[50][14] = 50,
	[50][15] = 50,
	[50][16] = 50,
	[50][17] = 50,
	[50][18] = 50,
	[50][19] = 50,
	[50][20] = 50,
	[50][21] = 50,
	[50][22] = 50,
	[50][23] = 50,
	[50][24] = 50,
	[50][25] = 50,
	[50][26] = 50,
	[50][27] = 50,
	[50][28] = 50,
	[50][29] = 50,
	[50][30] = 50,
	[50][31] = 50,
	[50][32] = 50,
	[50][33] = 50,
	[50][34] = 87,
	[50][35] = 50,
	[50][36] = 50,
	[50][37] = 50,
	[50][38] = 50,
	[50][39] = 50,
	[50][40] = 50,
	[50][41] = 50,
	[50][42] = 50,
	[50][43] = 50,
	[50][44] = 50,
	[50][45] = 50,
	[50][46] = 50,
	[50][47] = 50,
	[50][48] = 50,
	[50][49] = 50,
	[50][50] = 50,
	[50][51] = 50,
	[50][52] = 50,
	[50][53] = 50,
	[50][54] = 50,
	[50][55] = 50,
	[50][56] = 50,
	[50][57] = 50,
	[50][58] = 50,
	[50][59] = 50,
	[50][60] = 50,
	[50][61] = 50,
	[50][62] = 50,
	[50][63] = 50,
	[50][64] = 50,
	[50][65] = 50,
	[50][66] = 50,
	[50][67] = 50,
	[50][68] = 50,
	[50][69] = 50,
	[50][70] = 50,
	[50][71] = 50,
	[50][72] = 50,
	[50][73] = 50,
	[50][74] = 50,
	[50][75] = 50,
	[50][76] = 50,
	[50][77] = 50,
	[50][78] = 50,
	[50][79] = 50,
	[50][80] = 50,
	[50][81] = 50,
	[50][82] = 50,
	[50][83] = 50,
	[50][84] = 50,
	[50][85] = 50,
	[50][86] = 50,
	[50][87] = 50,
	[50][88] = 50,
	[50][89] = 50,
	[50][90] = 50,
	[50][91] = 50,
	[50][92] = 88,
	[50][93] = 50,
	[50][94] = 50,
	[50][95] = 50,
	[50][96] = 50,
	[50][97] = 50,
	[50][98] = 50,
	[50][99] = 50,
	[50][100] = 50,
	[50][101] = 50,
	[50][102] = 50,
	[50][103] = 50,
	[50][104] = 50,
	[50][105] = 50,
	[50][106] = 50,
	[50][107] = 50,
	[50][108] = 50,
	[50][109] = 50,
	[50][110] = 50,
	[50][111] = 50,
	[50][112] = 50,
	[50][113] = 50,
	[50][114] = 50,
	[50][115] = 50,
	[50][116] = 50,
	[50][117] = 50,
	[50][118] = 50,
	[50][119] = 50,
	[50][120] = 50,
	[50][121] = 50,
	[50][122] = 50,
	[50][123] = 50,
	[50][124] = 50,
	[50][125] = 50,
	[50][126] = 50,
	[50][127] = 50,
	[50][128] = 50,
	[50][129] = 50,
	[50][130] = 50,
	[50][131] = 50,
	[50][132] = 50,
	[50][133] = 50,
	[50][134] = 50,
	[50][135] = 50,
	[50][136] = 50,
	[50][137] = 50,
	[50][138] = 50,
	[50][139] = 50,
	[50][140] = 50,
	[50][141] = 50,
	[50][142] = 50,
	[50][143] = 50,
	[50][144] = 50,
	[50][145] = 50,
	[50][146] = 50,
	[50][147] = 50,
	[50][148] = 50,
	[50][149] = 50,
	[50][150] = 50,
	[50][151] = 50,
	[50][152] = 50,
	[50][153] = 50,
	[50][154] = 50,
	[50][155] = 50,
	[50][156] = 50,
	[50][157] = 50,
	[50][158] = 50,
	[50][159] = 50,
	[50][160] = 50,
	[50][161] = 50,
	[50][162] = 50,
	[50][163] = 50,
	[50][164] = 50,
	[50][165] = 50,
	[50][166] = 50,
	[50][167] = 50,
	[50][168] = 50,
	[50][169] = 50,
	[50][170] = 50,
	[50][171] = 50,
	[50][172] = 50,
	[50][173] = 50,
	[50][174] = 50,
	[50][175] = 50,
	[50][176] = 50,
	[50][177] = 50,
	[50][178] = 50,
	[50][179] = 50,
	[50][180] = 50,
	[50][181] = 50,
	[50][182] = 50,
	[50][183] = 50,
	[50][184] = 50,
	[50][185] = 50,
	[50][186] = 50,
	[50][187] = 50,
	[50][188] = 50,
	[50][189] = 50,
	[50][190] = 50,
	[50][191] = 50,
	[50][192] = 50,
	[50][193] = 50,
	[50][194] = 50,
	[50][195] = 50,
	[50][196] = 50,
	[50][197] = 50,
	[50][198] = 50,
	[50][199] = 50,
	[50][200] = 50,
	[50][201] = 50,
	[50][202] = 50,
	[50][203] = 50,
	[50][204] = 50,
	[50][205] = 50,
	[50][206] = 50,
	[50][207] = 50,
	[50][208] = 50,
	[50][209] = 50,
	[50][210] = 50,
	[50][211] = 50,
	[50][212] = 50,
	[50][213] = 50,
	[50][214] = 50,
	[50][215] = 50,
	[50][216] = 50,
	[50][217] = 50,
	[50][218] = 50,
	[50][219] = 50,
	[50][220] = 50,
	[50][221] = 50,
	[50][222] = 50,
	[50][223] = 50,
	[50][224] = 50,
	[50][225] = 50,
	[50][226] = 50,
	[50][227] = 50,
	[50][228] = 50,
	[50][229] = 50,
	[50][230] = 50,
	[50][231] = 50,
	[50][232] = 50,
	[50][233] = 50,
	[50][234] = 50,
	[50][235] = 50,
	[50][236] = 50,
	[50][237] = 50,
	[50][238] = 50,
	[50][239] = 50,
	[50][240] = 50,
	[50][241] = 50,
	[50][242] = 50,
	[50][243] = 50,
	[50][244] = 50,
	[50][245] = 50,
	[50][246] = 50,
	[50][247] = 50,
	[50][248] = 50,
	[50][249] = 50,
	[50][250] = 50,
	[50][251] = 50,
	[50][252] = 50,
	[50][253] = 50,
	[50][254] = 50,
	[50][255] = 50,
	[54][47] = 89,
	[55][48] = 55,
	[55][49] = 55,
	[55][50] = 55,
	[55][51] = 55,
	[55][52] = 55,
	[55][53] = 55,
	[55][54] = 55,
	[55][55] = 55,
	[55][56] = 55,
	[55][57] = 55,
	[56][105] = 90,
	[57][104] = 91,
	[59][61] = 92,
	[61][38] = 93,
	[63][47] = 89,
	[66][60] = 94,
	[66][61] = 95,
	[67][61] = 96,
	[68][61] = 97,
	[68][62] = 98,
	[71][124] = 99,
	[72][45] = 100,
	[74][38] = 93,
	[75][124] = 99,
	[76][61] = 95,
	[77][61] = 97,
	[78][45] = 100,
	[79][43] = 79,
	[79][45] = 79,
	[79][61] = 79,
	[79][88] = 79,
	[79][103] = 101,
	[79][111] = 101,
	[79][114] = 79,
	[79][115] = 79,
	[79][116] = 79,
	[79][117] = 101,
	[79][119] = 79,
	[79][120] = 79,
	[80][48] = 102,
	[80][49] = 102,
	[80][50] = 102,
	[80][51] = 102,
	[80][52] = 102,
	[80][53] = 102,
	[80][54] = 102,
	[80][55] = 102,
	[81][43] = 79,
	[81][45] = 79,
	[81][61] = 79,
	[81][97] = 81,
	[81][103] = 81,
	[81][111] = 81,
	[81][117] = 81,
	[88][34] = 50,
	[88][92] = 50,
	[88][110] = 50,
	[88][116] = 50,
	[89][0] = 89,
	[89][1] = 89,
	[89][2] = 89,
	[89][3] = 89,
	[89][4] = 89,
	[89][5] = 89,
	[89][6] = 89,
	[89][7] = 89,
	[89][8] = 89,
	[89][9] = 89,
	[89][10] = 48,
	[89][11] = 89,
	[89][12] = 89,
	[89][13] = 89,
	[89][14] = 89,
	[89][15] = 89,
	[89][16] = 89,
	[89][17] = 89,
	[89][18] = 89,
	[89][19] = 89,
	[89][20] = 89,
	[89][21] = 89,
	[89][22] = 89,
	[89][23] = 89,
	[89][24] = 89,
	[89][25] = 89,
	[89][26] = 89,
	[89][27] = 89,
	[89][28] = 89,
	[89][29] = 89,
	[89][30] = 89,
	[89][31] = 89,
	[89][32] = 89,
	[89][33] = 89,
	[89][34] = 89,
	[89][35] = 89,
	[89][36] = 89,
	[89][37] = 89,
	[89][38] = 89,
	[89][39] = 89,
	[89][40] = 89,
	[89][41] = 89,
	[89][42] = 89,
	[89][43] = 89,
	[89][44] = 89,
	[89][45] = 89,
	[89][46] = 89,
	[89][47] = 89,
	[89][48] = 89,
	[89][49] = 89,
	[89][50] = 89,
	[89][51] = 89,
	[89][52] = 89,
	[89][53] = 89,
	[89][54] = 89,
	[89][55] = 89,
	[89][56] = 89,
	[89][57] = 89,
	[89][58] = 89,
	[89][59] = 89,
	[89][60] = 89,
	[89][61] = 89,
	[89][62] = 89,
	[89][63] = 89,
	[89][64] = 89,
	[89][65] = 89,
	[89][66] = 89,
	[89][67] = 89,
	[89][68] = 89,
	[89][69] = 89,
	[89][70] = 89,
	[89][71] = 89,
	[89][72] = 89,
	[89][73] = 89,
	[89][74] = 89,
	[89][75] = 89,
	[89][76] = 89,
	[89][77] = 89,
	[89][78] = 89,
	[89][79] = 89,
	[89][80] = 89,
	[89][81] = 89,
	[89][82] = 89,
	[89][83] = 89,
	[89][84] = 89,
	[89][85] = 89,
	[89][86] = 89,
	[89][87] = 89,
	[89][88] = 89,
	[89][89] = 89,
	[89][90] = 89,
	[89][91] = 89,
	[89][92] = 89,
	[89][93] = 89,
	[89][94] = 89,
	[89][95] = 89,
	[89][96] = 89,
	[89][97] = 89,
	[89][98] = 89,
	[89][99] = 89,
	[89][100] = 89,
	[89][101] = 89,
	[89][102] = 89,
	[89][103] = 89,
	[89][104] = 89,
	[89][105] = 89,
	[89][106] = 89,
	[89][107] = 89,
	[89][108] = 89,
	[89][109] = 89,
	[89][110] = 89,
	[89][111] = 89,
	[89][112] = 89,
	[89][113] = 89,
	[89][114] = 89,
	[89][115] = 89,
	[89][116] = 89,
	[89][117] = 89,
	[89][118] = 89,
	[89][119] = 89,
	[89][120] = 89,
	[89][121] = 89,
	[89][122] = 89,
	[89][123] = 89,
	[89][124] = 89,
	[89][125] = 89,
	[89][126] = 89,
	[89][127] = 89,
	[89][128] = 89,
	[89][129] = 89,
	[89][130] = 89,
	[89][131] = 89,
	[89][132] = 89,
	[89][133] = 89,
	[89][134] = 89,
	[89][135] = 89,
	[89][136] = 89,
	[89][137] = 89,
	[89][138] = 89,
	[89][139] = 89,
	[89][140] = 89,
	[89][141] = 89,
	[89][142] = 89,
	[89][143] = 89,
	[89][144] = 89,
	[89][145] = 89,
	[89][146] = 89,
	[89][147] = 89,
	[89][148] = 89,
	[89][149] = 89,
	[89][150] = 89,
	[89][151] = 89,
	[89][152] = 89,
	[89][153] = 89,
	[89][154] = 89,
	[89][155] = 89,
	[89][156] = 89,
	[89][157] = 89,
	[89][158] = 89,
	[89][159] = 89,
	[89][160] = 89,
	[89][161] = 89,
	[89][162] = 89,
	[89][163] = 89,
	[89][164] = 89,
	[89][165] = 89,
	[89][166] = 89,
	[89][167] = 89,
	[89][168] = 89,
	[89][169] = 89,
	[89][170] = 89,
	[89][171] = 89,
	[89][172] = 89,
	[89][173] = 89,
	[89][174] = 89,
	[89][175] = 89,
	[89][176] = 89,
	[89][177] = 89,
	[89][178] = 89,
	[89][179] = 89,
	[89][180] = 89,
	[89][181] = 89,
	[89][182] = 89,
	[89][183] = 89,
	[89][184] = 89,
	[89][185] = 89,
	[89][186] = 89,
	[89][187] = 89,
	[89][188] = 89,
	[89][189] = 89,
	[89][190] = 89,
	[89][191] = 89,
	[89][192] = 89,
	[89][193] = 89,
	[89][194] = 89,
	[89][195] = 89,
	[89][196] = 89,
	[89][197] = 89,
	[89][198] = 89,
	[89][199] = 89,
	[89][200] = 89,
	[89][201] = 89,
	[89][202] = 89,
	[89][203] = 89,
	[89][204] = 89,
	[89][205] = 89,
	[89][206] = 89,
	[89][207] = 89,
	[89][208] = 89,
	[89][209] = 89,
	[89][210] = 89,
	[89][211] = 89,
	[89][212] = 89,
	[89][213] = 89,
	[89][214] = 89,
	[89][215] = 89,
	[89][216] = 89,
	[89][217] = 89,
	[89][218] = 89,
	[89][219] = 89,
	[89][220] = 89,
	[89][221] = 89,
	[89][222] = 89,
	[89][223] = 89,
	[89][224] = 89,
	[89][225] = 89,
	[89][226] = 89,
	[89][227] = 89,
	[89][228] = 89,
	[89][229] = 89,
	[89][230] = 89,
	[89][231] = 89,
	[89][232] = 89,
	[89][233] = 89,
	[89][234] = 89,
	[89][235] = 89,
	[89][236] = 89,
	[89][237] = 89,
	[89][238] = 89,
	[89][239] = 89,
	[89][240] = 89,
	[89][241] = 89,
	[89][242] = 89,
	[89][243] = 89,
	[89][244] = 89,
	[89][245] = 89,
	[89][246] = 89,
	[89][247] = 89,
	[89][248] = 89,
	[89][249] = 89,
	[89][250] = 89,
	[89][251] = 89,
	[89][252] = 89,
	[89][253] = 89,
	[89][254] = 89,
	[89][255] = 89,
	[90][108] = 103,
	[91][101] = 104,
	[100][45] = 105,
	[101][43] = 79,
	[101][45] = 79,
	[101][61] = 79,
	[102][48] = 106,
	[102][49] = 106,
	[102][50] = 106,
	[102][51] = 106,
	[102][52] = 106,
	[102][53] = 106,
	[102][54] = 106,
	[102][55] = 106,
	[103][101] = 107,
	[104][108] = 108,
	[108][108] = 109,
};


const unsigned zebu_lexer_starts[316] = {
	[1] = 1,
	[2] = 2,
	[3] = 1,
	[4] = 3,
	[5] = 4,
	[6] = 4,
	[7] = 1,
	[8] = 1,
	[9] = 1,
	[10] = 1,
	[11] = 5,
	[12] = 6,
	[13] = 7,
	[14] = 8,
	[15] = 9,
	[16] = 10,
	[17] = 8,
	[18] = 7,
	[19] = 11,
	[20] = 12,
	[21] = 13,
	[22] = 3,
	[23] = 3,
	[24] = 3,
	[25] = 14,
	[26] = 15,
	[27] = 16,
	[28] = 17,
	[29] = 18,
	[30] = 1,
	[31] = 19,
	[32] = 1,
	[33] = 19,
	[34] = 4,
	[35] = 4,
	[36] = 1,
	[37] = 1,
	[38] = 1,
	[39] = 1,
	[40] = 20,
	[41] = 21,
	[42] = 22,
	[43] = 23,
	[44] = 24,
	[45] = 22,
	[46] = 25,
	[47] = 26,
	[48] = 27,
	[49] = 19,
	[50] = 19,
	[51] = 19,
	[52] = 28,
	[53] = 29,
	[54] = 1,
	[55] = 30,
	[56] = 3,
	[57] = 3,
	[58] = 3,
	[59] = 3,
	[60] = 3,
	[61] = 3,
	[62] = 1,
	[63] = 1,
	[64] = 1,
	[65] = 17,
	[66] = 1,
	[67] = 1,
	[68] = 1,
	[69] = 7,
	[70] = 17,
	[71] = 1,
	[72] = 1,
	[73] = 1,
	[74] = 1,
	[75] = 1,
	[76] = 1,
	[77] = 1,
	[78] = 1,
	[79] = 1,
	[80] = 1,
	[81] = 1,
	[82] = 1,
	[83] = 1,
	[84] = 1,
	[85] = 31,
	[86] = 22,
	[87] = 7,
	[88] = 8,
	[89] = 22,
	[90] = 1,
	[91] = 30,
	[92] = 19,
	[93] = 19,
	[94] = 19,
	[95] = 19,
	[96] = 19,
	[97] = 1,
	[98] = 1,
	[99] = 1,
	[100] = 1,
	[101] = 1,
	[102] = 1,
	[103] = 3,
	[104] = 1,
	[105] = 1,
	[106] = 1,
	[107] = 1,
	[108] = 1,
	[109] = 1,
	[110] = 1,
	[111] = 1,
	[112] = 1,
	[113] = 1,
	[114] = 1,
	[115] = 1,
	[116] = 1,
	[117] = 22,
	[118] = 32,
	[119] = 1,
	[120] = 32,
	[121] = 22,
	[122] = 32,
	[123] = 33,
	[124] = 5,
	[125] = 3,
	[126] = 5,
	[127] = 9,
	[128] = 9,
	[129] = 14,
	[130] = 9,
	[131] = 6,
	[132] = 10,
	[133] = 11,
	[134] = 12,
	[135] = 34,
	[136] = 1,
	[137] = 34,
	[138] = 4,
	[139] = 4,
	[140] = 1,
	[141] = 1,
	[142] = 1,
	[143] = 1,
	[144] = 35,
	[145] = 36,
	[146] = 37,
	[147] = 38,
	[148] = 39,
	[149] = 37,
	[150] = 40,
	[151] = 41,
	[152] = 42,
	[153] = 34,
	[154] = 34,
	[155] = 34,
	[156] = 43,
	[157] = 44,
	[158] = 3,
	[159] = 3,
	[160] = 3,
	[161] = 3,
	[162] = 14,
	[163] = 16,
	[164] = 14,
	[165] = 14,
	[166] = 14,
	[167] = 16,
	[168] = 5,
	[169] = 16,
	[170] = 15,
	[171] = 45,
	[172] = 37,
	[173] = 7,
	[174] = 37,
	[175] = 7,
	[176] = 19,
	[177] = 22,
	[178] = 22,
	[179] = 20,
	[180] = 19,
	[181] = 20,
	[182] = 23,
	[183] = 23,
	[184] = 28,
	[185] = 23,
	[186] = 21,
	[187] = 24,
	[188] = 25,
	[189] = 26,
	[190] = 37,
	[191] = 19,
	[192] = 19,
	[193] = 19,
	[194] = 19,
	[195] = 28,
	[196] = 29,
	[197] = 28,
	[198] = 28,
	[199] = 28,
	[200] = 29,
	[201] = 20,
	[202] = 29,
	[203] = 3,
	[204] = 3,
	[205] = 22,
	[206] = 3,
	[207] = 33,
	[208] = 32,
	[209] = 30,
	[210] = 30,
	[211] = 30,
	[212] = 22,
	[213] = 1,
	[214] = 30,
	[215] = 34,
	[216] = 34,
	[217] = 34,
	[218] = 34,
	[219] = 34,
	[220] = 1,
	[221] = 1,
	[222] = 1,
	[223] = 1,
	[224] = 1,
	[225] = 1,
	[226] = 1,
	[227] = 1,
	[228] = 1,
	[229] = 1,
	[230] = 1,
	[231] = 1,
	[232] = 1,
	[233] = 1,
	[234] = 1,
	[235] = 1,
	[236] = 1,
	[237] = 1,
	[238] = 1,
	[239] = 1,
	[240] = 31,
	[241] = 1,
	[242] = 7,
	[243] = 7,
	[244] = 19,
	[245] = 19,
	[246] = 19,
	[247] = 1,
	[248] = 32,
	[249] = 33,
	[250] = 46,
	[251] = 1,
	[252] = 46,
	[253] = 46,
	[254] = 47,
	[255] = 1,
	[256] = 47,
	[257] = 22,
	[258] = 47,
	[259] = 46,
	[260] = 22,
	[261] = 1,
	[262] = 22,
	[263] = 22,
	[264] = 22,
	[265] = 34,
	[266] = 22,
	[267] = 22,
	[268] = 35,
	[269] = 34,
	[270] = 35,
	[271] = 38,
	[272] = 38,
	[273] = 43,
	[274] = 38,
	[275] = 36,
	[276] = 8,
	[277] = 39,
	[278] = 40,
	[279] = 41,
	[280] = 37,
	[281] = 34,
	[282] = 34,
	[283] = 34,
	[284] = 34,
	[285] = 43,
	[286] = 44,
	[287] = 43,
	[288] = 43,
	[289] = 43,
	[290] = 44,
	[291] = 35,
	[292] = 44,
	[293] = 7,
	[294] = 7,
	[295] = 22,
	[296] = 22,
	[297] = 30,
	[298] = 30,
	[299] = 22,
	[300] = 22,
	[301] = 46,
	[302] = 47,
	[303] = 22,
	[304] = 22,
	[305] = 34,
	[306] = 34,
	[307] = 34,
	[308] = 1,
	[309] = 46,
	[310] = 22,
	[311] = 22,
	[312] = 47,
	[313] = 46,
	[314] = 22,
	[315] = 37,
};


const unsigned zebu_lexer_accepts[110] = {
	[48] = 1,
	[49] = 7,
	[51] = 3,
	[52] = 8,
	[53] = 9,
	[55] = 4,
	[58] = 10,
	[60] = 18,
	[61] = 25,
	[62] = 16,
	[63] = 17,
	[64] = 11,
	[65] = 12,
	[66] = 13,
	[68] = 15,
	[69] = 29,
	[70] = 26,
	[71] = 14,
	[72] = 9,
	[73] = 31,
	[76] = 13,
	[77] = 15,
	[79] = 32,
	[82] = 34,
	[83] = 35,
	[84] = 13,
	[85] = 15,
	[86] = 14,
	[87] = 2,
	[92] = 24,
	[93] = 27,
	[94] = 19,
	[95] = 21,
	[96] = 23,
	[97] = 22,
	[98] = 20,
	[99] = 28,
	[101] = 32,
	[105] = 30,
	[106] = 33,
	[107] = 5,
	[109] = 6,
};


const unsigned zebu_lexer_EOFs[18] = {
	[7] = 73,
	[15] = 73,
	[17] = 73,
};


#ifdef ZEBU_DEBUG
#include <stdbool.h>

struct link
{
	bool is_last;
	struct link* prev;
};

static void print_links(struct link* link)
{
	if (!link) return;
	
	print_links(link->prev);
	
	if (link->is_last)
		fputs("    ", stdout);
	else
		fputs("   ", stdout);
}

static void print_tree_escape(char *out, char in)
{
	switch (in)
	{
		case ' ':
		case '~':
		case '!':
		case '@':
		case '#':
		case '$':
		case '%':
		case '^':
		case '&':
		case '*':
		case '-':
		case '+':
		case '=':
		case '|':
		case '<': case '>':
		case '(': case ')':
		case '{': case '}':
		case '[': case ']':
		case ':': case ';':
		case ',': case '.':
		case '_':
		case '/':
		case '`':
		case '0' ... '9':
		case 'a' ... 'z':
		case 'A' ... 'Z':
			*out++ = in;
			*out = 0;
			break;
		
		case '\\': *out++ = '\\', *out++ = '\\', *out = 0; break;
		
		case '\'': *out++ = '\\', *out++ = '\'', *out = 0; break;
		
		case '\"': *out++ = '\\', *out++ = '\"', *out = 0; break;
		
		case '\t': *out++ = '\\', *out++ = 't', *out = 0; break;
		
		case '\n': *out++ = '\\', *out++ = 'n', *out = 0; break;
		
		default:
			sprintf(out, "\\x%02X", in);
			break;
	}
}

enum prefix
{
	p_root,
	p_not_last_child,
	p_last_child,
};

void print_token_leaf(struct link* links, enum prefix p, const char* name, struct zebu_token* token)
{
	print_links(links);
	switch (p)
	{
		case p_root: break;
		case p_not_last_child: fputs(" ", stdout); break;
		case p_last_child: fputs(" ", stdout); break;
	}
	printf("\e[32m%s\e[0m (\e[35m\"", name);
	char escape[10];
	for (unsigned i = 0, n = token->len; i < n; i++)
		print_tree_escape(escape, token->data[i]), fputs(escape, stdout);
	printf("\"\e[0m) on line %u\n", token->line);
}

void print_scanf_leaf(struct link* links, enum prefix p, const char* name, const char* format, ...)
{
	va_list ap;
	print_links(links);
	switch (p)
	{
		case p_root: break;
		case p_not_last_child: fputs(" ", stdout); break;
		case p_last_child: fputs(" ", stdout); break;
	}
	printf("\e[32m%s\e[0m (\e[35m%s\e[m: \e[35m", name, format);
	va_start(ap, format);
	vprintf(format, ap);
	va_end(ap);
	printf("\e[0m)\n");
}

void print_empty_leaf(struct link* links, enum prefix p, const char* type, const char* name)
{
	print_links(links);
	switch (p)
	{
		case p_root: break;
		case p_not_last_child: fputs(" ", stdout); break;
		case p_last_child: fputs(" ", stdout); break;
	}
	printf("\e[31m%s\e[0m (\e[36m%s\e[0m)\n", name, type);
}
void print_zebu_$start(struct link* links, enum prefix p, const char* name, struct zebu_$start* ptree);

void print_zebu_additive_expression(struct link* links, enum prefix p, const char* name, struct zebu_additive_expression* ptree);

void print_zebu_and_expression(struct link* links, enum prefix p, const char* name, struct zebu_and_expression* ptree);

void print_zebu_assertion(struct link* links, enum prefix p, const char* name, struct zebu_assertion* ptree);

void print_zebu_complex_command(struct link* links, enum prefix p, const char* name, struct zebu_complex_command* ptree);

void print_zebu_conditional_expression(struct link* links, enum prefix p, const char* name, struct zebu_conditional_expression* ptree);

void print_zebu_equality_expression(struct link* links, enum prefix p, const char* name, struct zebu_equality_expression* ptree);

void print_zebu_exclusive_or_expression(struct link* links, enum prefix p, const char* name, struct zebu_exclusive_or_expression* ptree);

void print_zebu_expression(struct link* links, enum prefix p, const char* name, struct zebu_expression* ptree);

void print_zebu_file(struct link* links, enum prefix p, const char* name, struct zebu_file* ptree);

void print_zebu_inclusive_or_expression(struct link* links, enum prefix p, const char* name, struct zebu_inclusive_or_expression* ptree);

void print_zebu_logical_and_expression(struct link* links, enum prefix p, const char* name, struct zebu_logical_and_expression* ptree);

void print_zebu_logical_or_expression(struct link* links, enum prefix p, const char* name, struct zebu_logical_or_expression* ptree);

void print_zebu_multiplicative_expression(struct link* links, enum prefix p, const char* name, struct zebu_multiplicative_expression* ptree);

void print_zebu_prefix_expression(struct link* links, enum prefix p, const char* name, struct zebu_prefix_expression* ptree);

void print_zebu_primary_expression(struct link* links, enum prefix p, const char* name, struct zebu_primary_expression* ptree);

void print_zebu_relational_expression(struct link* links, enum prefix p, const char* name, struct zebu_relational_expression* ptree);

void print_zebu_root(struct link* links, enum prefix p, const char* name, struct zebu_root* ptree);

void print_zebu_shift_expression(struct link* links, enum prefix p, const char* name, struct zebu_shift_expression* ptree);

void print_zebu_simple_command(struct link* links, enum prefix p, const char* name, struct zebu_simple_command* ptree);

void print_zebu_test(struct link* links, enum prefix p, const char* name, struct zebu_test* ptree);

void print_zebu_$start(struct link* links, enum prefix p, const char* name, struct zebu_$start* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36m$start\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->root)
		print_zebu_root(new ?: links, p_last_child, "root", ptree->root);
	else
		print_empty_leaf(new ?: links, p_last_child, "root", "root");
	free(new);
}
void print_zebu_additive_expression(struct link* links, enum prefix p, const char* name, struct zebu_additive_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36madditive_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_multiplicative_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "multiplicative_expression", "inner");
	if (ptree->left)
		print_zebu_additive_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "additive_expression", "left");
	if (ptree->right)
		print_zebu_multiplicative_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "multiplicative_expression", "right");
	free(new);
}
void print_zebu_and_expression(struct link* links, enum prefix p, const char* name, struct zebu_and_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mand_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_equality_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "equality_expression", "inner");
	if (ptree->left)
		print_zebu_and_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "and_expression", "left");
	if (ptree->right)
		print_zebu_equality_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "equality_expression", "right");
	free(new);
}
void print_zebu_assertion(struct link* links, enum prefix p, const char* name, struct zebu_assertion* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36massertion\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->conditional)
		print_zebu_expression(new ?: links, p_last_child, "conditional", ptree->conditional);
	else
		print_empty_leaf(new ?: links, p_last_child, "expression", "conditional");
	free(new);
}
void print_zebu_complex_command(struct link* links, enum prefix p, const char* name, struct zebu_complex_command* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mcomplex_command\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->redirect_in)
		print_zebu_primary_expression(new ?: links, p_not_last_child, "redirect_in", ptree->redirect_in);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "primary_expression", "redirect_in");
	if (ptree->redirect_out)
		print_zebu_primary_expression(new ?: links, p_not_last_child, "redirect_out", ptree->redirect_out);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "primary_expression", "redirect_out");
	if (ptree->subcommands.n)
	{
		for (unsigned i = 0, n = ptree->subcommands.n; i < n; i++)
		{
			char label[11 + 30];
			snprintf(label, sizeof(label), "subcommands[%u]", i);
			print_zebu_simple_command(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->subcommands.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "simple_command[]", "subcommands");
	}
	free(new);
}
void print_zebu_conditional_expression(struct link* links, enum prefix p, const char* name, struct zebu_conditional_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mconditional_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->conditional)
		print_zebu_logical_or_expression(new ?: links, p_not_last_child, "conditional", ptree->conditional);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "logical_or_expression", "conditional");
	if (ptree->falsecase)
		print_zebu_conditional_expression(new ?: links, p_not_last_child, "falsecase", ptree->falsecase);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "conditional_expression", "falsecase");
	if (ptree->inner)
		print_zebu_logical_or_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "logical_or_expression", "inner");
	if (ptree->truecase)
		print_zebu_expression(new ?: links, p_last_child, "truecase", ptree->truecase);
	else
		print_empty_leaf(new ?: links, p_last_child, "expression", "truecase");
	free(new);
}
void print_zebu_equality_expression(struct link* links, enum prefix p, const char* name, struct zebu_equality_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mequality_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_relational_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "relational_expression", "inner");
	if (ptree->left)
		print_zebu_equality_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "equality_expression", "left");
	if (ptree->right)
		print_zebu_relational_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "relational_expression", "right");
	free(new);
}
void print_zebu_exclusive_or_expression(struct link* links, enum prefix p, const char* name, struct zebu_exclusive_or_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mexclusive_or_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_and_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "and_expression", "inner");
	if (ptree->left)
		print_zebu_exclusive_or_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "exclusive_or_expression", "left");
	if (ptree->right)
		print_zebu_and_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "and_expression", "right");
	free(new);
}
void print_zebu_expression(struct link* links, enum prefix p, const char* name, struct zebu_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mexpression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_conditional_expression(new ?: links, p_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_last_child, "conditional_expression", "inner");
	free(new);
}
void print_zebu_file(struct link* links, enum prefix p, const char* name, struct zebu_file* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mfile\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->chmods.n)
	{
		for (unsigned i = 0, n = ptree->chmods.n; i < n; i++)
		{
			char label[6 + 30];
			snprintf(label, sizeof(label), "chmods[%u]", i);
			print_token_leaf(new ?: links, i + 1 < n ? p_not_last_child : p_not_last_child, label, ptree->chmods.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_not_last_child, "token[]", "chmods");
	}
	if (ptree->expression)
		print_zebu_expression(new ?: links, p_not_last_child, "expression", ptree->expression);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "expression", "expression");
	if (ptree->octal)
		print_token_leaf(new ?: links, p_not_last_child, "octal", ptree->octal);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "octal");
	if (ptree->path)
		print_token_leaf(new ?: links, p_last_child, "path", ptree->path);
	else
		print_empty_leaf(new ?: links, p_last_child, "token", "path");
	free(new);
}
void print_zebu_inclusive_or_expression(struct link* links, enum prefix p, const char* name, struct zebu_inclusive_or_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36minclusive_or_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_exclusive_or_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "exclusive_or_expression", "inner");
	if (ptree->left)
		print_zebu_inclusive_or_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "inclusive_or_expression", "left");
	if (ptree->right)
		print_zebu_exclusive_or_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "exclusive_or_expression", "right");
	free(new);
}
void print_zebu_logical_and_expression(struct link* links, enum prefix p, const char* name, struct zebu_logical_and_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mlogical_and_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_inclusive_or_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "inclusive_or_expression", "inner");
	if (ptree->left)
		print_zebu_logical_and_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "logical_and_expression", "left");
	if (ptree->right)
		print_zebu_inclusive_or_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "inclusive_or_expression", "right");
	free(new);
}
void print_zebu_logical_or_expression(struct link* links, enum prefix p, const char* name, struct zebu_logical_or_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mlogical_or_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_logical_and_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "logical_and_expression", "inner");
	if (ptree->left)
		print_zebu_logical_or_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "logical_or_expression", "left");
	if (ptree->right)
		print_zebu_logical_and_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "logical_and_expression", "right");
	free(new);
}
void print_zebu_multiplicative_expression(struct link* links, enum prefix p, const char* name, struct zebu_multiplicative_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mmultiplicative_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_prefix_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "prefix_expression", "inner");
	if (ptree->left)
		print_zebu_multiplicative_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "multiplicative_expression", "left");
	if (ptree->right)
		print_zebu_prefix_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "prefix_expression", "right");
	free(new);
}
void print_zebu_prefix_expression(struct link* links, enum prefix p, const char* name, struct zebu_prefix_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mprefix_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->file)
		print_zebu_expression(new ?: links, p_not_last_child, "file", ptree->file);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "expression", "file");
	if (ptree->inner)
		print_zebu_primary_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "primary_expression", "inner");
	if (ptree->shell)
		print_zebu_complex_command(new ?: links, p_not_last_child, "shell", ptree->shell);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "complex_command", "shell");
	if (ptree->sub)
		print_zebu_prefix_expression(new ?: links, p_last_child, "sub", ptree->sub);
	else
		print_empty_leaf(new ?: links, p_last_child, "prefix_expression", "sub");
	free(new);
}
void print_zebu_primary_expression(struct link* links, enum prefix p, const char* name, struct zebu_primary_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mprimary_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->integer)
		print_token_leaf(new ?: links, p_not_last_child, "integer", ptree->integer);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "integer");
	if (ptree->string)
		print_token_leaf(new ?: links, p_not_last_child, "string", ptree->string);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "string");
	if (ptree->sub)
		print_zebu_expression(new ?: links, p_last_child, "sub", ptree->sub);
	else
		print_empty_leaf(new ?: links, p_last_child, "expression", "sub");
	free(new);
}
void print_zebu_relational_expression(struct link* links, enum prefix p, const char* name, struct zebu_relational_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mrelational_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_shift_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "shift_expression", "inner");
	if (ptree->left)
		print_zebu_relational_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "relational_expression", "left");
	if (ptree->right)
		print_zebu_shift_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "shift_expression", "right");
	free(new);
}
void print_zebu_root(struct link* links, enum prefix p, const char* name, struct zebu_root* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mroot\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->tests.n)
	{
		for (unsigned i = 0, n = ptree->tests.n; i < n; i++)
		{
			char label[5 + 30];
			snprintf(label, sizeof(label), "tests[%u]", i);
			print_zebu_test(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->tests.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "test[]", "tests");
	}
	free(new);
}
void print_zebu_shift_expression(struct link* links, enum prefix p, const char* name, struct zebu_shift_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mshift_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_additive_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "additive_expression", "inner");
	if (ptree->left)
		print_zebu_shift_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "shift_expression", "left");
	if (ptree->right)
		print_zebu_additive_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "additive_expression", "right");
	free(new);
}
void print_zebu_simple_command(struct link* links, enum prefix p, const char* name, struct zebu_simple_command* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36msimple_command\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->args.n)
	{
		for (unsigned i = 0, n = ptree->args.n; i < n; i++)
		{
			char label[4 + 30];
			snprintf(label, sizeof(label), "args[%u]", i);
			print_zebu_primary_expression(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->args.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "primary_expression[]", "args");
	}
	free(new);
}
void print_zebu_test(struct link* links, enum prefix p, const char* name, struct zebu_test* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mtest\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->assertions.n)
	{
		for (unsigned i = 0, n = ptree->assertions.n; i < n; i++)
		{
			char label[10 + 30];
			snprintf(label, sizeof(label), "assertions[%u]", i);
			print_zebu_assertion(new ?: links, i + 1 < n ? p_not_last_child : p_not_last_child, label, ptree->assertions.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_not_last_child, "assertion[]", "assertions");
	}
	if (ptree->files.n)
	{
		for (unsigned i = 0, n = ptree->files.n; i < n; i++)
		{
			char label[5 + 30];
			snprintf(label, sizeof(label), "files[%u]", i);
			print_zebu_file(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->files.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "file[]", "files");
	}
	free(new);
}

#endif

struct zebu_token* inc_zebu_token(struct zebu_token* token)
{
	if (token) token->refcount++;
	return token;
}
struct zebu_$start* inc_zebu_$start(struct zebu_$start* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_additive_expression* inc_zebu_additive_expression(struct zebu_additive_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_and_expression* inc_zebu_and_expression(struct zebu_and_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_assertion* inc_zebu_assertion(struct zebu_assertion* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_complex_command* inc_zebu_complex_command(struct zebu_complex_command* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_conditional_expression* inc_zebu_conditional_expression(struct zebu_conditional_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_equality_expression* inc_zebu_equality_expression(struct zebu_equality_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_exclusive_or_expression* inc_zebu_exclusive_or_expression(struct zebu_exclusive_or_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_expression* inc_zebu_expression(struct zebu_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_file* inc_zebu_file(struct zebu_file* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_inclusive_or_expression* inc_zebu_inclusive_or_expression(struct zebu_inclusive_or_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_logical_and_expression* inc_zebu_logical_and_expression(struct zebu_logical_and_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_logical_or_expression* inc_zebu_logical_or_expression(struct zebu_logical_or_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_multiplicative_expression* inc_zebu_multiplicative_expression(struct zebu_multiplicative_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_prefix_expression* inc_zebu_prefix_expression(struct zebu_prefix_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_primary_expression* inc_zebu_primary_expression(struct zebu_primary_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_relational_expression* inc_zebu_relational_expression(struct zebu_relational_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_root* inc_zebu_root(struct zebu_root* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_shift_expression* inc_zebu_shift_expression(struct zebu_shift_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_simple_command* inc_zebu_simple_command(struct zebu_simple_command* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_test* inc_zebu_test(struct zebu_test* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}



extern void free_zebu_token(struct zebu_token* token);
extern void free_zebu_$start(struct zebu_$start* ptree);

extern void free_zebu_additive_expression(struct zebu_additive_expression* ptree);

extern void free_zebu_and_expression(struct zebu_and_expression* ptree);

extern void free_zebu_assertion(struct zebu_assertion* ptree);

extern void free_zebu_complex_command(struct zebu_complex_command* ptree);

extern void free_zebu_conditional_expression(struct zebu_conditional_expression* ptree);

extern void free_zebu_equality_expression(struct zebu_equality_expression* ptree);

extern void free_zebu_exclusive_or_expression(struct zebu_exclusive_or_expression* ptree);

extern void free_zebu_expression(struct zebu_expression* ptree);

extern void free_zebu_file(struct zebu_file* ptree);

extern void free_zebu_inclusive_or_expression(struct zebu_inclusive_or_expression* ptree);

extern void free_zebu_logical_and_expression(struct zebu_logical_and_expression* ptree);

extern void free_zebu_logical_or_expression(struct zebu_logical_or_expression* ptree);

extern void free_zebu_multiplicative_expression(struct zebu_multiplicative_expression* ptree);

extern void free_zebu_prefix_expression(struct zebu_prefix_expression* ptree);

extern void free_zebu_primary_expression(struct zebu_primary_expression* ptree);

extern void free_zebu_relational_expression(struct zebu_relational_expression* ptree);

extern void free_zebu_root(struct zebu_root* ptree);

extern void free_zebu_shift_expression(struct zebu_shift_expression* ptree);

extern void free_zebu_simple_command(struct zebu_simple_command* ptree);

extern void free_zebu_test(struct zebu_test* ptree);

void free_zebu_token(struct zebu_token* token)
{
	if (token && !--token->refcount)
	{
		free(token->data);
		free(token);
	}
}
void free_zebu_$start(struct zebu_$start* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_root(ptree->root);
		free(ptree);
	}
}

void free_zebu_additive_expression(struct zebu_additive_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_multiplicative_expression(ptree->inner);
		free_zebu_additive_expression(ptree->left);
		free_zebu_multiplicative_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_and_expression(struct zebu_and_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_equality_expression(ptree->inner);
		free_zebu_and_expression(ptree->left);
		free_zebu_equality_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_assertion(struct zebu_assertion* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_expression(ptree->conditional);
		free(ptree);
	}
}

void free_zebu_complex_command(struct zebu_complex_command* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_primary_expression(ptree->redirect_in);
		free_zebu_primary_expression(ptree->redirect_out);
		for (unsigned i = 0, n = ptree->subcommands.n; i < n; i++)
			free_zebu_simple_command(ptree->subcommands.data[i]);
		free(ptree->subcommands.data);
		free(ptree);
	}
}

void free_zebu_conditional_expression(struct zebu_conditional_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_logical_or_expression(ptree->conditional);
		free_zebu_conditional_expression(ptree->falsecase);
		free_zebu_logical_or_expression(ptree->inner);
		free_zebu_expression(ptree->truecase);
		free(ptree);
	}
}

void free_zebu_equality_expression(struct zebu_equality_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_relational_expression(ptree->inner);
		free_zebu_equality_expression(ptree->left);
		free_zebu_relational_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_exclusive_or_expression(struct zebu_exclusive_or_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_and_expression(ptree->inner);
		free_zebu_exclusive_or_expression(ptree->left);
		free_zebu_and_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_expression(struct zebu_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_conditional_expression(ptree->inner);
		free(ptree);
	}
}

void free_zebu_file(struct zebu_file* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		for (unsigned i = 0, n = ptree->chmods.n; i < n; i++)
			free_zebu_token(ptree->chmods.data[i]);
		free(ptree->chmods.data);
		free_zebu_expression(ptree->expression);
		free_zebu_token(ptree->octal);
		free_zebu_token(ptree->path);
		free(ptree);
	}
}

void free_zebu_inclusive_or_expression(struct zebu_inclusive_or_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_exclusive_or_expression(ptree->inner);
		free_zebu_inclusive_or_expression(ptree->left);
		free_zebu_exclusive_or_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_logical_and_expression(struct zebu_logical_and_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_inclusive_or_expression(ptree->inner);
		free_zebu_logical_and_expression(ptree->left);
		free_zebu_inclusive_or_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_logical_or_expression(struct zebu_logical_or_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_logical_and_expression(ptree->inner);
		free_zebu_logical_or_expression(ptree->left);
		free_zebu_logical_and_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_multiplicative_expression(struct zebu_multiplicative_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_prefix_expression(ptree->inner);
		free_zebu_multiplicative_expression(ptree->left);
		free_zebu_prefix_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_prefix_expression(struct zebu_prefix_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_expression(ptree->file);
		free_zebu_primary_expression(ptree->inner);
		free_zebu_complex_command(ptree->shell);
		free_zebu_prefix_expression(ptree->sub);
		free(ptree);
	}
}

void free_zebu_primary_expression(struct zebu_primary_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->integer);
		free_zebu_token(ptree->string);
		free_zebu_expression(ptree->sub);
		free(ptree);
	}
}

void free_zebu_relational_expression(struct zebu_relational_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_shift_expression(ptree->inner);
		free_zebu_relational_expression(ptree->left);
		free_zebu_shift_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_root(struct zebu_root* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		for (unsigned i = 0, n = ptree->tests.n; i < n; i++)
			free_zebu_test(ptree->tests.data[i]);
		free(ptree->tests.data);
		free(ptree);
	}
}

void free_zebu_shift_expression(struct zebu_shift_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_additive_expression(ptree->inner);
		free_zebu_shift_expression(ptree->left);
		free_zebu_additive_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_simple_command(struct zebu_simple_command* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		for (unsigned i = 0, n = ptree->args.n; i < n; i++)
			free_zebu_primary_expression(ptree->args.data[i]);
		free(ptree->args.data);
		free(ptree);
	}
}

void free_zebu_test(struct zebu_test* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		for (unsigned i = 0, n = ptree->assertions.n; i < n; i++)
			free_zebu_assertion(ptree->assertions.data[i]);
		free(ptree->assertions.data);
		for (unsigned i = 0, n = ptree->files.n; i < n; i++)
			free_zebu_file(ptree->files.data[i]);
		free(ptree->files.data);
		free(ptree);
	}
}



#define argv0 (program_invocation_name)

#define N(array) (sizeof(array) / sizeof(*array))

#ifdef ZEBU_DEBUG
static void escape(char *out, unsigned char in)
{
	switch (in)
	{
		case ' ':
		case '~':
		case '!':
		case '@':
		case '#':
		case '$':
		case '%':
		case '^':
		case '&':
		case '*':
		case '-':
		case '+':
		case '=':
		case '|':
		case '/':
		case '<': case '>':
		case '(': case ')':
		case '{': case '}':
		case '[': case ']':
		case ':': case ';':
		case ',': case '.':
		case '_':
		case '0' ... '9':
		case 'a' ... 'z':
		case 'A' ... 'Z':
			*out++ = in;
			*out = 0;
			break;
		
		case '\\': *out++ = '\\', *out++ = '\\', *out = 0; break;
		
		case '\'': *out++ = '\\', *out++ = '\'', *out = 0; break;
		
		case '\"': *out++ = '\\', *out++ = '\"', *out = 0; break;
		
		case '\t': *out++ = '\\', *out++ = 't', *out = 0; break;
		
		case '\n': *out++ = '\\', *out++ = 'n', *out = 0; break;
		
		default:
			sprintf(out, "\\x%02hhX", in);
			break;
	}
}
#endif

struct zebu_$start* zebu_parse(FILE* stream)
{
	void* root;
	struct { unsigned* data, n, cap; } yacc = {};
	struct { void** data; unsigned n, cap; } data = {};
	struct { unsigned char* data; unsigned n, cap, line; } lexer = {
		.line = 1,
	};
	
	void push_state(unsigned y)
	{
		if (yacc.n + 1 >= yacc.cap)
		{
			yacc.cap = yacc.cap << 1 ?: 1;
			yacc.data = realloc(yacc.data, sizeof(*yacc.data) * yacc.cap);
		}
		yacc.data[yacc.n++] = y;
	}
	
	void push_data(void* d)
	{
		if (data.n + 1 >= data.cap)
		{
			data.cap = data.cap << 1 ?: 1;
			data.data = realloc(data.data, sizeof(*data.data) * data.cap);
		}
		data.data[data.n++] = d;
	}
	
	#ifdef ZEBU_DEBUG
	void ddprintf(const char* fmt, ...)
	{
		for (unsigned i = 0, n = yacc.n; i < n; i++)
			printf("%u ", yacc.data[i]);
		
		printf("| ");
		
		va_list va;
		va_start(va, fmt);
		vprintf(fmt, va);
		va_end(va);
	}
	#endif
	
	void push_char(unsigned char c)
	{
		while (lexer.n + 1 >= lexer.cap)
		{
			lexer.cap = lexer.cap << 1 ?: 1;
			#ifdef ZEBU_DEBUG
			ddprintf("lexer.cap == %u\n", lexer.cap);
			#endif
			lexer.data = realloc(lexer.data, lexer.cap);
		}
		
		lexer.data[lexer.n++] = c;
	}
	
	unsigned y, t, s, r;
	void* td;
	
	void read_token(unsigned l)
	{
		unsigned original_l = l, i = 0, a, b, c, f = 0;
		
		unsigned line = lexer.line;
		
		t = 0;
		
		#ifdef ZEBU_DEBUG
		ddprintf("lexer: \"%.*s\": l = %u\n", lexer.n, lexer.data, l);
		#endif
		
		while (1)
		{
			if (i < lexer.n)
			{
				c = lexer.data[i];
				
				#ifdef ZEBU_DEBUG
				char escaped[10];
				
				escape(escaped, c);
				
				ddprintf("lexer: c = '%s' (0x%X) (from cache)\n", escaped, c);
				#endif
				
				a = l < N(zebu_lexer) && c < N(*zebu_lexer) ? zebu_lexer[l][c] : 0;
			}
			else if ((c = getc(stream)) != EOF)
			{
				push_char(c);
				
				#ifdef ZEBU_DEBUG
				char escaped[10];
				
				escape(escaped, c);
				
				ddprintf("lexer: c = '%s' (0x%X)\n", escaped, c);
				#endif
				
				a = l < N(zebu_lexer) && c < N(*zebu_lexer) ? zebu_lexer[l][c] : 0;
			}
			else
			{
				c = EOF;
				
				#ifdef ZEBU_DEBUG
				ddprintf("lexer: c = <EOF>\n");
				#endif
				
				a = l < N(zebu_lexer_EOFs) ? zebu_lexer_EOFs[l] : 0;
			}
			
			b = l < N(zebu_lexer_accepts) ? zebu_lexer_accepts[l] : 0;
			
			#ifdef ZEBU_DEBUG
			ddprintf("lexer: \"%.*s\" (%u): a = %u, b = %u\n", lexer.n, lexer.data, i, a, b);
			#endif
			
			if (a)
			{
				if (b)
				{
					l = a, t = b, f = i++, lexer.line = line;
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: l = %u\n", l);
					#endif
				}
				else
				{
					l = a, i++;
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: l = %u\n", l);
					#endif
				}
				
				if (c == '\n')
				{
					line++;
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: line: %u\n", line);
					#endif
				}
			}
			else if (b)
			{
				#ifdef ZEBU_DEBUG
				ddprintf("lexer: token: \"%.*s\", line: %u\n", i, lexer.data, line);
				#endif
				
				if (!lexer.n)
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: EOF.\n");
					#endif
					t = b, td = NULL;
					break;
				}
				else if (b == 1)
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: whitespace: \"%.*s\"\n", i, lexer.data);
					#endif
					
					l = original_l, t = 0, lexer.line = line;
					memmove(lexer.data, lexer.data + i, lexer.n - i), lexer.n -= i, i = 0;
				}
				else
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: i = %u\n", i);
					#endif
					
					struct zebu_token* token = malloc(sizeof(*token));
					token->refcount = 1;
					token->line = line;
					token->data = memcpy(malloc(i + 1), lexer.data, i);
					token->data[i] = 0;
					token->len = i;
					t = b, td = token;
					
					lexer.line = line;
					memmove(lexer.data, lexer.data + i, lexer.n - i), lexer.n -= i;
					break;
				}
			}
			else if (t)
			{
				if (t == 1)
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: falling back to whitespace: \"%.*s\"\n", f, lexer.data);
					#endif
					
					l = original_l, t = 0, line = lexer.line;
					memmove(lexer.data, lexer.data + f, lexer.n - f), lexer.n -= f, f = 0, i = 0;
				}
				else
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: falling back to token: \"%.*s\"\n", f, lexer.data);
					#endif
					
					struct zebu_token* token = malloc(sizeof(*token));
					token->refcount = 1;
					token->line = lexer.line;
					token->data = memcpy(malloc(f + 1), lexer.data, f);
					token->data[f] = 0;
					token->len = f;
					td = token;
					
					memmove(lexer.data, lexer.data + f, lexer.n - f), lexer.n -= f, f = 0;
					break;
				}
			}
			else
			{
				if (i != 0)
				{
					if (c == (unsigned) EOF)
						fprintf(stderr, "%s: unexpected '<EOF>' when reading '%.*s' on line %u!\n", argv0, i, lexer.data, line);
					else
						fprintf(stderr, "%s: unexpected '%c' when reading '%.*s' on line %u!\n", argv0, c, i, lexer.data, line);
				}
				else
				{
					if (c == (unsigned) EOF)
						fprintf(stderr, "%s: unexpected '<EOF>' on line %u!\n", argv0, line);
					else
						fprintf(stderr, "%s: unexpected '%c' on line %u!\n", argv0, c, line);
				}
				exit(1);
			}
		}
	}
	
	push_state(1), y = 1, read_token(1);
	
	#ifdef ZEBU_DEBUG
	ddprintf("y = %u, t = %u\n", y, t);
	#endif
	
	while (yacc.n)
	{
		if (y < N(zebu_shifts) && t < N(*zebu_shifts) && (s = zebu_shifts[y][t]))
		{
			#ifdef ZEBU_DEBUG
			ddprintf("s == %u\n", s);
			#endif
			
			y = s, push_state(y), push_data(td);
			
			read_token(zebu_lexer_starts[y]);
			
			#ifdef ZEBU_DEBUG
			ddprintf("t = %u\n", t);
			#endif
		}
		else if (y < N( zebu_reduces) && t < N(*zebu_reduces) && (r = zebu_reduces[y][t]))
		{
			#ifdef ZEBU_DEBUG
			ddprintf("r == %u\n", r);
			#endif
			
			unsigned g;
			void* d;
			
			switch (r)
{
	case 17:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_root* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_root(value->root), value->root = inc_zebu_root(subgrammar);
free_zebu_root(subgrammar);
}
		d = value, g = 35;
		break;
	}
	case 33:
	{
		struct zebu_additive_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_multiplicative_expression(value->right), value->right = inc_zebu_multiplicative_expression(subgrammar);
free_zebu_multiplicative_expression(subgrammar);
}
		d = value, g = 23;
		break;
	}
	case 77:
	{
		struct zebu_complex_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_complex_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->redirect_in) { free_zebu_primary_expression(value->redirect_in); value->redirect_in = inc_zebu_primary_expression(trie->redirect_in); }
if (trie->redirect_out) { free_zebu_primary_expression(value->redirect_out); value->redirect_out = inc_zebu_primary_expression(trie->redirect_out); }
if (trie->subcommands.n)
{
while (value->subcommands.n + trie->subcommands.n > value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + trie->subcommands.n, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
for (unsigned i = 0, n = trie->subcommands.n; i < n; i++)
value->subcommands.data[i] = inc_zebu_simple_command(trie->subcommands.data[i]);
value->subcommands.n += trie->subcommands.n;
}
free_zebu_complex_command(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 34;
		break;
	}
	case 76:
	{
		struct zebu_complex_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_complex_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->redirect_in) { free_zebu_primary_expression(value->redirect_in); value->redirect_in = inc_zebu_primary_expression(trie->redirect_in); }
if (trie->redirect_out) { free_zebu_primary_expression(value->redirect_out); value->redirect_out = inc_zebu_primary_expression(trie->redirect_out); }
if (trie->subcommands.n)
{
while (value->subcommands.n + trie->subcommands.n > value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + trie->subcommands.n, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
for (unsigned i = 0, n = trie->subcommands.n; i < n; i++)
value->subcommands.data[i] = inc_zebu_simple_command(trie->subcommands.data[i]);
value->subcommands.n += trie->subcommands.n;
}
free_zebu_complex_command(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 34;
		break;
	}
	case 58:
	{
		struct zebu_prefix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 29;
		break;
	}
	case 48:
	{
		struct zebu_relational_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_shift_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_shift_expression(value->right), value->right = inc_zebu_shift_expression(subgrammar);
free_zebu_shift_expression(subgrammar);
}
		d = value, g = 26;
		break;
	}
	case 53:
	{
		struct zebu_shift_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_additive_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_additive_expression(value->right), value->right = inc_zebu_additive_expression(subgrammar);
free_zebu_additive_expression(subgrammar);
}
		d = value, g = 27;
		break;
	}
	case 62:
	{
		struct zebu_simple_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_primary_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->args.n == value->args.cap)
{
value->args.cap = value->args.cap << 1 ?: 1;
value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
}
memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
value->args.data[0] = inc_zebu_primary_expression(subgrammar), value->args.n++;
free_zebu_primary_expression(subgrammar);
}
		d = value, g = 30;
		break;
	}
	case 65:
	{
		struct zebu_simple_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_simple_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->args.n)
{
while (value->args.n + trie->args.n > value->args.cap)
{
value->args.cap = value->args.cap << 1 ?: 1;
value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
}
memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
for (unsigned i = 0, n = trie->args.n; i < n; i++)
value->args.data[i] = inc_zebu_primary_expression(trie->args.data[i]);
value->args.n += trie->args.n;
}
free_zebu_simple_command(trie);
}
{
struct zebu_primary_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->args.n == value->args.cap)
{
value->args.cap = value->args.cap << 1 ?: 1;
value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
}
memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
value->args.data[0] = inc_zebu_primary_expression(subgrammar), value->args.n++;
free_zebu_primary_expression(subgrammar);
}
		d = value, g = 30;
		break;
	}
	case 68:
	{
		struct zebu_complex_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_simple_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->subcommands.n == value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + 1, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
value->subcommands.data[0] = inc_zebu_simple_command(subgrammar), value->subcommands.n++;
free_zebu_simple_command(subgrammar);
}
		d = value, g = 32;
		break;
	}
	case 75:
	{
		struct zebu_complex_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_complex_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->redirect_in) { free_zebu_primary_expression(value->redirect_in); value->redirect_in = inc_zebu_primary_expression(trie->redirect_in); }
if (trie->redirect_out) { free_zebu_primary_expression(value->redirect_out); value->redirect_out = inc_zebu_primary_expression(trie->redirect_out); }
if (trie->subcommands.n)
{
while (value->subcommands.n + trie->subcommands.n > value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + trie->subcommands.n, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
for (unsigned i = 0, n = trie->subcommands.n; i < n; i++)
value->subcommands.data[i] = inc_zebu_simple_command(trie->subcommands.data[i]);
value->subcommands.n += trie->subcommands.n;
}
free_zebu_complex_command(trie);
}
{
struct zebu_simple_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->subcommands.n == value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + 1, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
value->subcommands.data[0] = inc_zebu_simple_command(subgrammar), value->subcommands.n++;
free_zebu_simple_command(subgrammar);
}
		d = value, g = 32;
		break;
	}
	case 70:
	{
		struct zebu_complex_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_primary_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_primary_expression(value->redirect_out), value->redirect_out = inc_zebu_primary_expression(subgrammar);
free_zebu_primary_expression(subgrammar);
}
		d = value, g = 33;
		break;
	}
	case 37:
	{
		struct zebu_equality_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_relational_expression(value->right), value->right = inc_zebu_relational_expression(subgrammar);
free_zebu_relational_expression(subgrammar);
}
		d = value, g = 24;
		break;
	}
	case 73:
	{
		struct zebu_file* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_file* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->chmods.n){
while (value->chmods.n + trie->chmods.n > value->chmods.cap)
{
value->chmods.cap = value->chmods.cap << 1 ?: 1;
value->chmods.data = realloc(value->chmods.data, sizeof(*value->chmods.data) * value->chmods.cap);
}
memmove(value->chmods.data + trie->chmods.n, value->chmods.data, sizeof(*value->chmods.data) * value->chmods.n);
for (unsigned i = 0, n = trie->chmods.n; i < n; i++)
value->chmods.data[i] = inc_zebu_token(trie->chmods.data[i]);
value->chmods.n += trie->chmods.n;
}
if (trie->expression) { free_zebu_expression(value->expression); value->expression = inc_zebu_expression(trie->expression); }
if (trie->octal) { free_zebu_token(value->octal); value->octal = inc_zebu_token(trie->octal); }
if (trie->path) { free_zebu_token(value->path); value->path = inc_zebu_token(trie->path); }
free_zebu_file(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 31;
		break;
	}
	case 72:
	{
		struct zebu_file* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_file* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->chmods.n){
while (value->chmods.n + trie->chmods.n > value->chmods.cap)
{
value->chmods.cap = value->chmods.cap << 1 ?: 1;
value->chmods.data = realloc(value->chmods.data, sizeof(*value->chmods.data) * value->chmods.cap);
}
memmove(value->chmods.data + trie->chmods.n, value->chmods.data, sizeof(*value->chmods.data) * value->chmods.n);
for (unsigned i = 0, n = trie->chmods.n; i < n; i++)
value->chmods.data[i] = inc_zebu_token(trie->chmods.data[i]);
value->chmods.n += trie->chmods.n;
}
if (trie->expression) { free_zebu_expression(value->expression); value->expression = inc_zebu_expression(trie->expression); }
if (trie->octal) { free_zebu_token(value->octal); value->octal = inc_zebu_token(trie->octal); }
if (trie->path) { free_zebu_token(value->path); value->path = inc_zebu_token(trie->path); }
free_zebu_file(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
if (value->chmods.n == value->chmods.cap)
{
value->chmods.cap = value->chmods.cap << 1 ?: 1;
value->chmods.data = realloc(value->chmods.data, sizeof(*value->chmods.data) * value->chmods.cap);
}
memmove(value->chmods.data + 1, value->chmods.data, sizeof(*value->chmods.data) * value->chmods.n);
value->chmods.data[0] = inc_zebu_token(token), value->chmods.n++;
free_zebu_token(token);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 28;
		break;
	}
	case 63:
	{
		struct zebu_file* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_file* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->chmods.n){
while (value->chmods.n + trie->chmods.n > value->chmods.cap)
{
value->chmods.cap = value->chmods.cap << 1 ?: 1;
value->chmods.data = realloc(value->chmods.data, sizeof(*value->chmods.data) * value->chmods.cap);
}
memmove(value->chmods.data + trie->chmods.n, value->chmods.data, sizeof(*value->chmods.data) * value->chmods.n);
for (unsigned i = 0, n = trie->chmods.n; i < n; i++)
value->chmods.data[i] = inc_zebu_token(trie->chmods.data[i]);
value->chmods.n += trie->chmods.n;
}
if (trie->expression) { free_zebu_expression(value->expression); value->expression = inc_zebu_expression(trie->expression); }
if (trie->octal) { free_zebu_token(value->octal); value->octal = inc_zebu_token(trie->octal); }
if (trie->path) { free_zebu_token(value->path); value->path = inc_zebu_token(trie->path); }
free_zebu_file(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 28;
		break;
	}
	case 57:
	{
		struct zebu_file* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression(value->expression), value->expression = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
		d = value, g = 20;
		break;
	}
	case 44:
	{
		struct zebu_multiplicative_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_prefix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_prefix_expression(value->right), value->right = inc_zebu_prefix_expression(subgrammar);
free_zebu_prefix_expression(subgrammar);
}
		d = value, g = 25;
		break;
	}
	case 21:
	{
		struct zebu_prefix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_prefix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_prefix_expression(value->sub), value->sub = inc_zebu_prefix_expression(subgrammar);
free_zebu_prefix_expression(subgrammar);
}
		d = value, g = 19;
		break;
	}
	case 34:
	{
		struct zebu_additive_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_additive_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_multiplicative_expression(value->inner); value->inner = inc_zebu_multiplicative_expression(trie->inner); }
if (trie->left) { free_zebu_additive_expression(value->left); value->left = inc_zebu_additive_expression(trie->left); }
if (trie->right) { free_zebu_multiplicative_expression(value->right); value->right = inc_zebu_multiplicative_expression(trie->right); }
free_zebu_additive_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_additive_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_additive_expression(value->left), value->left = inc_zebu_additive_expression(subgrammar);
free_zebu_additive_expression(subgrammar);
}
		d = value, g = 1;
		break;
	}
	case 13:
	{
		struct zebu_additive_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_multiplicative_expression(value->inner), value->inner = inc_zebu_multiplicative_expression(subgrammar);
free_zebu_multiplicative_expression(subgrammar);
}
		d = value, g = 1;
		break;
	}
	case 32:
	{
		struct zebu_additive_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_additive_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_multiplicative_expression(value->inner); value->inner = inc_zebu_multiplicative_expression(trie->inner); }
if (trie->left) { free_zebu_additive_expression(value->left); value->left = inc_zebu_additive_expression(trie->left); }
if (trie->right) { free_zebu_multiplicative_expression(value->right); value->right = inc_zebu_multiplicative_expression(trie->right); }
free_zebu_additive_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_additive_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_additive_expression(value->left), value->left = inc_zebu_additive_expression(subgrammar);
free_zebu_additive_expression(subgrammar);
}
		d = value, g = 1;
		break;
	}
	case 7:
	{
		struct zebu_and_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_equality_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_equality_expression(value->inner), value->inner = inc_zebu_equality_expression(subgrammar);
free_zebu_equality_expression(subgrammar);
}
		d = value, g = 2;
		break;
	}
	case 35:
	{
		struct zebu_and_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_equality_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_equality_expression(value->right), value->right = inc_zebu_equality_expression(subgrammar);
free_zebu_equality_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_and_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_and_expression(value->left), value->left = inc_zebu_and_expression(subgrammar);
free_zebu_and_expression(subgrammar);
}
		d = value, g = 2;
		break;
	}
	case 26:
	{
		struct zebu_assertion* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression(value->conditional), value->conditional = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
		d = value, g = 3;
		break;
	}
	case 69:
	{
		struct zebu_complex_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_complex_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->redirect_in) { free_zebu_primary_expression(value->redirect_in); value->redirect_in = inc_zebu_primary_expression(trie->redirect_in); }
if (trie->redirect_out) { free_zebu_primary_expression(value->redirect_out); value->redirect_out = inc_zebu_primary_expression(trie->redirect_out); }
if (trie->subcommands.n)
{
while (value->subcommands.n + trie->subcommands.n > value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + trie->subcommands.n, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
for (unsigned i = 0, n = trie->subcommands.n; i < n; i++)
value->subcommands.data[i] = inc_zebu_simple_command(trie->subcommands.data[i]);
value->subcommands.n += trie->subcommands.n;
}
free_zebu_complex_command(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_simple_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->subcommands.n == value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + 1, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
value->subcommands.data[0] = inc_zebu_simple_command(subgrammar), value->subcommands.n++;
free_zebu_simple_command(subgrammar);
}
		d = value, g = 21;
		break;
	}
	case 66:
	{
		struct zebu_complex_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_primary_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_primary_expression(value->redirect_in), value->redirect_in = inc_zebu_primary_expression(subgrammar);
free_zebu_primary_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_simple_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->subcommands.n == value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + 1, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
value->subcommands.data[0] = inc_zebu_simple_command(subgrammar), value->subcommands.n++;
free_zebu_simple_command(subgrammar);
}
		d = value, g = 21;
		break;
	}
	case 67:
	{
		struct zebu_complex_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_complex_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->redirect_in) { free_zebu_primary_expression(value->redirect_in); value->redirect_in = inc_zebu_primary_expression(trie->redirect_in); }
if (trie->redirect_out) { free_zebu_primary_expression(value->redirect_out); value->redirect_out = inc_zebu_primary_expression(trie->redirect_out); }
if (trie->subcommands.n)
{
while (value->subcommands.n + trie->subcommands.n > value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + trie->subcommands.n, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
for (unsigned i = 0, n = trie->subcommands.n; i < n; i++)
value->subcommands.data[i] = inc_zebu_simple_command(trie->subcommands.data[i]);
value->subcommands.n += trie->subcommands.n;
}
free_zebu_complex_command(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_simple_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->subcommands.n == value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + 1, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
value->subcommands.data[0] = inc_zebu_simple_command(subgrammar), value->subcommands.n++;
free_zebu_simple_command(subgrammar);
}
		d = value, g = 21;
		break;
	}
	case 31:
	{
		struct zebu_complex_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_simple_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->subcommands.n == value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + 1, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
value->subcommands.data[0] = inc_zebu_simple_command(subgrammar), value->subcommands.n++;
free_zebu_simple_command(subgrammar);
}
		d = value, g = 21;
		break;
	}
	case 74:
	{
		struct zebu_complex_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_complex_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->redirect_in) { free_zebu_primary_expression(value->redirect_in); value->redirect_in = inc_zebu_primary_expression(trie->redirect_in); }
if (trie->redirect_out) { free_zebu_primary_expression(value->redirect_out); value->redirect_out = inc_zebu_primary_expression(trie->redirect_out); }
if (trie->subcommands.n)
{
while (value->subcommands.n + trie->subcommands.n > value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + trie->subcommands.n, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
for (unsigned i = 0, n = trie->subcommands.n; i < n; i++)
value->subcommands.data[i] = inc_zebu_simple_command(trie->subcommands.data[i]);
value->subcommands.n += trie->subcommands.n;
}
free_zebu_complex_command(trie);
}
{
struct zebu_primary_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_primary_expression(value->redirect_in), value->redirect_in = inc_zebu_primary_expression(subgrammar);
free_zebu_primary_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_simple_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->subcommands.n == value->subcommands.cap)
{
value->subcommands.cap = value->subcommands.cap << 1 ?: 1;
value->subcommands.data = realloc(value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.cap);
}
memmove(value->subcommands.data + 1, value->subcommands.data, sizeof(*value->subcommands.data) * value->subcommands.n);
value->subcommands.data[0] = inc_zebu_simple_command(subgrammar), value->subcommands.n++;
free_zebu_simple_command(subgrammar);
}
		d = value, g = 21;
		break;
	}
	case 71:
	{
		struct zebu_conditional_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_conditional_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_conditional_expression(value->falsecase), value->falsecase = inc_zebu_conditional_expression(subgrammar);
free_zebu_conditional_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression(value->truecase), value->truecase = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_logical_or_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_logical_or_expression(value->conditional), value->conditional = inc_zebu_logical_or_expression(subgrammar);
free_zebu_logical_or_expression(value->inner), value->inner = inc_zebu_logical_or_expression(subgrammar);
free_zebu_logical_or_expression(subgrammar);
}
		d = value, g = 4;
		break;
	}
	case 12:
	{
		struct zebu_conditional_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_logical_or_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_logical_or_expression(value->conditional), value->conditional = inc_zebu_logical_or_expression(subgrammar);
free_zebu_logical_or_expression(value->inner), value->inner = inc_zebu_logical_or_expression(subgrammar);
free_zebu_logical_or_expression(subgrammar);
}
		d = value, g = 4;
		break;
	}
	case 38:
	{
		struct zebu_equality_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_equality_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_relational_expression(value->inner); value->inner = inc_zebu_relational_expression(trie->inner); }
if (trie->left) { free_zebu_equality_expression(value->left); value->left = inc_zebu_equality_expression(trie->left); }
if (trie->right) { free_zebu_relational_expression(value->right); value->right = inc_zebu_relational_expression(trie->right); }
free_zebu_equality_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_equality_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_equality_expression(value->left), value->left = inc_zebu_equality_expression(subgrammar);
free_zebu_equality_expression(subgrammar);
}
		d = value, g = 5;
		break;
	}
	case 16:
	{
		struct zebu_equality_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_relational_expression(value->inner), value->inner = inc_zebu_relational_expression(subgrammar);
free_zebu_relational_expression(subgrammar);
}
		d = value, g = 5;
		break;
	}
	case 36:
	{
		struct zebu_equality_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_equality_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_relational_expression(value->inner); value->inner = inc_zebu_relational_expression(trie->inner); }
if (trie->left) { free_zebu_equality_expression(value->left); value->left = inc_zebu_equality_expression(trie->left); }
if (trie->right) { free_zebu_relational_expression(value->right); value->right = inc_zebu_relational_expression(trie->right); }
free_zebu_equality_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_equality_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_equality_expression(value->left), value->left = inc_zebu_equality_expression(subgrammar);
free_zebu_equality_expression(subgrammar);
}
		d = value, g = 5;
		break;
	}
	case 4:
	{
		struct zebu_exclusive_or_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_and_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_and_expression(value->inner), value->inner = inc_zebu_and_expression(subgrammar);
free_zebu_and_expression(subgrammar);
}
		d = value, g = 6;
		break;
	}
	case 39:
	{
		struct zebu_exclusive_or_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_and_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_and_expression(value->right), value->right = inc_zebu_and_expression(subgrammar);
free_zebu_and_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_exclusive_or_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_exclusive_or_expression(value->left), value->left = inc_zebu_exclusive_or_expression(subgrammar);
free_zebu_exclusive_or_expression(subgrammar);
}
		d = value, g = 6;
		break;
	}
	case 6:
	{
		struct zebu_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_conditional_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_conditional_expression(value->inner), value->inner = inc_zebu_conditional_expression(subgrammar);
free_zebu_conditional_expression(subgrammar);
}
		d = value, g = 7;
		break;
	}
	case 56:
	{
		struct zebu_file* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_file* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->chmods.n){
while (value->chmods.n + trie->chmods.n > value->chmods.cap)
{
value->chmods.cap = value->chmods.cap << 1 ?: 1;
value->chmods.data = realloc(value->chmods.data, sizeof(*value->chmods.data) * value->chmods.cap);
}
memmove(value->chmods.data + trie->chmods.n, value->chmods.data, sizeof(*value->chmods.data) * value->chmods.n);
for (unsigned i = 0, n = trie->chmods.n; i < n; i++)
value->chmods.data[i] = inc_zebu_token(trie->chmods.data[i]);
value->chmods.n += trie->chmods.n;
}
if (trie->expression) { free_zebu_expression(value->expression); value->expression = inc_zebu_expression(trie->expression); }
if (trie->octal) { free_zebu_token(value->octal); value->octal = inc_zebu_token(trie->octal); }
if (trie->path) { free_zebu_token(value->path); value->path = inc_zebu_token(trie->path); }
free_zebu_file(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
if (value->chmods.n == value->chmods.cap)
{
value->chmods.cap = value->chmods.cap << 1 ?: 1;
value->chmods.data = realloc(value->chmods.data, sizeof(*value->chmods.data) * value->chmods.cap);
}
memmove(value->chmods.data + 1, value->chmods.data, sizeof(*value->chmods.data) * value->chmods.n);
value->chmods.data[0] = inc_zebu_token(token), value->chmods.n++;
free_zebu_token(token);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->path), value->path = inc_zebu_token(token);
free_zebu_token(token);
}
		d = value, g = 8;
		break;
	}
	case 64:
	{
		struct zebu_file* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_file* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->chmods.n){
while (value->chmods.n + trie->chmods.n > value->chmods.cap)
{
value->chmods.cap = value->chmods.cap << 1 ?: 1;
value->chmods.data = realloc(value->chmods.data, sizeof(*value->chmods.data) * value->chmods.cap);
}
memmove(value->chmods.data + trie->chmods.n, value->chmods.data, sizeof(*value->chmods.data) * value->chmods.n);
for (unsigned i = 0, n = trie->chmods.n; i < n; i++)
value->chmods.data[i] = inc_zebu_token(trie->chmods.data[i]);
value->chmods.n += trie->chmods.n;
}
if (trie->expression) { free_zebu_expression(value->expression); value->expression = inc_zebu_expression(trie->expression); }
if (trie->octal) { free_zebu_token(value->octal); value->octal = inc_zebu_token(trie->octal); }
if (trie->path) { free_zebu_token(value->path); value->path = inc_zebu_token(trie->path); }
free_zebu_file(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->octal), value->octal = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->path), value->path = inc_zebu_token(token);
free_zebu_token(token);
}
		d = value, g = 8;
		break;
	}
	case 28:
	{
		struct zebu_file* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_file* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->chmods.n){
while (value->chmods.n + trie->chmods.n > value->chmods.cap)
{
value->chmods.cap = value->chmods.cap << 1 ?: 1;
value->chmods.data = realloc(value->chmods.data, sizeof(*value->chmods.data) * value->chmods.cap);
}
memmove(value->chmods.data + trie->chmods.n, value->chmods.data, sizeof(*value->chmods.data) * value->chmods.n);
for (unsigned i = 0, n = trie->chmods.n; i < n; i++)
value->chmods.data[i] = inc_zebu_token(trie->chmods.data[i]);
value->chmods.n += trie->chmods.n;
}
if (trie->expression) { free_zebu_expression(value->expression); value->expression = inc_zebu_expression(trie->expression); }
if (trie->octal) { free_zebu_token(value->octal); value->octal = inc_zebu_token(trie->octal); }
if (trie->path) { free_zebu_token(value->path); value->path = inc_zebu_token(trie->path); }
free_zebu_file(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->path), value->path = inc_zebu_token(token);
free_zebu_token(token);
}
		d = value, g = 8;
		break;
	}
	case 8:
	{
		struct zebu_inclusive_or_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_exclusive_or_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_exclusive_or_expression(value->inner), value->inner = inc_zebu_exclusive_or_expression(subgrammar);
free_zebu_exclusive_or_expression(subgrammar);
}
		d = value, g = 9;
		break;
	}
	case 40:
	{
		struct zebu_inclusive_or_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_exclusive_or_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_exclusive_or_expression(value->right), value->right = inc_zebu_exclusive_or_expression(subgrammar);
free_zebu_exclusive_or_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_inclusive_or_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_inclusive_or_expression(value->left), value->left = inc_zebu_inclusive_or_expression(subgrammar);
free_zebu_inclusive_or_expression(subgrammar);
}
		d = value, g = 9;
		break;
	}
	case 10:
	{
		struct zebu_logical_and_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_inclusive_or_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_inclusive_or_expression(value->inner), value->inner = inc_zebu_inclusive_or_expression(subgrammar);
free_zebu_inclusive_or_expression(subgrammar);
}
		d = value, g = 10;
		break;
	}
	case 41:
	{
		struct zebu_logical_and_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_inclusive_or_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_inclusive_or_expression(value->right), value->right = inc_zebu_inclusive_or_expression(subgrammar);
free_zebu_inclusive_or_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_logical_and_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_logical_and_expression(value->left), value->left = inc_zebu_logical_and_expression(subgrammar);
free_zebu_logical_and_expression(subgrammar);
}
		d = value, g = 10;
		break;
	}
	case 11:
	{
		struct zebu_logical_or_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_logical_and_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_logical_and_expression(value->inner), value->inner = inc_zebu_logical_and_expression(subgrammar);
free_zebu_logical_and_expression(subgrammar);
}
		d = value, g = 11;
		break;
	}
	case 42:
	{
		struct zebu_logical_or_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_logical_and_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_logical_and_expression(value->right), value->right = inc_zebu_logical_and_expression(subgrammar);
free_zebu_logical_and_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_logical_or_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_logical_or_expression(value->left), value->left = inc_zebu_logical_or_expression(subgrammar);
free_zebu_logical_or_expression(subgrammar);
}
		d = value, g = 11;
		break;
	}
	case 43:
	{
		struct zebu_multiplicative_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_multiplicative_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_prefix_expression(value->inner); value->inner = inc_zebu_prefix_expression(trie->inner); }
if (trie->left) { free_zebu_multiplicative_expression(value->left); value->left = inc_zebu_multiplicative_expression(trie->left); }
if (trie->right) { free_zebu_prefix_expression(value->right); value->right = inc_zebu_prefix_expression(trie->right); }
free_zebu_multiplicative_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_multiplicative_expression(value->left), value->left = inc_zebu_multiplicative_expression(subgrammar);
free_zebu_multiplicative_expression(subgrammar);
}
		d = value, g = 12;
		break;
	}
	case 45:
	{
		struct zebu_multiplicative_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_multiplicative_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_prefix_expression(value->inner); value->inner = inc_zebu_prefix_expression(trie->inner); }
if (trie->left) { free_zebu_multiplicative_expression(value->left); value->left = inc_zebu_multiplicative_expression(trie->left); }
if (trie->right) { free_zebu_prefix_expression(value->right); value->right = inc_zebu_prefix_expression(trie->right); }
free_zebu_multiplicative_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_multiplicative_expression(value->left), value->left = inc_zebu_multiplicative_expression(subgrammar);
free_zebu_multiplicative_expression(subgrammar);
}
		d = value, g = 12;
		break;
	}
	case 46:
	{
		struct zebu_multiplicative_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_multiplicative_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_prefix_expression(value->inner); value->inner = inc_zebu_prefix_expression(trie->inner); }
if (trie->left) { free_zebu_multiplicative_expression(value->left); value->left = inc_zebu_multiplicative_expression(trie->left); }
if (trie->right) { free_zebu_prefix_expression(value->right); value->right = inc_zebu_prefix_expression(trie->right); }
free_zebu_multiplicative_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_multiplicative_expression(value->left), value->left = inc_zebu_multiplicative_expression(subgrammar);
free_zebu_multiplicative_expression(subgrammar);
}
		d = value, g = 12;
		break;
	}
	case 14:
	{
		struct zebu_multiplicative_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_prefix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_prefix_expression(value->inner), value->inner = inc_zebu_prefix_expression(subgrammar);
free_zebu_prefix_expression(subgrammar);
}
		d = value, g = 12;
		break;
	}
	case 59:
	{
		struct zebu_prefix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_prefix_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->file) { free_zebu_expression(value->file); value->file = inc_zebu_expression(trie->file); }
if (trie->inner) { free_zebu_primary_expression(value->inner); value->inner = inc_zebu_primary_expression(trie->inner); }
if (trie->shell) { free_zebu_complex_command(value->shell); value->shell = inc_zebu_complex_command(trie->shell); }
if (trie->sub) { free_zebu_prefix_expression(value->sub); value->sub = inc_zebu_prefix_expression(trie->sub); }
free_zebu_prefix_expression(trie);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression(value->file), value->file = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 13;
		break;
	}
	case 60:
	{
		struct zebu_prefix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_prefix_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->file) { free_zebu_expression(value->file); value->file = inc_zebu_expression(trie->file); }
if (trie->inner) { free_zebu_primary_expression(value->inner); value->inner = inc_zebu_primary_expression(trie->inner); }
if (trie->shell) { free_zebu_complex_command(value->shell); value->shell = inc_zebu_complex_command(trie->shell); }
if (trie->sub) { free_zebu_prefix_expression(value->sub); value->sub = inc_zebu_prefix_expression(trie->sub); }
free_zebu_prefix_expression(trie);
}
{
struct zebu_complex_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_complex_command(value->shell), value->shell = inc_zebu_complex_command(subgrammar);
free_zebu_complex_command(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 13;
		break;
	}
	case 20:
	{
		struct zebu_prefix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_prefix_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->file) { free_zebu_expression(value->file); value->file = inc_zebu_expression(trie->file); }
if (trie->inner) { free_zebu_primary_expression(value->inner); value->inner = inc_zebu_primary_expression(trie->inner); }
if (trie->shell) { free_zebu_complex_command(value->shell); value->shell = inc_zebu_complex_command(trie->shell); }
if (trie->sub) { free_zebu_prefix_expression(value->sub); value->sub = inc_zebu_prefix_expression(trie->sub); }
free_zebu_prefix_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 13;
		break;
	}
	case 22:
	{
		struct zebu_prefix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_prefix_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->file) { free_zebu_expression(value->file); value->file = inc_zebu_expression(trie->file); }
if (trie->inner) { free_zebu_primary_expression(value->inner); value->inner = inc_zebu_primary_expression(trie->inner); }
if (trie->shell) { free_zebu_complex_command(value->shell); value->shell = inc_zebu_complex_command(trie->shell); }
if (trie->sub) { free_zebu_prefix_expression(value->sub); value->sub = inc_zebu_prefix_expression(trie->sub); }
free_zebu_prefix_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 13;
		break;
	}
	case 23:
	{
		struct zebu_prefix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_prefix_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->file) { free_zebu_expression(value->file); value->file = inc_zebu_expression(trie->file); }
if (trie->inner) { free_zebu_primary_expression(value->inner); value->inner = inc_zebu_primary_expression(trie->inner); }
if (trie->shell) { free_zebu_complex_command(value->shell); value->shell = inc_zebu_complex_command(trie->shell); }
if (trie->sub) { free_zebu_prefix_expression(value->sub); value->sub = inc_zebu_prefix_expression(trie->sub); }
free_zebu_prefix_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 13;
		break;
	}
	case 24:
	{
		struct zebu_prefix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_prefix_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->file) { free_zebu_expression(value->file); value->file = inc_zebu_expression(trie->file); }
if (trie->inner) { free_zebu_primary_expression(value->inner); value->inner = inc_zebu_primary_expression(trie->inner); }
if (trie->shell) { free_zebu_complex_command(value->shell); value->shell = inc_zebu_complex_command(trie->shell); }
if (trie->sub) { free_zebu_prefix_expression(value->sub); value->sub = inc_zebu_prefix_expression(trie->sub); }
free_zebu_prefix_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 13;
		break;
	}
	case 15:
	{
		struct zebu_prefix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_primary_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_primary_expression(value->inner), value->inner = inc_zebu_primary_expression(subgrammar);
free_zebu_primary_expression(subgrammar);
}
		d = value, g = 13;
		break;
	}
	case 1:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->string), value->string = inc_zebu_token(token);
free_zebu_token(token);
}
		d = value, g = 14;
		break;
	}
	case 29:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression(value->sub), value->sub = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 14;
		break;
	}
	case 2:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->integer), value->integer = inc_zebu_token(token);
free_zebu_token(token);
}
		d = value, g = 14;
		break;
	}
	case 47:
	{
		struct zebu_relational_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_relational_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_shift_expression(value->inner); value->inner = inc_zebu_shift_expression(trie->inner); }
if (trie->left) { free_zebu_relational_expression(value->left); value->left = inc_zebu_relational_expression(trie->left); }
if (trie->right) { free_zebu_shift_expression(value->right); value->right = inc_zebu_shift_expression(trie->right); }
free_zebu_relational_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_relational_expression(value->left), value->left = inc_zebu_relational_expression(subgrammar);
free_zebu_relational_expression(subgrammar);
}
		d = value, g = 15;
		break;
	}
	case 49:
	{
		struct zebu_relational_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_relational_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_shift_expression(value->inner); value->inner = inc_zebu_shift_expression(trie->inner); }
if (trie->left) { free_zebu_relational_expression(value->left); value->left = inc_zebu_relational_expression(trie->left); }
if (trie->right) { free_zebu_shift_expression(value->right); value->right = inc_zebu_shift_expression(trie->right); }
free_zebu_relational_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_relational_expression(value->left), value->left = inc_zebu_relational_expression(subgrammar);
free_zebu_relational_expression(subgrammar);
}
		d = value, g = 15;
		break;
	}
	case 50:
	{
		struct zebu_relational_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_relational_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_shift_expression(value->inner); value->inner = inc_zebu_shift_expression(trie->inner); }
if (trie->left) { free_zebu_relational_expression(value->left); value->left = inc_zebu_relational_expression(trie->left); }
if (trie->right) { free_zebu_shift_expression(value->right); value->right = inc_zebu_shift_expression(trie->right); }
free_zebu_relational_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_relational_expression(value->left), value->left = inc_zebu_relational_expression(subgrammar);
free_zebu_relational_expression(subgrammar);
}
		d = value, g = 15;
		break;
	}
	case 51:
	{
		struct zebu_relational_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_relational_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_shift_expression(value->inner); value->inner = inc_zebu_shift_expression(trie->inner); }
if (trie->left) { free_zebu_relational_expression(value->left); value->left = inc_zebu_relational_expression(trie->left); }
if (trie->right) { free_zebu_shift_expression(value->right); value->right = inc_zebu_shift_expression(trie->right); }
free_zebu_relational_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_relational_expression(value->left), value->left = inc_zebu_relational_expression(subgrammar);
free_zebu_relational_expression(subgrammar);
}
		d = value, g = 15;
		break;
	}
	case 18:
	{
		struct zebu_relational_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_shift_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_shift_expression(value->inner), value->inner = inc_zebu_shift_expression(subgrammar);
free_zebu_shift_expression(subgrammar);
}
		d = value, g = 15;
		break;
	}
	case 19:
	{
		struct zebu_root* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_test* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->tests.n == value->tests.cap)
{
value->tests.cap = value->tests.cap << 1 ?: 1;
value->tests.data = realloc(value->tests.data, sizeof(*value->tests.data) * value->tests.cap);
}
memmove(value->tests.data + 1, value->tests.data, sizeof(*value->tests.data) * value->tests.n);
value->tests.data[0] = inc_zebu_test(subgrammar), value->tests.n++;
free_zebu_test(subgrammar);
}
		d = value, g = 16;
		break;
	}
	case 55:
	{
		struct zebu_root* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_root* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->tests.n)
{
while (value->tests.n + trie->tests.n > value->tests.cap)
{
value->tests.cap = value->tests.cap << 1 ?: 1;
value->tests.data = realloc(value->tests.data, sizeof(*value->tests.data) * value->tests.cap);
}
memmove(value->tests.data + trie->tests.n, value->tests.data, sizeof(*value->tests.data) * value->tests.n);
for (unsigned i = 0, n = trie->tests.n; i < n; i++)
value->tests.data[i] = inc_zebu_test(trie->tests.data[i]);
value->tests.n += trie->tests.n;
}
free_zebu_root(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_test* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->tests.n == value->tests.cap)
{
value->tests.cap = value->tests.cap << 1 ?: 1;
value->tests.data = realloc(value->tests.data, sizeof(*value->tests.data) * value->tests.cap);
}
memmove(value->tests.data + 1, value->tests.data, sizeof(*value->tests.data) * value->tests.n);
value->tests.data[0] = inc_zebu_test(subgrammar), value->tests.n++;
free_zebu_test(subgrammar);
}
		d = value, g = 16;
		break;
	}
	case 3:
	{
		struct zebu_shift_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_additive_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_additive_expression(value->inner), value->inner = inc_zebu_additive_expression(subgrammar);
free_zebu_additive_expression(subgrammar);
}
		d = value, g = 17;
		break;
	}
	case 52:
	{
		struct zebu_shift_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_shift_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_additive_expression(value->inner); value->inner = inc_zebu_additive_expression(trie->inner); }
if (trie->left) { free_zebu_shift_expression(value->left); value->left = inc_zebu_shift_expression(trie->left); }
if (trie->right) { free_zebu_additive_expression(value->right); value->right = inc_zebu_additive_expression(trie->right); }
free_zebu_shift_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_shift_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_shift_expression(value->left), value->left = inc_zebu_shift_expression(subgrammar);
free_zebu_shift_expression(subgrammar);
}
		d = value, g = 17;
		break;
	}
	case 54:
	{
		struct zebu_shift_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_shift_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_additive_expression(value->inner); value->inner = inc_zebu_additive_expression(trie->inner); }
if (trie->left) { free_zebu_shift_expression(value->left); value->left = inc_zebu_shift_expression(trie->left); }
if (trie->right) { free_zebu_additive_expression(value->right); value->right = inc_zebu_additive_expression(trie->right); }
free_zebu_shift_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_shift_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_shift_expression(value->left), value->left = inc_zebu_shift_expression(subgrammar);
free_zebu_shift_expression(subgrammar);
}
		d = value, g = 17;
		break;
	}
	case 30:
	{
		struct zebu_simple_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_primary_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->args.n == value->args.cap)
{
value->args.cap = value->args.cap << 1 ?: 1;
value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
}
memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
value->args.data[0] = inc_zebu_primary_expression(subgrammar), value->args.n++;
free_zebu_primary_expression(subgrammar);
}
		d = value, g = 22;
		break;
	}
	case 61:
	{
		struct zebu_simple_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_simple_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->args.n)
{
while (value->args.n + trie->args.n > value->args.cap)
{
value->args.cap = value->args.cap << 1 ?: 1;
value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
}
memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
for (unsigned i = 0, n = trie->args.n; i < n; i++)
value->args.data[i] = inc_zebu_primary_expression(trie->args.data[i]);
value->args.n += trie->args.n;
}
free_zebu_simple_command(trie);
}
{
struct zebu_primary_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->args.n == value->args.cap)
{
value->args.cap = value->args.cap << 1 ?: 1;
value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
}
memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
value->args.data[0] = inc_zebu_primary_expression(subgrammar), value->args.n++;
free_zebu_primary_expression(subgrammar);
}
		d = value, g = 22;
		break;
	}
	case 5:
	{
		struct zebu_test* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->assertions.n == value->assertions.cap)
{
value->assertions.cap = value->assertions.cap << 1 ?: 1;
value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
}
memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
free_zebu_assertion(subgrammar);
}
		d = value, g = 18;
		break;
	}
	case 25:
	{
		struct zebu_test* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_test* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->assertions.n)
{
while (value->assertions.n + trie->assertions.n > value->assertions.cap)
{
value->assertions.cap = value->assertions.cap << 1 ?: 1;
value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
}
memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
value->assertions.n += trie->assertions.n;
}
if (trie->files.n)
{
while (value->files.n + trie->files.n > value->files.cap)
{
value->files.cap = value->files.cap << 1 ?: 1;
value->files.data = realloc(value->files.data, sizeof(*value->files.data) * value->files.cap);
}
memmove(value->files.data + trie->files.n, value->files.data, sizeof(*value->files.data) * value->files.n);
for (unsigned i = 0, n = trie->files.n; i < n; i++)
value->files.data[i] = inc_zebu_file(trie->files.data[i]);
value->files.n += trie->files.n;
}
free_zebu_test(trie);
}
{
struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->assertions.n == value->assertions.cap)
{
value->assertions.cap = value->assertions.cap << 1 ?: 1;
value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
}
memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
free_zebu_assertion(subgrammar);
}
		d = value, g = 18;
		break;
	}
	case 9:
	{
		struct zebu_test* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_file* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->files.n == value->files.cap)
{
value->files.cap = value->files.cap << 1 ?: 1;
value->files.data = realloc(value->files.data, sizeof(*value->files.data) * value->files.cap);
}
memmove(value->files.data + 1, value->files.data, sizeof(*value->files.data) * value->files.n);
value->files.data[0] = inc_zebu_file(subgrammar), value->files.n++;
free_zebu_file(subgrammar);
}
		d = value, g = 18;
		break;
	}
	case 27:
	{
		struct zebu_test* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_test* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->assertions.n)
{
while (value->assertions.n + trie->assertions.n > value->assertions.cap)
{
value->assertions.cap = value->assertions.cap << 1 ?: 1;
value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
}
memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
value->assertions.n += trie->assertions.n;
}
if (trie->files.n)
{
while (value->files.n + trie->files.n > value->files.cap)
{
value->files.cap = value->files.cap << 1 ?: 1;
value->files.data = realloc(value->files.data, sizeof(*value->files.data) * value->files.cap);
}
memmove(value->files.data + trie->files.n, value->files.data, sizeof(*value->files.data) * value->files.n);
for (unsigned i = 0, n = trie->files.n; i < n; i++)
value->files.data[i] = inc_zebu_file(trie->files.data[i]);
value->files.n += trie->files.n;
}
free_zebu_test(trie);
}
{
struct zebu_file* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->files.n == value->files.cap)
{
value->files.cap = value->files.cap << 1 ?: 1;
value->files.data = realloc(value->files.data, sizeof(*value->files.data) * value->files.cap);
}
memmove(value->files.data + 1, value->files.data, sizeof(*value->files.data) * value->files.n);
value->files.data[0] = inc_zebu_file(subgrammar), value->files.n++;
free_zebu_file(subgrammar);
}
		d = value, g = 18;
		break;
	}
}
			
			if (g == 35)
			{
				free_zebu_token(td);
				yacc.n = 0, root = d;
			}
			else
			{
				y = yacc.data[yacc.n - 1];
				
				#ifdef ZEBU_DEBUG
				ddprintf("y = %u\n", y);
				#endif
				
				assert(y < N(zebu_gotos) && g < N(*zebu_gotos));
				
				s = zebu_gotos[y][g];
				
				#ifdef ZEBU_DEBUG
				ddprintf("s = %u\n", s);
				#endif
				
				y = s, push_state(y), push_data(d);
			}
		}
		else
		{
			struct zebu_token* token = td;
			
			fprintf(stderr, "zebu: unexpected token '%.*s'!\n", token->len, token->data);
			
			exit(1);
		}
	}
	
	#ifdef ZEBU_DEBUG
	print_zebu_$start(NULL, p_root, "start", root);
	#endif
	
	free(yacc.data);
	free(data.data);
	free(lexer.data);
	
	return root;
}

















